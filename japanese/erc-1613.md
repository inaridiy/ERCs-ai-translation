---
original: b2726ad3a2c85d39b74847e9dba1bb25daf4d288f366b8d3c342f572ada9c08e
---

---
eip: 1613
title: ガスステーションネットワーク
author: Yoav Weiss <yoav@tabookey.com>、Dror Tirosh <dror@tabookey.com>、Alex Forshtat <alex@tabookey.com>
discussions-to: https://github.com/yoav-tabookey/EIPs/issues/1
status: 停滞
type: 標準トラック
category: ERC
created: 2018-11-18
requires: 1077
---

## 簡単な要約
スマートコントラクト(dapps)がイーサを持たないユーザーにアクセス可能になるよう、コントラクトが「収集通話」を受け付け、着信通話の料金を支払えるようにする。
コントラクトが公開アクセス可能なチャンネル(Webの URL やWhisperアドレスなど)で「リッスン」できるようにする。
ノードが「ガスステーション」を運営し、これを促進するインセンティブを提供する。
ネットワークの変更は不要で、コントラクトの変更も最小限に抑える。

## 概要
dappsとやりとりするには ETH を支払ってガスを払う必要があり、これがdappsの普及を ETH ユーザーに制限している。
そのため、コントラクトの所有者はユーザー獲得のためにガス代を支払うことを望むかもしれないし、ユーザーにファイアト通貨でガス代を支払わせることもできる。
あるいは、第三者がある特定のコントラクトのガス代を補助したいと考えるかもしれない。
[EIP-1077](./eip-1077.md)で説明されているソリューションにより、ETHを持っていないアドレスからも取引ができるようになる。

ガスステーションネットワークは、[EIP-1077](./eip-1077.md)に準拠したものであり、ノードにガスレスの取引を「給油」するインセンティブを作り出すことで、この問題を解決しようとするものである。
実装の詳細をdappの管理者とユーザーの両方から抽象化し、既存のdappsを「収集通話」を受け付けるように簡単に変換できるようにする。

このネットワークは、参加するすべてのdappコントラクトが信頼する単一の公開コントラクト「RelayHub」と、Web やWhisperなどの非ETHインターフェースでリッスンし、取引の料金を支払い、その対価をRelayHubから受け取るインセンティブを持つ分散型のリレーノード(ガスステーション)で構成される。
RelayHubは誰でも検証できるが、それ以外のシステムはトラストレスである。
ガスステーションは、少なくとも1つの正直なガスステーションが存在する限り、取引をセンサーすることはできない。
システムを損なおうとする試みは、オンチェーンで証明でき、違反者は罰せられる。

## 動機

* スマートコントラクトの利用者を増やすため:
    * ETHを取得する手間を取り除く。取引はETHで支払われるが、コストはdappが負担するか、ユーザーが他の手段で支払うことができる。
    * ブロックチェーンと直接やりとりする必要がなく、分散化と検閲耐性は維持する。
      コントラクトは複数の公開チャンネルで「リッスン」でき、ユーザーは一般的に許可されているプロトコルを通じてコントラクトと対話できる。
* イーサノードに収益源を提供し、マイニング機器を必要としない。ネットワーク全体がノードが増えることで恩恵を受ける。
* プロトコルの変更は不要。ガスステーションネットワークはスマートコントラクトを介して自己組織化し、dappsはインターフェースを実装することでネットワークと対話する。

## 仕様

このシステムは、`RelayHub`シングルトンコントラクト、`RelayRecipient`コントラクトを継承する参加コントラクト、分散型の`Relay`ノードネットワーク(ガスステーション)、およびリレーを介してコントラクトと対話するユーザーアプリケーション(モバイルやWeb)で構成されています。

`RelayHub`の役割:

* アクティブなリレーのリストを管理する。送信者は各取引のためにこのリストからリレーを選択する。選択プロセスは以下で説明する。
* リレーとコントラクトの間の通信を仲介する。
* コントラクトに信頼できるバージョンの `msg.sender` と `msg.data` を提供する。
* リレーが置いたETHステークを保持する。最小ステークサイズが強制される。ステークは、リレーが登録を解除し、クールダウン期間を待った後に引き出すことができる。
* コントラクトが行った前払いETHを保持し、それをリレーの補償に使用する。
* 明らかに攻撃的なリレーを罰し、その証拠を提供した相手にステークを与えることで、リレーを正直に保つ。
* リレーが将来の取引で補償されるかどうかを無料で知ることができる。

`Relay`ノードの役割:

* ガス代を支払うために少額のETHを持つホットウォレットを維持する。
* ユーザーアプリがhttpsやWhisperなどのチャンネルを介してガスレスの取引を送信できるようなパブリックインターフェースを提供する。
* `RelayHub`にパブリックインターフェースとその価格(実際の取引ガスコストの乗数)を公開する。
* 必要に応じて、他のリレーの取引の失敗をRelayHubで監視し、攻撃的なリレーを捕まえてその stake を請求する。これは、リレーだけでなく誰でも行うことができる。

`RelayRecipient`コントラクトの実装:

* `RelayHub`のアドレスを知り、取引に関する情報を提供することを信頼する。
* `RelayHub`に少額のETHガス前払い預金を維持する。`RelayRecipient`コントラクトが直接支払うこともできるし、dappの所有者が`RelayRecipient`アドレスの代わりに支払うこともできる。
  dappの所有者は次の取引のための十分な残高を確保する責任があり、何か問題があれば預金を停止して、システムのバグの悪用を制限することができる。 DAOのユースケースでは、DAO論理が十分な預金を維持することになる。
* `msg.sender`と`msg.data`の代わりに、`getSender()`と`getMessageData()`を使う。`RelayRecipient`がこれらの関数を提供し、`RelayHub`から情報を取得する。
* `acceptRelayedCall(address relay, address from, bytes memory encodedFunction, uint gasPrice, uint transactionFee, bytes memory approval)`ビュー関数を実装し、取引を受け入れ、それに対して支払うことに同意する場合は**ゼロ**を返す。
  `acceptRelayedCall`は、`Relay`が問い合わせる際にRelayHubによって呼び出されるビュー関数であり、実際の取引中にも呼び出される。
  **非ゼロ**を返すと取引がリバートされ、`Relay`は(成功しても失敗しても)取引に対して補償されない。
  `acceptRelayedCall()`の実装例:
    * 信頼できるdappメンバーのホワイトリスト。
    * dappの所有者が管理する登録ユーザーの残高台帳。ユーザーはクレジットカードやその他の非ETH手段でdappに支払い、`RelayRecipient`の残高台帳にクレジットされる。
      ユーザーがdappに請求できるのは、クレジットされた額以内に限られる。
    * dappがオフチェーンで署名済みのメッセージ「approval」をトランザクション送信者に提供し、それを検証する。
    * 新規ユーザーのオンボーディングに使用される既知の取引のホワイトリスト。これにより、匿名の呼び出しが可能になるが、Sybil攻撃の対象となる。
      したがって、制限されたガス価格と信頼できるリレーのホワイトリストを組み合わせる必要がある。
      匿名のオンボーディング取引を許可するdappsは、独自の`Relay`を登録し、その`Relay`からの匿名取引のみを受け入れ、他の取引は任意のリレーから受け入れるといった方法が有効かもしれない。
      あるいは、上記の攻撃/緩和策で提案されているバランスシート方式を、オンボーディングにも使うことができる。
* `preRelayedCall(address relay, address from, bytes memory encodedFunction, uint transactionFee) returns (bytes32)`を実装する。このメソッドは、取引がリレーされる前に呼び出される。デフォルトでは何も行わない。

* `postRelayedCall(ddress relay, address from, bytes memory encodedFunction, bool success, uint usedGas, uint transactionFee, bytes32 preRetVal)`を実装する。このメソッドは、取引がリレーされた後に呼び出される。デフォルトでは何も行わない。
  
  これら2つのメソッドは、dapp固有の方法でユーザーに請求するために使用できる。 

以下のプロセスで使用される用語の定義:

* `RelayHub` - 誰もが使用する RelayHub シングルトンコントラクト。
* `Recipient` - `RelayRecipient`を実装し、RelayHubコントラクトからのリレー取引を受け入れ、着信取引の料金を支払うコントラクト。
* `Sender` - 有効な鍵ペアを持っているが ETH を持っていない外部アドレス。
* `Relay` - RelayHubに登録され、手数料を取って取引をSendersからRelayHubにリレーするETHを保有する外部アドレスを持つノード。

![シーケンス図](../assets/eip-1613/sequence.png)

`Relay`の登録/更新プロセス:

* Relayがウェブアプリ(または他の通信チャンネル)としてリッスンを開始する。
* 初めて起動する場合(まだキーがない)、Relayのアドレスの鍵ペアを生成する。
* Relayのアドレスにガス代を賄うだけの資金がない場合(たとえば新しく生成されたため)、オーナーがそれを資金提供するまで非アクティブのままになる。
* Relayのオーナーが資金を提供する。
* Relayのオーナーが必要なステークを `RelayHub` に送金して `RelayHub.stake(address relay, uint unstakeDelay)` を呼び出す。
* `RelayHub`は`relay`アドレスをインデックスとして、`owner`と`unstake delay`をリレーマップに格納する。
* Relayが `RelayHub.registerRelay(uint transactionFee, string memory url)` を呼び出し、リレーの`取引手数料`(取引ガスコストの乗数)と着信取引用の URL を提供する。 
* `RelayHub`は、Relayが十分なステークを持っていることを確認する。
* `RelayHub`は取引手数料をリレーマップに格納する。
* `RelayHub`は `RelayAdded(Relay, owner, transactionFee, relayStake, unstakeDelay, url)` イベントを発行する。
* Relayは6000ブロックごとに `keepalive` トランザクションを実行するタイマーを開始する。
* `Relay`は眠りについて、署名リクエストを待つ。

リレー取引の送信プロセス:

* `Sender`は、`RelayAdded`イベントを見て、自身の基準に基づいて生きているリレーの1つを選択する。選択は以下の要素を組み合わせて行う:
    * リレーが公開している取引手数料。
    * リレーのステークサイズとロックアップ時間。
    * 最近のリレー取引(`RelayHub`の`TransactionRelayed`イベントから確認可能)。
    * オプションで、送信アプリ自体またはそのバックエンドが保持する評判/ブラックリスト/ホワイトリスト(ガスステーションネットワークの一部ではない)。
* Senderは、Senderのアドレス、レシピエントアドレス、実際の取引データ、Relayの取引手数料、ガス価格、ガス制限、`RelayHub.nonces`からの現在のnonce、RelayHubのアドレス、Relayのアドレスを含む取引を準備し、署名する。
* Senderは、`RelayHub.balances[recipient]`に Relayの手数料を支払うだけの ETH が保持されていることを確認する。
* Senderは、`Relay.balance`に取引を送信する
だけの ETH があることを確認する。
* Senderは、`max_nonce`パラメーターを決定するために、Relayの現在の`nonce`値を読み取る。
* Senderは署名された取引とメタデータをRelayのWebインターフェースに送信する。
* `Relay`は、ゼロETH値でRelayHubへの取引でラップする。
* `Relay`はガス代を支払うためにその鍵で包装された取引に署名する。
* `Relay`は以下を確認する:
    * 取引の受信者コントラクトが、`RelayHub.canRelay()`ビュー関数を呼び出して確認すると、この取引を提出したときに受け入れる。
      これは、受信者の`acceptRelayedCall`ビュー関数も確認し、手数料の支払いに同意するかどうかを示す。
    * 取引のnonce が `RelayHub.nonces[sender]` と一致する。
    * 取引の受信者アドレスがRelayのアドレスと一致する。
    * 取引の受信者が`RelayHub`に取引手数料を支払うのに十分なETHを預けている。
    * Relayが取引に必要なガスを支払うのに十分なETHを持っている。
    * `max_nonce`の値が現在のRelayの`nonce`より高い
* Relayのチェックのいずれかが失敗した場合、エラーをSenderに返し、処理を進めない。
* Relayは署名された包装された取引をブロックチェーンに送信する。
* Relayは直ちに署名された包装された取引をSenderに返す。この手順については、後の攻撃/緩和策で説明する。
* `Sender`は包装された取引を受け取り、以下を確認する:
    * Relayのアドレスからの有効なRelayコールである。
    * 取引のイーサネットnonce がRelayの現在のnonceと一致する。
    * 取引のイーサネットnonceが`max_nonce`以下である。
    * `Relay`が取引を支払うのに十分な資金を持っている。
    * 包装された取引が有効で、`sender`によって署名されている。
    * レシピエントコントラクトが`RelayHub.balances`に、Relayの手数料を支払うのに十分な資金を持っている。
* Senderのチェックのいずれかが失敗した場合、新しいリレーを選択し直す。Senderはまた、非対応のリレーについて、バックエンドに報告するか、ローカルに保存して、将来の取引でこのリレーの順位を下げることもできる。
* `Sender`は、ガス代を支払わずに、任意のイーサノードを通じて生の包装された取引をブロックチェーンに直接送信することもできる。
  この送信は無視される可能性が高いが、二重に行っても害はない。
  これは厳密には必要ではないが(後の攻撃/緩和策で説明)、処理を早めることができる。
* `Sender`はブロックチェーンを監視し、取引がマイニングされるのを待つ。
  取引は検証済みで、Relayの現在のnonceを使っているので、Relayが別の(異なる)取引を同じnonceで送信しない限り、マイニングは成功するはずである。
  そのような攻撃によりマイニングが失敗した場合、Senderは別のリレーを通じて`RelayHub.penalizeRepeatedNonce`を呼び出し、報酬を受け取り、攻撃的なリレーの残りのステークを焼却し、新しいリレーを選択して取引を送信し直す。
  攻撃/緩和策のセクションで詳しく説明する。
* `RelayHub`は取引を受け取る:
    * `gasleft()`を`initialGas`として記録し、後の支払いに使用する。
    * 登録済みのリレーから送信されたことを確認する。
    * 内部取引の署名が、その発信元(Senderのキー)と一致することを確認する。
    * 取引に記載されているリレーアドレスが`msg.sender`と一致することを確認する。
    * 取引の`nonce`が`RelayHub.nonces`の発信元の nonce と一致することを確認する。
    * レシピエントの`acceptRelayedCall`関数を呼び出し、取引を受け入れるかどうかを確認する。受け入れない場合、`TransactionRelayed`は`CanRelayFailed`ステータスで発行され、`chargeOrCanRelayStatus`には`acceptRelayedCall`の返り値が含まれる。
      この場合、Relayは支払われない。Relayは`RelayHub.canRelay`を確認する責任があったからである。
    * レシピエントの`preRelayedCall`関数を呼び出す。この呼び出しがリバートすると、`TransactionRelayed`は`PreRelayedFailed`ステータスで発行される。
    * 取引をレシピエントに送信する。この呼び出しがリバートすると、`TransactionRelayed`は`RelayedCallFailed`ステータスで発行される。
      `call()`にガスを渡す際、`RelayHub`は後処理に十分なガスを確保する。レシピエントがガス不足になる可能性はあるが、`RelayHub`は決してそうなることはない。
      `RelayHub`はまた、`msg.data`の最後にSenderのアドレスを送信するので、`RelayRecipient.getSender()`がreal Senderを抽出し、`RelayHub`アドレスからの取引なので信頼できる。
* レシピエントコントラクトが取引を処理する。
* `RelayHub`がレシピエントの`postRelayedCall`を呼び出す。
* `RelayHub`は呼び出しの戻り値を確認し、`TransactionRelayed(address relay, address from, address to, bytes4 selector, uint256 status, uint256 chargeOrCanRelayStatus)`を発行する。
* `RelayHub`は`RelayHub.nonces[sender]`を増やす。
* `RelayHub`は、測定された取引コストに基づいて、レシピエントの残高からリレーの所有者に ETH 残高を転送し、取引手数料を支払う。
  リレー支払いに関する注意: リレーは、レシピエントがリバートしても、実際に使用したガスについて支払われる。
  リレーが損失を被るのは、`canRelay`が非ゼロを返した場合だけで、リレーはこのビューを関数を確認する責任があったからである。
  その他のリバートは捕捉され、支払われる。攻撃/緩和策を参照。
* `Relay`は送信した取引を追跡し、`TransactionRelayed`イベントを待って請求を確認する。
  取引がリバートされ、未払いの場合、つまりレシピエントの`acceptRelayedCall()`関数が一貫性がなかった場合、`Relay`はしばらくその受信者にサービスを拒否する(または頻繁に起こる場合は永久にブラックリストに登録する)。
  攻撃/緩和策を参照。

`Relay`の停止プロセス:

* Relayのオーナー(最初に資金を提供したアドレス)が`RelayHub.removeRelayByOwner(Relay)`を呼び出す。
* `RelayHub`は呼び出し元がRelayのオーナーであることを確認し、`Relay`を削除し、`RelayRemoved(Relay)`を発行する。
* `RelayHub`はオーナーのステークを解放するためのカウントダウンを開始する。
* `Relay`は`RelayRemoved`イベントを受け取る。
* `Relay`は残りのETHをオーナーに送金する。
* `Relay`はシャットダウンする。
* オーナーのアンステーク遅延が過ぎたら、オーナーは`RelayHub.unstake()`を呼び出し、ステークを引き出す。

## 根拠
ガスステーションネットワークの設計根拠は、2つの要件セットの組み合わせです。簡単な採用と堅牢性です。

簡単な採用のための設計目標は以下の通りです:

* ネットワークの変更は不要。
* コントラクト、アプリ、フレームワークへの変更は最小限に抑える。

堅牢性の要件は分散化と攻撃耐性に翻訳されます。ガスステーションネットワークは分散化されており、任意のエンティティがシステム内の他のエンティティを攻撃する可能性があると想定する必要があります。

具体的には、以下のような攻撃を考慮しています:

* 個々の送信者に対する拒否サービス攻撃、つまり取引の検閲。
* 個々のリレーに対する拒否サービスと金融攻撃。
* 個々のコントラクトに対する拒否サービスと金融攻撃。
* 既存のエンティティへの攻撃、または任意の数の悪意のあるエンティティの導入による、ネットワーク全体に対する拒否サービス攻撃。

#### 攻撃と緩和策

##### 攻撃: リレーが取引に署名しないか、ユーザーリクエストを無視することで、取引をセンサーしようとする。
リレーは署名された取引をすぐにSenderに返すことが期待されている。
Senderは取引がマイニングされるのを待つ必要はなく、リクエストが提供されたかどうかをすぐに知ることができる。
リレーが数秒以内に署名された取引を返さない場合、Senderは操作をキャンセルし、接続を切断し、別のリレーに切り替える。
また、近い将来このリレーを使わないよう、自身のプライベートストレージで「非対応」としてマークする。

したがって、このような攻撃で引き起こされる最大の被害は、数秒間の遅延に過ぎない。しばらくすると、Senderはそのリレーを完全に避けるようになる。

##### 攻撃: リレーが取引に署名し、Senderに返すが、ブロックチェーンに載せない。
この攻撃は失敗し、取引をセンサーしない。
Senderは、Relayが署名した生の取引をブロックチェーンに直接送信できるので、取引は実行されるが、Relayはそれを認識していない可能性があり、次の取引で壊れるnonce を持つことになる。

##### 攻撃: リレーが取引に署名し、同じnonceの別の取引を公開する。
nonceの再利用は、数秒以内のHTTPリクエスト中に検出できない唯一のDoSである。
それは、同じnonceの悪意のある取引がマイニングされ、`RelayHub.TransactionRelayed`イベントをトリガーしたときにしか検出されない。
しかし、この攻撃は失敗し、リレーの全ステークを失わせる。

Senderは、nonceNの Relayから署名された取引を持っており、ブロックチェーンから nonceNの Relayから署名された別の取引も受け取る。
これにより、Relayが Senderに対してDoS攻撃を行ったことが証明される。
Senderは`RelayHub.penalizeRepeatedNonce(bytes transaction1, bytes transaction2)`を呼び出し、攻撃を検証し、Relayのステークを没収し、その半分をこの`penalizeRepeatedNonce`呼び出しを行った Senderに送る。
残りの半分は`address(0)`に送られ、焼却される。これは、悪質なリレーが自分を罰して逃げ切ることを防ぐためである。
Senderはその後、新しいリレーを選択し、元の取引を送信する。

このような攻撃の結果は、数ブロックの遅延(攻撃が検出されるまで)ですが、リレーは完全に削除され、ステーク全体を失う。
このような攻撃を大規模に行うのは非常に高価で、実際にはSenderや正直なリレーにとって非常に有利である。

##### 攻撃: リレーが取引に署名し、現在のnonceよりも高いnonceを使用する。
この攻撃では、Relayは完全に有効な取引を作成して返したが、このRelayが「欠落した」取引でnonceのギャップを埋めるまでは、マイニングされない可能性がある。
これにより、一部の取引の中継が無期限に遅延する可能性がある。これを緩和するために、Senderは署名リクエストに`max_nonce`パラメーターを含める。
現在のnonceより2-3高めに設定することをお勧めする。

Senderがリレーから署名された取引を受け取ると、使用されたnonceが有効かどうかを検証し、そうでない場合、クライアントはその
リレーを無視し、他のリレーを使ってその取引をリレーする。したがって、このような攻撃による実際の遅延はない。

##### 攻撃: dappが一貫性のないacceptRelayedCall()を実装し、複数のSenderアドレスを使ってコストのかかる取引を生成することで、リレーのリソースを消耗させ、その収益性を低下させる。
この攻撃では、コントラクトが一貫性のないacceptRelayedCall(偶数ブロックではゼロ、奇数ブロックでは非ゼロを返す)を設定し、未払いの取引を通じてリレーのリソースを使い果たそうとする。
リレーは事後的にすぐに検出できる。
取引が未払いの場合、リレーはレシピエントコントラクトのacceptRelayedCallが一貫性がなかったことを知る。
なぜなら、リレーはトランザクション送信前にビュー関数を確認しているからである。
時折のレースコンディションによる状態変化の結果かもしれないが、頻繁に起こる場合、リレーはこのコントラクトをブラックリストに登録し、取引を拒否する。
1つの攻撃的なコントラクトが、リレーに2-3の取引コストを超える被害を与えることはできない。

リレーは過去のブロックチェーンを見て、未払いの取引(RelayHubによってリバートされた)の履歴を確認し、高い失敗率のコントラクトにサービスを拒否することもできる。
ある1つのコントラクトが数件のリレーに軽微な損失を与えた場合、すべてのリレーがそのコントラクトへのサービスを停止するので、それ以上の被害を与えることはできない。

この攻撃はスケールしない。なぜなら、悪意のあるコントラクトを作成するコストは、ネットワークに与える被害と同程度だからである。
すべてのリレーのリソースを使い果たすほどの被害を与えるには、膨大な ETH を集める必要がある。

さらに、dappがサービスを受ける前にRelayHubにステークを置くことを要求し、アンステーク遅延を強制することで、攻撃者が同時に十分な悪意のあるコントラクトを作成し、リレーを攻撃するのに必要な膨大な ETH を集める必要があるため、この攻撃をさらに非実用的にすることができる。
この保護は多分オーバーキルだが、攻撃がそもそもスケールしないためである。

##### 攻撃: ユーザーが自分のリレーを登録し、dappに高価な取引を送ることで、dappを盗もうとする。
悪意のあるSenderが意味のない/リバートされた取引を繰り返しdappに送り、dappにリレーの料金を支払わせる場合、
それはdappの責任でその Senderをブラックリストに登録し、acceptRelayedCallがその Senderに対して非ゼロを返すようにすることである。
収集通話は一般的に、レシピエントに知られていない匿名のSenderを対象としたものではない。
ガスステーションネットワークを利用するdappは、システム内で悪意のあるユーザーをブラックリストに登録する方法を持つべきである。

Sybil攻撃を緩和する簡単な方法は、ユーザーがクレジットカードで事前にクレジットを購入し、dappコントラクトにその残高を持たせることである。
そうすれば、acceptRelayedCall()はユーザーが十分なクレジットを持っている場合にのみゼロを返し、取引がリレーされるたびにユーザーの残高から料金を差し引くことができる。
この方法では、攻撃者は自分のリソースしか消費できない。

無料のdapp(ユーザーに料金を請求せず、ユーザーの取引を自ら支払うことを好む)の場合の変形は、Webインターフェイスでユーザー作成時にキャプチャを要求したり、Google/Facebookアカウントでログインさせたりすることで、攻撃者のアカウント作成速度を制限することである。
その過程を経たユーザーにのみ、RelayRecipientでクレジットを与える。そのようなSybil攻撃の速度は、実際の被害を引き起こすほど高くはない。

##### 攻撃: 攻撃者が信頼できないリレーを大量に登録してネットワークの可用性を低下させようとする。
リレーを登録するには RelayHub にステークを置く必要があり、ステークは、リレーが登録解除され、長いクールダウン期間(1ヶ月など)が経過した後にしか引き出せない。

信頼できないリレーは、一度だけ数秒の遅延を引き起こすことができ、その後Senderに完全にブラックリストに登録される(上記の最初の攻撃で説明)。
この軽微な遅延を引き起こし、ブラックリストに登録された後、攻撃者は別の信頼できないリレーを立ち上げるまで1ヶ月待たなければならない。
ネットワークに明らかな遅延を引き起こすほど大量の信頼できないリレーを同時に立ち上げるには、必要なステークのコストが膨大すぎる。
しかも、それらのリレーは短期間でブラックリストに登録されてしまう。

##### 攻撃: 攻撃者がリレー取引を再生しようとする。
取引にはnonceが含まれている。RelayHubは各Senderのnonceを(カウンターとして)管理している。
不正なnonceの取引はRelayHubによってリバートされる。各取引は1回しかリレーできない。

##### 攻撃: ユーザーがリレーから受け取った生の取引を実行しないため、このリレーによって署名された以降の全ての取引の実行がブロックされる
ユーザーは実際に取引を実行する必要はない。実行できれば十分である。
リレーとSenderの関係は相互不信である。上述のプロセスは、リレーが取引を実行するインセンティブを与えるので、ユーザーが実際のマイニングを待つ必要はない。

リレーが署名された取引を返したら(すぐに行うべき)、リレーは次の取引に自身のnonceを進めるためにそれを実行するインセンティブがある。
ユーザーは(しなくてもよいが)取引を実行することもできる。
この攻撃が成り立たない理由を理解するには、署名された取引がSenderに返された後の4つのシナリオを考えると良い:

1. リレーが取引を実行し、ユーザーが実行しない。このシナリオでは取引が実行されるので問題ない。これが上述の攻撃のケースである。
2. リレーが取引を実行せず、ユーザーが実行する。1と同様に、取引が実行されるので問題ない。
3. 両者が取引を実行する。保留中の取引プール内の取引は同一なので、1回だけ実行される。問題ない。
4. どちらも取引を実行しない。この場合、取引は実行されないが、リレーはnonce を進められない。現在のnonceで次の取引を提供することもできず、ユーザーが2つの異なる取引を同じnonceで持っていることを証明できるので、リレーは動けなくなる。

このマトリックスから分かるように、リレーは一度Senderに返した取引を必ず実行しなければならない。#1か#3の状態になり、#4の状態を避けるためである。
これは、ユーザーにオンチェーンの確認を待たせることなく、リレーに自分の仕事をコミットさせる方法である。

## 下位互換性

ガスステーションネットワークはスマートコントラクトと外部エンティティとして実装されており、ネットワークの変更は必要ありません。

ガスステーションネットワークのサポートを追加したdappは、既存のアプリ/ユーザーとの下位互換性を維持します。
追加されたメソッドは既存のものに上乗せされるので、既存のアプリに変更は必要ありません。

## 実装

**TabooKey**が開発中の[**ガスステーションネットワーク**](https://github.com/tabookey-dev/tabookey-gasless)の動作実装があります。
`RelayHub`、`RelayRecipient`、`web3 hooks`、`geth`内のガスステーションの実装、およびガスステーションネットワークを使用するサンプルdappで構成されています。

## 著作権
著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。