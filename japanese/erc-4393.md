---
original: d6c38017cb980f760662bbf897519bc68d88d37c9059f074659234d2cab5041f
---

---
eip: 4393
title: NFTおよびマルチトークンのマイクロペイメント
description: NFTおよびマルチトークンの保有者にチップを送信できるインターフェース
author: Jules Lai (@julesl23)
discussions-to: https://ethereum-magicians.org/t/eip-proposal-micropayments-standard-for-nfts-and-multi-tokens/7366
status: 停滞
type: Standards Track
category: ERC
created: 2021-10-24
requires: 165, 721, 1155
---

## 概要

このスタンダードは、NFTおよびマルチトークンへのチップ送信のためのスマートコントラクトインターフェースを定義しています。トークンの保有者は[EIP-20](./eip-20.md)報酬としてチップを引き出すことができます。

このEIPの目的では、マイクロペイメントは「チップ」と呼ばれる小額の金銭的取引として定義されます。これらのチップは[EIP-721](./eip-721.md) NFTおよび[EIP-1155](./eip-1155.md)マルチトークンの保有者に対する報酬として送信されます。保有者(コントローラーとも呼ばれる)は、NFTが非デジタルアセットのようなサービスを表す場合、より一般的な用語として使用されます。

## 動機

NFTやマルチトークンに対してチップを送信する安価な方法。ガス最適化されたチップトークンコントラクトを使用し、`tipBatch`関数を使ってバッチでチップを送信することで実現できます。

アプリケーションにチップサービスを簡単に実装し、NFTおよびマルチトークンの保有者を報酬することができます。ユーザーコミュニティからNFT保有者への収益の公平な分配を可能にします。

可能な限り最小限のインターフェースにすることで、さまざまなユースケースへの採用を促進します。

いくつかのユースケースは以下の通りです:

- ゲーム内購入およびその他の仮想商品
- メッセージ、投稿、音楽、ビデオコンテンツへのチップ
- 寄付/クラウドファンディング
- ロイヤリティの配布
- 課金制広告
- サービスの利用促進
- リワードカードやクーポン

これらはすべて、ブロックチェーンのセキュリティ、即時性、透明性を活用できます。

## 仕様

このスタンダード提案では、`ITipToken`インターフェースの実装によってチップ送信を可能にします。インターフェースは意図的に最小限に抑えられており、多様なユースケースに対応できるようになっています。

このEIPスタンダードを実装するスマートコントラクトは、このEIPインターフェースに記載されているすべての関数を実装しなければなりません。また、インターフェースで指定されたイベントも必ず発行しなければならず、これらのイベントのみからチップトークンコントラクトの完全な状態を再構築できるようにする必要があります。

このEIPスタンダードを実装するスマートコントラクトは、[EIP-165](./eip-165.md)のsupportsInterfaceを実装し、引数interfaceIDに0xE47A7022が渡された場合、常に真を返さなければなりません。この文書におけるrevertは、require、throw(非推奨)、revertステートメントを意味する可能性があり、エラーメッセージの有無は問わないものとします。

nft(または大文字のNFT)は、コード内およびこの文書で言及されている場合、EIP-1155の代替可能トークンを指す可能性があります。

```solidity
interface ITipToken {
    /**
        @dev NFTのチップ承認アドレスを承認したときに発行されるイベント。
        'nft'の保有者がチップ報酬を受け取ることができるようになります。
        NFTの転送イベントが発行されると、その NFTに対して承認されていたアドレスがすべて解除されます。
        注: このインターフェースのERC-165識別子は0x985A3267です。
    */
    event ApprovalForNFT(
        address[] holders,
        address indexed nft,
        uint256 indexed id,
        bool approved
    );

    /**
        @dev ユーザーがチップトークンのコントラクトアドレスまたは外部アドレスにERC-20互換トークンを預金したときに発行されるイベント。
        これはまた、その預金がチップトークンの量に交換されたことを示します。
    */
    event Deposit(
        address indexed user,
        address indexed rewardToken,
        uint256 amount,
        uint256 tipTokenAmount
    );

    /**
        @dev 保有者がERC-20互換の報酬を引き出したときに発行されるイベント。
        この報酬は、チップトークンのコントラクトアドレスまたは外部アドレスから来ます。チップトークンの実装によって異なります。
    */
    event WithdrawReward(
        address indexed holder,
        address indexed rewardToken,
        uint256 amount
    );

    /**
        @dev コンストラクタまたはイニシャライズメソッドが実行されたときに発行されるイベント。
        重要なのは、NFT保有者への報酬として使用されるERC-20互換トークン'rewardToken_'が、このタイミングで設定され、チップトークンコントラクトの存続期間中変更されないことです。
        'rewardToken_'と'tipToken_'は同じである可能性があります。
    */
    event InitializeTipToken(
        address indexed tipToken_,
        address indexed rewardToken_,
        address owner_
    );

    /**
        @dev ユーザーがNFT保有者にチップを送信するたびに発行されるイベント。
        報酬トークンアドレスと、保有者が引き出すまで保留される報酬トークンの量も含まれます。
    */
    event Tip(
        address indexed user,
        address[] holder,
        address indexed nft,
        uint256 id,
        uint256 amount,
        address rewardToken,
        uint256[] rewardTokenAmount
    );

    /**
        @notice 単一のNFTまたは複数の保有者が共有するマルチトークンのチップ承認を有効化または無効化する
        @dev NFTのsupportsInterfaceが IERC721 またはIERC1155を返さない場合、revertしなければなりません。
        'holders'のいずれかがゼロアドレスの場合、revertしなければなりません。
        'nft'がチップトークンコントラクトアドレスをオペレーターとして承認していない場合、revertしなければなりません。
        'ApprovalForNFT'イベントを発行して、承認または非承認を反映しなければなりません。
        @param holders NFTの保有者(NFTコントローラー)
        @param nft NFTコントラクトアドレス
        @param id NFTトークンID
        @param approved 'holder'が承認される場合はtrue、承認を取り消す場合はfalse
    */
    function setApprovalForNFT(
        address[] calldata holders,
        address nft,
        uint256 id,
        bool approved
    ) external;

    /**
        @notice 'holder'と'nft'のトークン'id'がsetApprovalForNFTで承認されているかどうかを確認する
        @dev NFTの所有者が変更されたかどうかは確認しません。それは実装者の責任で、所有権の変更イベントを検出し、適切な措置を講じる必要があります。
        @param holder NFTの保有者(NFTコントローラー)
        @param nft NFTコントラクトアドレス
        @param id NFTトークンID
        @return 'holder'と'nft'のトークン'id'が以前チップトークンコントラクトで承認されていた場合はtrue
    */
    function isApprovalForNFT(
        address holder,
        address nft,
        uint256 id
    ) external returns (bool);

    /**
        @notice msg.senderからNFTの単一の保有者またはマルチトークンの共有保有者にチップを送信する
        @dev 'nft'がチップ送信に承認されていない場合、revertしなければなりません。
        'nft'がゼロアドレスの場合、revertしなければなりません。
        'nft'がチップ'amount'を'holder'に焼却し、保有者のアカウントに保留中の報酬を送信しなければなりません。
        'nft'がマルチトークンで複数の保有者がいる場合、各保有者はマルチトークンの残高に比例してチップ額を受け取らなければなりません。
        'Tip'イベントを発行して、msg.senderが'nft'の保有者(者)にチップした金額を反映しなければなりません。
        @param nft NFTコントラクトアドレス
        @param id NFTトークンID
        @param amount NFTの保有者に送信するチップトークンの量
    */
    function tip(
        address nft,
        uint256 id,
        uint256 amount
    ) external;

    /**
        @notice ガス効率のために'nfts'の保有者にバッチでチップを送信する
        @dev NFTがチップ送信に承認されていない場合、revertしなければなりません。
        入力引数の長さが全て同じでない場合、revertしなければなりません。
        ユーザーアドレスのいずれかがゼロの場合、revertしなければなりません。
        エラーがある場合は、バッチ全体をrevertしなければなりません。
        各保有者に送信された金額と、どのnftに対してどのユーザーから送信されたかを再構築できるよう、'Tip'イベントを発行しなければなりません。
        @param users チップを送信するユーザーアカウント
        @param nfts チップの保有者に送信するNFTコントラクトアドレス
        @param ids 'nfts'を一意に識別するNFTトークンID
        @param amounts NFTの保有者に送信するチップトークンの量
    */
    function tipBatch(
        address[] calldata users,
        address[] calldata nfts,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external;

    /**
        @notice ERC-20互換トークンを預金してチップトークンと交換する
        @dev チップトークンの価格は、ユーザーのチップトークン残高に対する預金量の比率に応じて、各預金で異なる可能性があります。
        預金されたトークンは、チップトークンコントラクトアカウントまたは外部エスクローで保持できます。これはチップトークンの実装によって異なります。
        各チップトークンコントラクトは、1種類のERC-20互換報酬トークンのみを扱わなければなりません。
        トークンアドレスは、チップトークンのコンストラクタまたはイニシャライズメソッドで渡される必要があります。ゼロアドレスの場合、revertしなければなりません。
        'Deposit'イベントを発行し、ユーザー、預金トークンの詳細、交換されたチップトークンの量を示さなければなりません。
        @param user ユーザーアカウント
        @param amount チップトークンと交換するERC-20トークンの量。この預金は後の報酬トークンとして使用される
    */
    function deposit(address user, uint256 amount) external payable;

    /**
        @notice NFT保有者は、自身の判断で報酬としてERC-20互換トークンを引き出すことができる
        @dev 保留中の残高が不足している場合、revertしなければなりません。
        'amount'をmsg.sender(保有者)のアカウントに送信しなければなりません。
        保留中の報酬トークンの残高を'amount'引き出した分だけ減らさなければなりません。
        'WithdrawReward'イベントを発行し、引き出した保有者、報酬トークンアドレス、'amount'を示さなければなりません。
        @param amount 報酬として引き出すERC-20トークンの量
    */
    function withdrawReward(uint256 amount) external payable;

    /**
        @notice ERC-20のbalanceOfと同じ動作をし、'user'が保有するチップトークンの量
        @param user ユーザーアカウント
        @return ユーザーが保有するチップトークンの残高
    */
    function balanceOf(address user) external view returns (uint256);

    /**
        @notice ユーザーがチップを送信するときに報酬となるERC-20互換トークンの預金残高
        @param user ユーザーアカウント
        @return ユーザーが預金しているERC-20互換トークンの残高
    */
    function balanceDepositOf(address user) external view returns (uint256);

    /**
        @notice 'holder'に支払われるべき報酬トークンの量
        @dev 保留中のトークンは、チップトークンコントラクトアカウントまたは外部エスクローから来る可能性があります。チップトークンの実装によって異なります。
        @param holder NFT(複数)の保有者(NFTコントローラー)
        @return 保有者に支払われるべ
き報酬トークンの量
    */
    function rewardPendingOf(address holder) external view returns (uint256);
}

### チップと保有者への報酬

ユーザーはまず、チップトークンコントラクトに互換性のあるEIP-20を預金します。これは手数料を差し引いた上で、チップトークンと交換して保管されます。これらのチップトークンは、チップトークンコントラクトによって承認されたNFTやマルチトークンに送信できます。保有者は、これらのチップトークンを引き出して元のEIP-20預金を報酬として受け取ることができます。

### チップトークンの転送と価値計算

チップトークンの値はEIP-20預金と交換され、その逆も行われます。チップトークンの価格と、預金に対するチップトークンの発行量の比率は、チップトークンの実装者が決定します。1つの可能性は、地域ごとに固定の換算レートを設定することです。これにより、より貧しい国のユーザーも、同じ程度の感謝の気持ちを込めて、より裕福な国のユーザーと同じ数のチップを送信できるようになります。つまり、平均的な富の違いによって、実際に人気のあるNFTを発見するためのアナリティクスが歪められることがありません。これにより、クリエイターにとってもレベルプレイングフィールドが実現します。

ユーザーがチップを送信するたび、預金されたEIP-20の同等の価値がNFTまたはマルチトークンの保有者の保留中のアカウントに転送されなければなりません。そして、送信されたチップトークンは焼却されなければなりません。この同等の価値は、以下の簡単な式を使って計算されます:

_ユーザーのEIP-20預金の合計残高 _ チップ額 / ユーザーのチップトークン合計残高\*

したがって、ユーザーのチップ残高に「無料」のチップを追加することで、そのユーザーにとってのチップの全体的な価値が希釈されます。なぜなら、それらは依然としてEIP-20預金の同じ量を表しているからです。

チップトークンコントラクトがEIP-20を継承している場合、チップをユーザー間で直接転送できます。預金額はすでにチップトークンコントラクト(または外部エスクローアカウント)にあるため、ユーザーアカウントと預金残高のマッピングのみを更新すればよいです。ユーザーAからチップを焼却し、ユーザーBに、ユーザーBのEIP-20預金平均価値当たりのチップ量を維持するように新たに発行することをお勧めします。これにより、チップを送信する際の価値の変動を防ぐことができます。

EIP-20を継承していない場合、チップトークンを発行するときは、送信者がゼロアドレス、受信者がゼロアドレスの`event Transfer(address indexed from, address indexed to, uint256 value)`を必ず発行しなければなりません。このTransferイベントは、`IERC20`インターフェースのTransfer関数と同じシグネチャでなければなりません。

### ロイヤリティの分配

EIP-1155では、トークンIDの共有保有者が可能です。複数の寄稿者によって書かれた記事をNFTで表現するシナリオを考えてみましょう。ここでは、各寄稿者が保有者であり、EIP-1155トークンIDの残高に応じて、それぞれの共有割合を表すことができます。つまり、EIP-1155トークン1の保有者AとBがいる場合、保有者Aの残高が25、保有者Bの残高が75であれば、トークン1に送信されたチップは、保有者Aに25%の報酬保留、保有者Bに75%の報酬保留として分配されます。

ITipTokenコントラクトのデータ構造の例は以下の通りです:

```solidity
    /// NFT/マルチトークンのトークンIDと保有者(複数)のマッピング
    mapping(address => mapping(uint256 => address[])) private _tokenIdToHolders;

    /// ユーザーの預金残高のマッピング
    mapping(address => uint256) private _depositBalances;

    /// 保有者の報酬保留額のマッピング
    mapping(address => uint256) private _rewardsPending;
```

これにより、EIP-721コントラクトの固有のトークンIDと単一の保有者(標準に準拠するため)、およびEIP-1155コントラクトの複数のトークンIDと複数の保有者に対応できます。`tip`関数の実装では、NFT/マルチトークンアドレスとトークンIDのインデックスを使って`_tokenIdToHolders`にアクセスし、保有者の`_rewardsPending`に分配します。

ロイヤリティを直接保有者に分配するシナリオでは、`ITipToken`コントラクトの`tip`メソッドの実装は、オプションの手数料を差し引いた上で、ユーザーのアカウントから単一のNFTの保有者または複数トークンの共有保有者に直接ロイヤリー額を送信する可能性があります。この場合、チップトークンの種類が報酬トークンになります。

### 注意点

`ITipToken`インターフェースをシンプルかつ汎用的に保つため、各チップトークンコントラクトは1種類のEIP-20互換預金タイプのみを使用しなければなりません。複数のEIP-20預金に対してチップが必要な場合、必要なEIP-20互換タイプごとにチップトークンコントラクトを別々にデプロイする必要があります。したがち、ETHとBTCラッパーのEIP-20預金の両方からチップが必要な場合、チップトークンコントラクトを2つデプロイする必要があります。チップトークンコントラクトのコンストラクタでは、特定のチップトークンコントラクトに対応するEIP-20トークンアドレスを渡す必要があります。または、アップグレード可能なチップトークンコントラクトの場合、EIP-20トークンアドレスを渡すイニシャライズメソッドが必要です。

このEIPでは、EIP-20報酬預金がどこに保持されているかの詳細は提供していません。保有者が自身の報酬を引き出す際に、それらが利用可能である必要があります。推奨される実装は、預金をチップトークンコントラクトアドレスに保持することです。保有者への報酬保留残高を記録する
マッピング構造を維持することで、ユーザーがチップを送信する際に預金を移動せずに、保有者が報酬を引き出す際に、その保有者のアドレスに転送できます。

このスタンダードでは、許可されるEIP-20互換預金の種類を指定していません。チップトークン自体でも構いません。ただし、正確な預金額を把握するために、転送後に預金残高を確認することをお勧めします。EIP-20コントラクトが手数料を取り、実際の預金額が減少する可能性があるためです。

このスタンダードでは、預金やチップトークンの送信に対する払い戻し機能は指定していません。これは実装者の判断に委ねられます。この理由は、インターフェースを軽量に保ち、実装者に払い戻しの必要性を強要するのではなく、それを選択肢として残すためです。

### ガスコストの最小化

オフチェーンでチップを蓄積し、それらを一括して`tipBatch`メソッドを呼び出すことで、トランザクションの初期化コストを1回分で済ませることができます。さらに、同じユーザーが同じNFTトークンに複数のチップを送信した場合、それらをまとめてバッチの1エントリとして送信することで、オフチェーンでさらにガス節約できます。

同じNFTに送信するユーザーをグループ化することで、NFTの有効性とEIP-721かEIP-1155かの確認を、グループごとに1回行うだけで済むため、ガス節約になります。

ユーザーの預金残高と各保有者の報酬残高の on-chain ステートの更新を最小限に抑える賢明な方法を使うことで、バッチ送信時のガスコストをさらに削減できます。例えば、次のNFTが同じ場合、チェックを省略できます。これは、チップトークンコントラクトの実装者に委ねられます。最適化を行う場合でも、どのアカウントがどのNFTにチップを送ったかを、発行されたTipおよびTipBatchイベントから再構築できるようにする必要があります。

## 根拠

### 単純性

ITipTokenインターフェースは、その目的を果たすのに十分な機能を持ちつつ、可能な限り少ない関数数を使用しています。これにより、できるだけ汎用的な使用を可能にしています。

### NFTの使用

各NFTは、ブロックチェーン上に一意に保存された非代替性トークンのデジタルアセットです。アドレスとトークンIDによって一意に識別されます。暗号学的ハッシュによる真実の焼却は、ユニークなデジタルアセット、サービス、その他の契約的合意への接続に役立ちます。そのようなユースケースには以下のようなものが含まれます(ただし、想像力と受け入れ次第で限定されるものではありません):

- デジタルアート、コレクター品、音楽、ビデオ、ライセンス、証明書、イベントチケット、ENS名、ゲームアイテム、メタバースのオブジェクト、物理アイテムの真正性の証明、サービス契約など

このメカニズムにより、NFTの消費者は、NFT保有者に簡単にチップを送信し、報酬を与えることができます。

### 新しいビジネスモデル

音楽の事例を例に取ると、物理メディアからデジタル配信モデルへの移行以来、業界は寡占企業に支配されてきました。これらの企業は固定の定額制サブスクリプションモデルを運営し、そこから創作者(歌手、ミュージシャンなど)への ロイヤリティ配分額を設定してきました。チップトークンは、ファンが好きな楽曲(つまりNFT)に報酬を与える追加の方法を表します。各曲やトラックはNFTで表され、ファンはそれらに好きなチップを送信でき、一方でNFTの創作者は、チップで購入されたEIP-20報酬を受け取ることができます。分散化とトークン化によって、ファン主導の音楽業界が新たな収益をもたらし、ファンと創作者の関係をより密接なものにすると期待されます。

他の業界でも同様の精神を適用でき、第三者のコントローラーが現在存在する金銭的な支配的な役割から、より促進的な役割に移行することが期待されます。

### 保証された監査証跡

Ethereumエコシステムが成長し続けるにつれ、多くのdappsが従来のデータベースやエクスプローラーのAPIサービスに依存して、データを取得・分類しています。このEIPスタンダードは、スマートコントラクトが必ず発行するイベントログにより、正確なチップトークンおよびEIP-20報酬の残高記録を提供することを保証します。データベースやエクスプローラーは、このスタンダードを実装したチップトークンコントラクトから発行されたイベントを索引化・分類して検索できるようになります。つまり、発行されたイベントのみからチップトークンコントラクトの状態を再構築できるようになります。

## 下位互換性

チップトークンコントラクトは、EIP-20仕様と完全に互換性を持ち、トークンを直接他のユーザーに送信できる場合、transfer関数などを継承できます。ただし、balanceOfは採用され、ユーザーアドレスが保有するチップの数でなければなりません。例えば、OpenZeppelinのEIP-20トークン実装を継承する場合、そのコントラクトがチップトークンの残高を管理する責任を負います。したがって、チップトークンのbalanceOf関数は単に親(super)コントラクトのbalanceOf関数を呼び出せばよいでしょう。

チップトークンの二次市場や、トークンの種類をアドレスではなく名前で識別することが有用なその他のユースケースについては、ITipTokenインターフェースでは扱っておらず、実装者の範疇となっています。

## セキュリティ上の考慮事項

ユーザーの預金をチップトークンコントラクトまたは外部エスクローアカウントに保持し、保有者への報酬以
外に使用しないことが推奨されますが、これを強制することはできません。このスタンダードでは、保有者が報酬を引き出す際に、預金が利用可能である必要があると規定しています。

ユーザーがNFTにチップを送信する前に、NFTの保有者がチップトークンコントラクトからのチップ送信を承認する必要があります。このスタンダードでは、NFTの保有者が報酬を受け取ることを規定しています。チップトークンコントラクトのコードでは、どこに報酬が行くかが明確に示されるべきです。手数料を課す場合は、ユーザーが預金を受け入れる前に、それが明確に示されるべきです。悪意のある実装者が、潜在的なチップ収入を自身の目的のために「乗っ取る」リスクがあります。しかし、チップ処理の取引数と頻度が高いため、この種の不正は早期に発見される可能性が高いでしょう。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。