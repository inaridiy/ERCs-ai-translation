---
original: aebdfd19b8fba73bf124ae6b5d568cefb78fedb68432febca9a3a85cdd30eb58
---

---
eip: 3772
title: 圧縮された整数
description: uint256の損失圧縮を使用して、ガスコストを最大4倍改善する。
author: Soham Zemse (@zemse)
discussions-to: https://github.com/ethereum/EIPs/issues/3772
status: 停滞
type: Standards Track
category: ERC
created: 2021-08-27
---

## 概要

このドキュメントでは、ストレージのコストを最適化するために、`uint256`を`uint64`、`uint96`、`uint128`などの小さなデータ構造に圧縮することを指定しています。小さなデータ構造(「cintx」と表される)は2つの部分に分かれており、最初の部分には「significant」ビットを、もう一方には圧縮解除に必要な「shift」の数を格納します。このドキュメントには、圧縮が損失を伴うため、アンダーフローが発生する2つの圧縮解除仕様も含まれています。

## 動機

- ストレージは高価です。各ストレージスロットの初期化コストは約0.8ドル、更新コストは0.2ドル(20 gwei、2000 ETHUSD)です。
- 通常、金額は`uint256`で保存されるため、1つ全体のスロットを占めます。
- DAI の場合、ほとんど扱うのは0.001 DAIから1T DAI(または10<sup>12</sup>)の範囲です。ETHの場合は0.000001 ETHから1B ETHの範囲です。同様に、どんなスケールのトークンでも、10<sup>15</sup>の金額範囲が合理的です。
- しかし、`uint256`型では$10<sup>-18</sup>から$10<sup>58</sup>の範囲を表現できるため、ほとんどが無駄になっています。つまり、$10<sup>15</sup>を超える値や$10<sup>-3</sup>未満の値の確率分布は無視できるほど小さい(P[val > 10<sup>15</sup>] ≈ 0 and P[val < 10<sup>-3</sup>] ≈ 0)のです。
- 10<sup>15</sup>の値を表現するのに必要なビット数は log<sub>2</sub>(10<sup>15</sup>) = 50ビットです。つまり、実用的な金額範囲を表現するのに50ビット(256ビットではなく)で十分で、ほとんど差がありません。

## 仕様

この仕様では、圧縮された値を表す構造体を`cintx`と表します。ここで、xは圧縮された値全体のビット数です。実装レベルでは、`cintx`の値を格納するために`uintx`を使用できます。

### 圧縮

#### uint256をcint64(最大cint120)に圧縮

`cintx`の最右位、つまり最下位8ビットは`shift`の格納に使用され、残りのビットは`uintx`の最初の1ビットから`significant`ビットとして使用されます。

```solidity
struct cint64 { uint56 significant; uint8 shift; }

// ...

struct cint120 { uint112 significant; uint8 shift; }
```

#### uint256をcint128(最大cint248)に圧縮

`cintx`の最右位、つまり最下位7ビットは`shift`の格納に使用され、残りのビットは`uintx`の最初の1ビットから`significant`ビットとして使用されます。

> 以下のコード例では、表現のためにのみ`uint7`を使用していますが、Solidityのuintはすべて8の倍数であることに注意してください。

```solidity
struct cint128 { uint121 significant; uint7 shift; }

// ...

struct cint248 { uint241 significant; uint7 shift; }
```

例:

```
例:
uint256の値: 2**100、2進数表現: 1000000...(100個の0)
cint64 { significant: 10000000...(55個の0), shift: 00101101 (45 in decimal)}

例:
uint256の値: 2**100-1、2進数表現: 111111...(100個の1)
cint64 { significant: 11111111...(56個の1), shift: 00101100 (44 in decimal) }
```

### 圧縮解除

通常の`decompress`と`decompressRoundingUp`の2つの圧縮解除メソッドが定義されています。

```solidity
library CInt64 {
    // uint256の金額をcint64にパックする
    function compress(uint256) internal returns (cint64) {}

    // cint64を、significantビットをshiftだけ左にシフトすることで解凍する
    function decompress(cint64) internal returns (uint256) {}

    // cint64を、significantビットをshiftだけ左にシフトし、
    // shiftビットを1にすることで解凍する
    function decompressRoundingUp(cint64) internal returns (uint256) {}
}
```

#### 通常の圧縮解除

`cintx`の`significant`ビットを`uint256`空間に移動し、`shift`だけ左にシフトします。

> 注意: 以下の例では視覚的な説明のためにcint16を使用していますが、その有効桁数は8ビットなので、金額を格納するには安全ではありません。最低50ビットが必要です。

```
例:
cint16{significant:11010111, shift:00000011}
解凍後のuint256: 11010111000 // 3ビット左にシフト

例:
cint64 { significant: 11111111...(56個の1), shift: 00101100 (44 in decimal) }
解凍後のuint256: 1111...(56個の1)0000...(44個の0)
```

#### 丸め上げ付きの圧縮解除

`cintx`の`significant`ビットを`uint256`空間に移動し、`shift`だけ左にシフトし、最下位`shift`ビットを`1`にします。

```
例:
cint16{significant:11011110, shift:00000011}
丸め上げ後の解凍値: 11011110111 // 3ビット左にシフトし、0ではなく1

例:
cint64 { significant: 11111111...(56個の1), shift: 00101100 (44 in decimal) }
解凍後のuint256: 1111...(100個の1)
```

この仕様は、状態変更呼び出しのガスコストを削減するために、新しいスマートコントラクトで内部状態を管理するために使用されます。スマートコントラクトの状態にあるこれらの圧縮値は、外部の世界(他のスマートコントラクトやクライアント)に公開すべきではありません。必要に応じて、圧縮解除された値をスマートコントラクトが公開する必要があります。

## 根拠

- `significant`ビットは`cintx`の最上位部分に、`shift`ビットは最下位部分に格納されています。これは明らかな開発者の間違いを防ぐためです。例えば、2<sup>56</sup>-1未満の数値の圧縮`cint64`値は、指定された順序とは逆の場合、その値自体になります。開発者が値を圧縮解除せずに使用するのを忘れた場合でも、この場合は圧縮値と解凍値が同じなので問題ありません。
- `cint64`を使用しても、自動的にガス代の節約にはならないことに注意が必要です。Solidityコンパイラが同じストレージスロットにより多くのデータをパックする必要があります。
- 圧縮と解凍にもわずかなコストがかかります。
- この設計は2進浮動小数点表現とも見なすことができますが、EVMで浮動小数点数を使用することはこのERCの範囲外です。浮動小数点数の主な目的は、利用可能なビット数の中で可能な限り広い範囲を表現できるようにすることですが、このERCの圧縮の目的は可能な限り精度を維持することです。したがって、指数/シフトビットの最小数(つまり`uint120`まで8ビット、`uint248`まで7ビット)を指定しています。

```solidity
// 3つのスロットを使用
struct UserData1 {
    uint64 amountCompressed;
    bytes32 hash;
    address beneficiary;
}

// 2つのスロットを使用
struct UserData2 {
    uint64 amountCompressed;
    address beneficiary;
    bytes32 hash;
}
```

## 下位互換性

既知の下位互換性の問題はありません。

## 参考実装

実装レベルでは、0.8.9で導入された custom types を使うか、直接`uint64`を使うことができます。

```soldity
function compress(uint256 full) public pure returns (uint64 cint) {
    uint8 bits = mostSignificantBitPosition(full);
    if (bits <= 55) {
        cint = uint64(full) << 8;
    } else {
        bits -= 55;
        cint = (uint64(full >> bits) << 8) + bits;
    }
}

function decompress(uint64 cint) public pure returns (uint256 full) {
    uint8 bits = uint8(cint % (1 << 9));
    full = uint256(cint >> 8) << bits;
}

function decompressRoundingUp(uint64 cint) public pure returns (uint256 full) {
    uint8 bits = uint8(cint % (1 << 9));
    full = uint256(cint >> 8) << bits + ((1 << bits) - 1);
}
```

上記のgistには、`cint64`の圧縮、解凍、演算のデモロジックを含む`library CInt64`があります。gistにはまた、ライブラリの使用例を示すサンプルコントラクトもあります。

CInt64フォーマットは保存専用であり、任意の演算を行う際は、適切なロジック(decompress またはdecompressRoundingUp)を使ってuint256形式に変換する必要があります。

## セキュリティ上の考慮事項

以下のセキュリティ上の考慮事項について説明します:

1. 損失圧縮による影響
   - `cint64`のエラー見積もり
   - エラーの処理
2. `cintx`の不適切な使用による精度の低下
3. 金額以外の`uint256`の圧縮

### 1. 損失圧縮による影響

値を圧縮すると、アンダーフローが発生し、つまり最下位ビットの一部が犠牲になります。これにより、`cintx`の解凍値が実際の`uint256`値以下になります。

```solidity
uint a = 2**100 - 1; // 100個の1のバイナリ表現
uint c = a.compress().decompress();

a > c; // true
a - (2**(100 - 56) - 1) == c; // true

// 視覚的な例:
// 前: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
// 後: 1111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000
```

#### cint64のエラー見積もり

2<sup>m</sup>オーダーの`value`(2<sup>m-1</sup>以上2<sup>m</sup>未満)を考えましょう。

2<sup>m</sup> - 1 - (2<sup>m-56</sup> - 1) <= `value` <= 2<sup>m</sup> - 1 の値について、圧縮値`cvalue`は2<sup>m</sup> - 1 - (2<sup>m-56</sup> - 1)になります。

最大のエラーは2<sup>m-56</sup> - 1で、10<sup>n-17</sup>(log<sub>2</sub>(56)は17)と近似できます。ここで`n`は小数点以下の桁数+1です。

例えば、10<sup>12</sup>(1兆)オーダーの値を`cint64`に圧縮する場合、最大のエラーは10<sup>12+1-17</sup> = $10<sup>-4</sup> = $0.0001になります。つまり、4桁目以下の精度が失われます。同様に、$1,000,000を`cint64`に格納する場合、解凍値は最大で$0.0000000001小さくなります。これに対し、ストレージコストはほぼ$0.8の初期化と$0.2の更新(20 gwei、2000 ETHUSD)です。

#### エラーの処理

圧縮により値がわずかに小さくなる(アンダーフロー)ことに注意してください。しかし、整数演算の除算も同様に値を小さくする操作です。例えば、

```solidity
10000001 / 2 == 5000000 // true
```

除算の結果は常に正確ではありませんが、実際の値よりも小さくなります。ほとんどのエンジニアは、最後に除算を行うことでこの影響を減らしています。

```
1001 / 2 * 301 == 150500 // true
1001 * 301 / 2 == 150650 // true
```

除算は野生で使用されており、DeFiユーザーが少しだけ少ない引出額を受け取ることがありますが、それにも気づきません。注意
深くすれば、その影響は最小限に抑えられます。圧縮も同様に、2<sup>shift</sup>で除算することになります。これにも注意深く対処すれば、影響は最小限に抑えられます。

一般的には以下のルールに従うべきです:

1. スマートコントラクトがユーザーに圧縮された金額を転送する場合、切り捨て値(`.decompress()`を使用)を使用する。
2. スマートコントラクトがユーザーから自身に圧縮された金額を転送(引き落とし)する場合、切り上げ値(`.decompressUp()`を使用)を使用する。

上記により、スマートコントラクトが圧縮によって損失を被ることはなく、ユーザーが少額の受取または支払いをすることになります。丸めの程度はユーザーにとって十分に無視できるレベルです。また、UniswapV3などの多くのプロジェクトでも同様の切り上げ/切り捨てパターンが観察されます。

### 2. `cintx`の不適切な使用による精度の低下

開発者のミスにより圧縮を使用することで精度が失われる例です。

通常のユーザー金額は最大エントロピーが50、つまり10<sup>15</sup>(または2<sup>50</sup>)の値範囲です。そのため、significantビットを格納するのに uint56 で十分です。しかし、次の例を見てみましょう:

```solidity
uint64 sharesC = // ストレージから圧縮値を読み取る;
uint64 price = // 呼び出し;
uint64 amountC = sharesC.cmuldiv(price, PRICE_UNIT);
user.transfer(amountC.uncompress());
```

上記のコードでは深刻な精度の低下が発生します。`sharesC`のエントロピーは50ですが、`priceC`のエントロピーも50です。これらを乗算すると、両者のエントロピーを含む100のエントロピーが得られます。乗算後、`cmul`で圧縮すると、`amountC`のエントロピーが56(significantビットを格納するuint56があるため)まで下がってしまいます。

エントロピー/精度の低下を防ぐには、圧縮を解除する必要があります。

```solidity
uint64 sharesC = shares.compress();
uint64 priceC = price.compress();
uint256 amount = sharesC.uncompress() * price / PRICE_UNIT;
user.transfer(amount);
```

圧縮は書き込み時にのみ有効で、演算時は慎重に行う必要があります。

### 3. 金額以外の`uint256`の圧縮

圧縮された整数は金額のみを圧縮することを目的としています。理論的には`uint256`に10<sup>77</sup>の値を格納できますが、ほとんどの値は一様分布(つまり確率が0または極めて小さい)です。(通常の状況では、ユーザーが1000T DAIや1T ETHをコントラクトに預金することはありません。ただし、誰かがmint関数に完全なアクセス権を持っている場合は別です)。人々が扱う金額($0.001 DAIから$1Tまたは10<sup>15</sup>から10<sup>30</sup>のuint256)のみが非ゼロの分布を持っています。

この情報を表現するのに50ビットで十分で、56ビットを使って精度を丸めています。

完全に異なる確率分布を持つ何かを圧縮する場合、同じ方法を使うと問題が発生する可能性があります。`uint256`の値の分布がよくわからない場合は、圧縮を使用しないほうがよいでしょう。また、圧縮を使用する場合は、圧縮によってエッジケースが発生しないかよく検討する必要があります(前述の乗算の例など)。

### 4. 安定通貨と変動通貨の金額の圧縮

動的な`uint8 shift`値を持っているため、1百万SHIBAINU トークンや0.0002 WBTC(どちらも現時点で$10)を表現する場合でも、cint64は上位56significantビットを選択し、値の表現を行います。

ただし、コインが極端に変動する場合は問題になる可能性があります。コインが2<sup>56</sup>倍(10<sup>16</sup>倍のプライス上昇!)上がるような極端な場合、`uint56`では不十分かもしれません。このような極端に変動する通貨を格納する場合は、`cint96`や`cint128`を使って、より多くのsignificantビットを格納する必要があります。

`cint64`には56ビットのsignificantビットがありますが、必要なのは50ビットだけです。つまり6ビットの余裕があり、cint64に格納された暗号資産の$価値が64倍(2<sup>6</sup>倍)上がっても問題ありません。下がった場合も問題ありません。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)により放棄されています。