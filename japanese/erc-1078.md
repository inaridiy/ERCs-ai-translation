---
original: a064549ee42f92df2e0e8562543f8d5ca97d161c492007150ea6bd5eec34a90c
---

---
eip: 1078
title: ENSサブドメインを使用した汎用ログイン/サインアップ
author: Alex Van de Sande <avsa@ethereum.org>
discussions-to: https://ethereum-magicians.org/t/erc1077-and-1078-the-magic-of-executable-signed-messages-to-login-and-do-actions/351
status: 停滞
type: Standards Track
category: ERC
created: 2018-05-04
requires: 191, 681, 725, 1077
---

## 概要

これは、パスワード、秘密鍵のバックアップ、シードフレーズの入力を必要としない、Ethereum ネイティブのログイン/サインアップ方式を提案します。ユーザーの観点からは、中央サーバーに依存しない二段階認証と非常に似たパターンになりますが、dappの開発者にとっては、Ethereum トランザクションを新しい方法で考える必要があります。

## 簡単な要約

ユーザーの一意の識別子は、Identity と Executable Signed Messages ERCの両方を実装するコントラクトです。ユーザーはこのアドレスを直接提供する必要はなく、それを指すENS名のみを提供します。これらのタイプのコントラクトは、意図を示すメッセージに署名する秘密鍵によって間接的に制御されており、それらのメッセージは第三者(または分散型のデプロイヤーネットワーク)によってコントラクトにデプロイされます。

したがって、アプリケーションに「ログイン」するデバイスは、ローカルで秘密鍵を生成し、その鍵をそのアイデンティティのシグナーの1つとして追加する許可を要求します。この秘密鍵は、メッセージに署名するためにのみ使用されるため、Ether、トークン、資産を保持する必要はなく、紛失した場合は簡単に新しいものに置き換えることができます。ユーザーの資金はアイデンティティコントラクトに保管されます。

このコンテキストでは、Ethereum アカウントは認証トークンのようなものとして使用されます。

ログインプロセスは次のようになります:

#### 1) ユーザーからの名前の要求

プロセスの最初のステップは、ユーザーのアイデンティティを指すENS名を要求することです。ユーザーがログインを設定していない場合、アプリは(統合されたアイデンティティマネージャーがある場合)サブドメインや所有する名前を提供するオプションを提供する必要があります。

**UXメモ:** この機能を提供する方法はいくつかあります。アプリはサインアップ/ログインを事前に尋ねるか、直接名前を入力するよう求めることができます。ユーザー名が存在するかどうかを簡単に確認できるため、アプリはそれに柔軟に対応し、ユーザーに2回同じ名前を入力させる必要はありません。ユーザーがサインアップを要求し、既存の名前を入力した場合は、その名前を使ってログインするよう求めるか、既存の名前に接続しようとしたが存在しない名前を入力した場合は、ユーザーに新しい名前を作成するかどうかを尋ねるなどの対応が必要です。同じ名前を2つのフィールドに入力させないでください。

#### 2.a) 新しいアイデンティティの作成

ユーザーにアイデンティティがない場合、アプリはユーザーのために1つ作成するオプションを提供する必要があります。各アプリには、オンデマンドですぐにサブドメインを作成できる1つ以上のドメインを持っている必要があります。したがって、アプリは次のようなアクションを背景で行います:

1. 最安全な方法でローカルデバイスやブラウザに保存する秘密鍵を生成します。
2. ERC720とERC1077をサポートするアイデンティティコントラクトを作成(または設定)します。
3. ステップ1で生成した秘密鍵を、コントラクトの*唯一の*管理者キーとして登録します(アプリは回復オプションとしてを除いて、アプリ制御のキーを追加してはいけません)。
4. 要求されたサブドメインを登録し、そのオーナーシップをコントラクトに移転します(アプリがメインドメインを制御し、必要に応じてそれらを再割り当てする権利を持つ一方で、サブドメイン自体のオーナーシップはアイデンティティに属するため、ユーザーが移転できるようになります)。
5. (オプション) コントラクトに回復メソッドを登録し、メインキーが失われた場合にユーザーがコントラクトにアクセスできるようにします。

これらのすべてのステップを1つのEthereumトランザクションで設定できるように設計できます。この手順は無料ではないため、アプリはユーザー登録に料金を請求したり、アプリ独自のシビル耐性検証(キャプチャ、デバイスID登録、プルーフオブワークなど)を要求する権利を留保します。

ユーザーは、トランザクションの確認時間を待つ必要はありません。代わりに、アプリ上の何かしらの場所に進捗状況を示すインジケーターを表示し、その後ユーザーが通常どおりアプリと対話できるようにします。問題が発生した場合(同時に別のユーザーが同じユーザー名を登録した場合など)、ユーザーに対処を求めることができます。

**実装メモ:** ガスを節約するために、これらの手順の一部を事前に行うことができます。アプリは、ガス価格が低い時に少数のコントラクトを自動的にデプロイし、すべての主要な変数を0xFFFFFF...FFFFFFに設定できます。これらは「空き」と見なされ、ユーザーが登録する際にガスの割引が適用されます。これにより、ユーザーがコントラクトのアドレス/アイコンを選択できるようになるという副次的な利点もあります。

#### 2.b) 既存のアイデンティティへの接続

ユーザーが既存のアイデンティティに接続したい場合、アプリが最初に理解する必要があるのは、どのレベルの特権を要求するかです:

**マネージャー** - 最高レベルで、アイデンティティ自体を変更するようなトランザクション(キーの追加や削除など)を開始したり署名したりできます。アイデンティティマネージャーを統合している場合にのみ、このレベルを要求する必要があります。アイデンティティの設定方法によっては、これらのトランザクションをデプロイするには複数のキーの署名が必要になる可能性があります。

**アクション** - このレベルでは、自身以外のアドレスでトランザクションを開始したり署名したりできます。資金、Ether、資産などを移動できます。一般的な目的のウォレットやEthereumトランザクションを送信するブラウザーの場合にのみ、このレベルの特権を要求する必要があります。アイデンティティの設定方法によっては、これらのトランザクションをデプロイするには複数のキーの署名が必要になる可能性があります。

**暗号化** - 最低レベルで、トランザクションを開始する権限はありませんが、特定のインスタンスやオフチェーンの署名メッセージを表すために使用できます。ゲーム、チャット、ソーシャルメディアアプリなどに理想的なレベルです。ゲームに実際の資金(例えば、賭け金を使ってゲームを開始する場合)が必要な場合でも、暗号化レベルを使用し、ユーザーの主要なウォレット/ブラウザーにEthereumURIスタンダードを使ってメッセージに署名させる必要があります。

目的のレベルが分かったら、アプリは次の手順を踏む必要があります:

1. **秘密鍵を生成** し、最安全な方法でローカルデバイスやブラウザに保存します。
2. **ENSを照会** して、既存のアイデンティティアドレスを特定します。
3. `addKey(PUBLICKEY,LEVEL)`関数を呼び出すトランザクションのバイトコードを**生成**します。
4. **ウィスパーチャンネルまたは他の分散型ピアネットワーク**でトランザクション要求をブロードキャストします。この手順の詳細については、さらなる議論が必要です。
5. **web3が利用可能な場合**は、web3.eth.sendTransactionを自動的または手動で呼び出します。
6. **URIを呼び出す**: [EIP-681のトランザクション要求URL形式](./eip-681.md)をサポートしている場合は、自動的または手動で呼び出します。
7. **QRコードを表示**: EIP681互換のURLを含むQRコードを表示します。このQRコードをクリックすると、他のオプションを再試行できますが、最後に行うべきです。ステップ1が機能した場合、ユーザーは互換性のあるデバイスで通知を受け取り、QRコードを使う必要はありません。

アプリ内でローカルに生成したパブリックキーを追加するEIP681互換のアドレスの例:

`ethereum:bob.example.eth?function=addKey(address='0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',uint=1)`

新しいキーの追加に複数の署名が必要な場合、またはそのリクエストを専門に処理するアプリがイーサを保有していない場合は、次のセクションの手順に従ってトランザクションを要求する必要があります。

前述のように、ユーザーはトランザクションの確認時間を待つ必要はありません。代わりに、アプリ上の何かしらの場所に進捗状況を示すインジケーターを表示し、その後ユーザーが通常どおりアプリと対話できるようにします。

#### 3) トランザクションの要求

ステップ2の結果、アプリはユーザーのアイデンティティアドレス、メインのENS名、およびパブリックアカウントがアイデンティティのキーの1つとして登録されている秘密鍵を持つはずです。これらの情報を使って、トランザクションに署名して実行できるようになりました。

**すべてのトランザクションがオンチェーンである必要はありません**。実際、署名メッセージの一般的な用途の多くはオフチェーンです。チャットアプリの場合、ローカルキーを使ってメッセージに署名し、他のパーティーに送信し、それらのパーティーがアイデンティティコントラクトを照会してキーが実際にユーザーから来たものかどうかを確認できます。資金が賭けられているゲームの場合、初期のゲームを設定するための最初のトランザクションのみがアイデンティティによって実行される必要があります。その後の各ターンでプレイヤーは現在の盤面の状態のハッシュに署名し、最後の2つのプレイを使って勝者を決定できます。キーはいつでも取り消すことができるため、アプリはゲーム開始時にすべてのキーを保存するなどの対策を講じる必要があります。この低レベルの特権のみを必要とするキーは、レベル4(暗号化)に設定する必要があります。

オンチェーンのトランザクションが必要な場合は、次の手順に従います:

1. **TO、FROM、VALUE、DATAを特定**します。これらはEthereumトランザクションの基本要素です。`from`は、トランザクションをデプロイしたい互換性のあるコントラクトです。
2. **必要な特権レベルを確認**します。`to`と`from`フィールドが同じコントラクトの場合(つまり、アイデンティティ自体に対してアクションを実行するトランザクションの場合)、レベル1(管理)が必要です。それ以外の場合はレベル2(アクション)です。アプリが所有するキーが必要なレベルに対応していることを確認します。
3. **必要な署名の数を確認**します。target コントラクトの `requiredSignatures(uint level)` を呼び出して確認します。
4. **ガスリミットを算出**します。目的のトランザクションのガスコストを見積もり、余裕を持って追加します(推奨: 10万ガス追加)。
5. **ガストークンとガス価格を決定**します。ネットワークの混雑状況と、ユーザーが支払うトークンの市場価格を考慮して現在のガス価格を確認します。Etherの場合はガスト
ークンを0のままにし、自分でデプロイしてコストを別の場所で補助する場合はガス価格を0のままにします。
6. **実行可能な署名付きトランザクションに署名**します。その標準に従います。

署名付き実行可能メッセージを取得したら、それをチェーンにデプロイする必要があります。トランザクションが単一の署名のみを必要とする場合、アプリプロバイダー自身がそれをデプロイできます。`from`アドレスにトランザクションを送信し、`executeSigned`関数を呼び出して、収集したパラメーターと署名を使います。

トランザクションが複数の署名を必要とする場合、またはアプリにデプロイ可能なサーバーがない場合は、次の手順に従う必要があります:

1. **ウィスパーチャンネルまたは他の分散型ピアネットワーク**でトランザクションをブロードキャストします。この手順の詳細については、さらなる議論が必要です。
2. **web3が利用可能な場合**は、web3.eth.personal_signを自動的または手動で呼び出します。
3. **QRコードを表示**: 署名されたトランザクションと新しい署名データを含むQRコードを表示します。このQRコードをクリックすると、他のオプションを再試行できますが、最後に行うべきです。ステップ1が機能した場合、ユーザーは互換性のあるデバイスで通知を受け取り、QRコードを使う必要はありません。

目標は、すべてのメッセージを収集できるノードが現れるまで、ウィスパーを介して署名を継続的にブロードキャストすることです。

上記の手順に従った後、目的のトランザクションがそのアドレスのトランザクションプールに表示されるのを待ち、ユーザーをアプリに誘導します。目的のトランザクションが見つかったら、QRコードの表示を停止し、アプリを続行しながら、トランザクションの進行状況を示し続けます。目的のコントラクトの `ExecutedSigned` イベントにサブスクライブします。ノンスを持つトランザクションが表示されたら、それを成功と見なすことができます。同じまたはそれ以上のノンス(またはタイムスタンプ)を持つ別のトランザクションが表示された場合は、そのトランザクションを永久に失敗したと見なし、プロセスを再開します。

### 実装

この実装の動作サンプルはまだ存在しませんが、多くの開発者がこれを採用することに興味を示しています。この節は、そのような実装が利用可能になった際に更新されます。

### 結論と今後の改善

この方式により、Etherを保持する必要がなく、デバイス上でロックされた秘密鍵を使ってメッセージを送信したりゲームをプレイしたりできる、はるかに軽量なアプリが可能になります。メッセージのデプロイに信頼できる分散型レイヤーを作成するために、一般的な分散型メッセージングプロトコルの標準化と、オープンソースのデプロイメントノードツールの開発がさらに必要です。

### 参考文献

* [Universal Logins talk at UX Unconf, Toronto](https://www.youtube.com/watch?v=qF2lhJzngto)

## 著作権
著作権およびその関連権利は[CC0](../LICENSE.md)により放棄されています。