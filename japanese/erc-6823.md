---
original: 973806dd43074a1c542121ae61a5b8ae8730704b89ca08b1534883b4eb1d4072
---

---
eip: 6823
title: トークンマッピングスロットリトリーバル拡張
description: ERC-20/721/1155コントラクトのマッピングストレージスロットにアクセスすることで、オフチェーントランザクションシミュレーションの精度を向上させるアプローチ。
author: qdqd (@qd-qd) <qdqdqdqdqd@protonmail.com>
discussions-to: https://ethereum-magicians.org/t/eip-6823-token-mapping-slot-retrieval-extension/13666
status: Draft
type: Standards Track
category: ERC
created: 2023-03-29
requires: 20, 721, 1155
---

## 概要

この提案の目的は、[ERC-20](./eip-20.md)、[ERC-721](./eip-721.md)、または[ERC-1155](./eip-1155.md)標準に準拠するコントラクトを含むトランザクションのオフチェーンシミュレーションの精度を向上させることです。これを達成するために、コンプライアントトークンの所有権を追跡するマッピングの予約済みストレージスロットを取得する方法が提案されています。提案された拡張機能は、互換性のある方法でマッピングの予約済みストレージスロットを識別するための標準化されたエントリポイントを提供します。これにより、状態の変化をより正確に捕捉するだけでなく、特定の実装の詳細に精通することなく、外部ツールやサービスがそれを行うことができるようになります。

## 動機

この提案の根拠を理解するには、値とマッピングがストレージレイアウトにどのように格納されるかを理解することが重要です。この手順は言語非依存です。Solidityだけでなく、Vyperなどの他のプログラミング言語にも適用できます。

ストレージレイアウトは、Ethereumスマートコントラクトでデータを永続的に格納する方法です。EVMでは、ストレージはキーバリューストアとして編成されており、各キーは32バイトの場所で、各値は32バイトのワードです。コントラクトで状態変数を定義すると、ストレージの場所に割り当てられます。その場所は、変数がコントラクトのストレージ構造内の位置によって決まります。コントラクト内の最初の変数は場所0に、2番目の変数は場所1に割り当てられ、以降同様に割り当てられます。32バイト未満の複数の値は、可能であれば単一のスロットにグループ化できます。

サイズが不確定なマッピングには特殊なストレージ配置が使用されます。状態変数の間にマッピングを格納するのではなく、32バイトのみを占有し、その要素はkeccak-256ハッシュを介して計算された別個のストレージスロットに格納されます。キー`k`に対応する値の場所は、`h(k)`と`p`を連結してkeccak-256ハッシュを取ることで決まります。`p`の値は、マッピングの位置で、変数の順序と性質によって決まります。コントラクトの実装方法を知らないと、この値を一般的に決めることはできません。

マッピングの性質により、スマートコントラクトを含むトランザクションをシミュレーションするのが困難です。なぜなら、異なるコントラクトのストレージレイアウトは、変数の要件と宣言の順序によって固有のものだからです。マッピング変数の値の格納場所はこの実装依存のストレージスロットによって決まるため、オフチェーンシミュレーションバージョンとオンチェーンの試行対話が同じ結果になることを保証できません。

この障壁により、外部プラットフォームやツールがコントラクトの状態の変更を確実に捕捉/検証することができません。

そのため、トランザクションシミュレーションは主にイベントに依存しています。しかし、このアプローチには限界があり、イベントは情報提供のみを目的とし、真実の源泉としては使用すべきではありません。状態のみが真実の源泉でなければなりません。さらに、ストレージの形状を決定論的かつ一般的に知ることはできないため、ストレージの真実の源泉を検証することができず、アプリケーション層から出力される情報に頼らざるを得ません。

## 仕様

この文書の「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」のキーワードは、RFC 2119およびRFC 8174に記載されているように解釈されるものとします。

この提案は、ERC-20/ERC-721/ERC-1155標準に対する拡張機能で、コンプライアントなスマートコントラクト実装におけるマッピングタイプの予約済みストレージスロットを決定論的に取得する方法を提供します。この方法により、イベントへの依存が排除され、ストレージからのデータアクセスの精度が向上します。したがって、提案された拡張機能により、より正確なオフチェーンシミュレーションが可能になります。その結果、呼び出し側にとってコストがかからず、コントラクトのデプロイコストも僅かに増加するだけで、透明性と予測可能性が向上します。

提案された拡張機能は、ERC-20/ERC-721/ERC-1155準拠のスマートコントラクト実装におけるマッピングタイプの予約済みストレージスロットを返す単一の関数です。この関数は`getTokenLocationRoot`と名付けられ、次のように宣言されます:

```solidity
abstract contract ERC20Extension is ERC20 {
    function getTokenLocationRoot() external pure virtual returns (bytes32 slot) {
        assembly {
            slot := <mapping_name>.slot
        }
    }
}

abstract contract ERC721Extension is ERC721 {
    function getTokenLocationRoot() external pure virtual returns (bytes32 slot) {
        assembly {
            slot := <mapping_name>.slot
        }
    }
}

abstract contract ERC1155Extension is ERC1155 {
    function getTokenLocationRoot() external pure virtual returns (bytes32 slot) {
        assembly {
            slot := <mapping_name>.slot
        }
    }
}
```

これらのコントラクトでは、オフチェーンの呼び出し側が`getTokenLocationRoot()`関数を使用して、マッピングタイプの予約済みストレージスロットを見つけることができます。この関数は、コントラクト内のマッピングタイプの予約済みストレージスロットを返します。この場所は、マッピングのすべての値が格納される場所を計算するために使用されます。この値を知ることで、コントラクトの実装に関係なく、マッピングの各値が正確に格納される場所を決定できます。呼び出し側は、このスロットを使用して特定のトークンIDのストレージスロットを計算し、イベントによって示された操作の予想値と比較することができます。ERC-721のミントの場合、呼び出し側はストレージスロットの値をトークンの所有者のアドレスと比較できます。ERC-20の転送の場合、呼び出し側はストレージスロットの値をトークンの新しい所有者のアドレスと比較できます。ERC-1155のバーンの場合、呼び出し側はストレージスロットの値をゼロアドレスと比較できます。オフチェーンの比較は、利用可能な多くのツールを使用して実行できます。さらに、状態全体を証明するのではなく、特定のトークンの所有権を追跡するためのロケーションのみを証明することで、ストレージを原子的に証明することができるかもしれません。

関数名は意図的に一般的であり、さまざまなトークン標準に対して同じ実装を可能にするためです。一度、この関数が普遍的に実装されると、この関数のシグネチャから派生するセレクターが、任意のトークンコントラクトの所有権に責任を持つストレージスロットを直接読み取るための単一の汎用エントリポイントになります。これにより、オフチェーンシミュレーションの精度が大幅に向上し、イベントは情報提供の目的でのみ使用されます。

コントラクト実装者は、`getTokenLocationRoot()`関数をコントラクトに実装しなければなりません。この関数は、コントラクト内のマッピングタイプの予約済みストレージスロットを返さなければなりません。この関数は`external pure`として宣言されるべきです。

## 根拠

実装のアイデアは、現在の標準との互換性を損なわない優雅で簡潔な方法を見つけることでした。さらに、ガス消費が重要であるため、最終ユーザーにコストがかかる実装は考えられませんでした。この場合、関数の追加によりコントラクトのデプロイコストが最小限に増加しますが、その使用は外部アクターにとって完全に無料です。

実装は、可能な限り柔軟性を持ち、現在EVMのスマートコントラクト開発に使用されている主要なプログラミング言語と直接互換性を持つように最小限に抑えられています。

## 下位互換性

下位互換性の問題は見つかっていません。

## 参考実装

```solidity
abstract contract ERC20Extension is ERC20 {
    function getTokenLocationRoot() external pure virtual returns (bytes32 slot) {
        assembly {
            slot := <mapping_name>.slot
        }
    }
}

abstract contract ERC721Extension is ERC721 {
    function getTokenLocationRoot() external pure virtual returns (bytes32 slot) {
        assembly {
            slot := <mapping_name>.slot
        }
    }
}

abstract contract ERC1155Extension is ERC1155 {
    function getTokenLocationRoot() external pure virtual returns (bytes32 slot) {
        assembly {
            slot := <mapping_name>.slot
        }
    }
```

## セキュリティ上の考慮事項

この拡張機能の実装によって、セキュリティ上の問題は発生しません。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)によって放棄されています。