---
original: 45bc9867b617df090af68a1a23d8865b0049a18c192389e092e9f88dbe2572d0
---

---
eip: 2535
title: ダイヤモンド、マルチファセットプロキシ
description: 展開後に拡張可能なモジュール式スマートコントラクトシステムを作成する。
author: Nick Mudge (@mudgen)
discussions-to: https://ethereum-magicians.org/t/discussion-for-eip2535-diamonds/10459/
status: 最終
type: 標準トラック
category: ERC
created: 2020-02-22
---

## 概要

<img align="right" src="../assets/eip-2535/diamond.svg" width="230" height="230" alt="ダイヤモンドコントラクト構造">

この提案は、展開後にアップグレード/拡張が可能で、サイズ制限がほとんどないモジュール式スマートコントラクトシステムであるダイヤモンドを標準化するものです。より技術的には、**ダイヤモンド**は、**ファセット**と呼ばれる別個の契約から提供される外部関数を持つ契約です。ファセットは、内部関数、ライブラリ、状態変数を共有できる別個の独立した契約です。

## 動機

ダイヤモンドを使う理由は以下のようなものがあります。

1. **無制限のコントラクト機能を単一のアドレスで提供する。** 単一のアドレスでコントラクト機能を提供することで、展開、テスト、他のスマートコントラクト、ソフトウェア、ユーザーインターフェイスとの統合が容易になります。
1. **コントラクトのサイズが24KBの上限を超えている。** 単一のコントラクトアドレスに保持する必要のある関連機能がある場合があります。ダイヤモンドには最大サイズの制限がありません。
1. **ダイヤモンドはコントラクトコードとデータの整理方法を提供する。** 多くの機能を持つコントラクトシステムを構築したい場合があります。ダイヤモンドは、ガス効率的に異なる機能を分離し、必要に応じて接続し、データを共有する体系的な方法を提供します。
1. **ダイヤモンドは機能のアップグレードを提供する。** アップグレード可能なダイヤモンドは、機能の追加/置換/削除を行うことができます。ダイヤモンドには最大サイズの制限がないため、時間とともにダイヤモンドに追加できる機能に制限はありません。既存の機能を再展開することなく、ダイヤモンドをアップグレードできます。ダイヤモンドの一部を追加/置換/削除しながら、他の部分は変更しないままにすることができます。
1. **ダイヤモンドを不変にすることができる。** 不変のダイヤモンドを展開するか、後でアップグレード可能なダイヤモンドを不変にすることができます。
1. **ダイヤモンドは既存のデプロイ済みコントラクトを再利用できる。** ブロックチェーンにコントラクトを展開する代わりに、既に展開されているオンチェーンのコントラクトを使ってダイヤモンドを作成できます。既存のデプロイ済みコントラクトから独自のダイヤモンドを作成できます。これにより、オンチェーンのスマートコントラクトプラットフォームやライブラリの作成が可能になります。

この標準は[EIP-1538](./eip-1538.md)の改善版です。その標準の動機と同じものが、この標準にも適用されます。

展開されたファセットは、任意の数のダイヤモンドで使用できます。

以下の図は、同じ2つのファセットを使用する2つのダイヤモンドを示しています。

- `FacetA`は`Diamond1`で使用されています
- `FacetA`は`Diamond2`で使用されています
- `FacetB`は`Diamond1`で使用されています
- `FacetB`は`Diamond2`で使用されています

<img src="../assets/eip-2535/facetreuse.png" alt="ファセットの再利用">

### アップグレード可能なダイヤモンドと集中型プライベートデータベース

なぜアップグレード可能なダイヤモンドを使うのか、集中型のプライベートで変更可能なデータベースを使わないのか?

1. 分散型自治組織(DAO)やその他のガバナンスシステムを使ってダイヤモンドをアップグレードできます。
1. Ethereumエコシステムとの広範な相互作用と統合が可能です。
1. オープンなストレージデータと検証済みのソースコードにより、信頼性の履歴を示すことができます。
1. オープンであれば、悪質な行為を発見して報告することができます。
1. 独立したセキュリティおよびドメイン専門家が、コントラクトの変更履歴を確認し、その信頼性の履歴を保証することができます。
1. アップグレード可能なダイヤモンドを不変で信頼できるものにすることができます。

### ダイヤモンドのいくつかのメリット

1. 必要な機能を提供する安定したコントラクトアドレス。
1. 互いに独立しているが、内部関数、ライブラリ、状態変数を共有できる複数のコントラクト(ファセット)の機能を単一のアドレスで提供できる。
1. 単一のアドレスからイベントを発行することで、イベントの処理が簡単になる。
1. 1つのトランザクションで複数の外部関数を一括で追加、置換、削除できる。
1. 変更する必要のある部分だけを変更できる細かなアップグレードが可能。
1. いつどの関数が存在するかをより細かく制御できる。
1. 分散型自治組織(DAO)、マルチシグコントラクト、その他のガバナンスシステムを使ってダイヤモンドをアップグレードできる。
1. 関数の追加、置換、削除を示すイベントがある。
1. ダイヤモンドに加えられたすべての変更を示すことができる。
1. ダイヤモンドに加えられたすべての変更を示すことで、時間とともに信頼性を高められる。
1. ダイヤモンドの現在のファセットと関数を確認する方法がある。
1. 不変で信頼できるダイヤモンドを持つことができる。
1. 24KBの最大コントラクトサイズの制限を解決する。ダイヤモンドは任意のサイズにできる。
1. 別々のファセットに実装された機能を一緒に使うことができる。
1. 既に展開されているオンチェーンのコントラクトからダイヤモンドを作成できる。
1. 必要な完全な機能を維持するために、エラーメッセージやその他のものを削除してサイズを縮小する必要がある大規模なコントラクトに対して、ダイヤモンドは解決策となる。
1. 必要に応じて、ゼロ、部分的、または完全なダイヤモンドの不変性を実現できる。
1. アップグレード可能なダイヤモンドで徐々にアプリケーションを開発・改善し、その後、不変で信頼できるものにする機能。
1. 徐々に開発し、アプリケーションと共にダイヤモンドを成長させる。
1. バグの修正、機能の追加、新しい標準の実装のためにダイヤモンドをアップグレードする。
1. ダイヤモンドとファセットでコードを整理する。
1. ダイヤモンドは多くの関数を持つことができますが、ファセットによって分割されているため、モジュール式のままです。
1. 単一のトランザクションで複数のコントラクトを呼び出す契約アーキテクチャでは、それらのコントラクトをダイヤモンドに凝縮し、状態変数に直接アクセスすることでガスを節約できる。
1. 内部関数を共有することで、外部関数を内部関数に変換してガスを節約できる。
1. バルク転送などのガス最適化された特定のユースケースのための外部関数を作成してガスを節約できる。
1. ダイヤモンドはツールやユーザーインターフェイスソフトウェア向けに設計されている。

## 仕様

### 用語

1. **ダイヤモンド**は、ファセットにデリゲートコールして関数呼び出しを実行するファサードスマートコントラクトです。ダイヤモンドは状態を持ちます。データはダイヤモンドのコントラクトストレージに保存されます。
1. **ファセット**は、外部関数を持つステートレススマートコントラクトまたはSolidityライブラリです。ファセットは展開され、その関数の1つ以上がダイヤモンドに追加されます。ファセットは自身のコントラクトストレージにデータを保存しませんが、状態を定義し、1つ以上のダイヤモンドのストレージを読み書きできます。ファセットという用語は、ダイヤモンド業界に由来します。ダイヤモンドの側面、または平面のことを指します。
1. **ルーペファセット**は、内部観察機能を提供するファセットです。ダイヤモンド業界では、ルーペはダイヤモンドを見るために使用する拡大鏡です。
1. **不変関数**は、置換や削除ができない外部関数です(ダイヤモンドに直接定義されているため、またはダイヤモンドのロジックが変更を許可しないため)。
1. この EIP の目的では、**マッピング**は2つのものの関連付けを意味し、特定の実装を指すものではありません。

「コントラクト」という用語は、スマートコントラクトまたはデプロイ済みのSolidityライブラリを緩やかに意味しています。

この EIP で「関数」と記述する場合、特に内部関数または外部関数と指定していない限り、外部関数を意味します。

この EIP では、外部関数に適用される情報は public 関数にも適用されます。

### 概要

ダイヤモンドはファセットから関数を `delegatecall` で呼び出します。

ダイヤモンド業界では、ダイヤモンドはカットすることで作られ、ファセットが形成されます。この標準では、ファセットに関数を追加、置換、削除することでダイヤモンドがカットされます。

### インターフェースの実装に関する注意

ダイヤモンドの性質上、ダイヤモンドはインターフェースを2つの方法で実装できます。直接(`contract Contract is Interface`)、または1つ以上のファセットから関数を追加する方法です。この提案の目的上、ダイヤモンドがインターフェースを実装すると述べられている場合、これらの実装方法のいずれも許可されます。

### フォールバック関数

ダイヤモンドの外部関数が呼び出されると、そのフォールバック関数が実行されます。フォールバック関数は、呼び出しデータの最初の4バイト(関数セレクターとして知られる)に基づいてどのファセットを呼び出すかを決定し、`delegatecall`を使ってそのファセットの関数を実行します。

ダイヤモンドのフォールバック関数と `delegatecall` により、ダイヤモンド自体が実装しているかのように、ファセットの関数を実行できます。 `msg.sender` と `msg.value` の値は変わらず、ダイヤモンドのストレージのみが読み書きされます。

ダイヤモンドのフォールバック関数の実装例は以下のようになります:

```solidity
// 呼び出された関数のファセットを見つけ、ファセットが見つかった場合は
// その関数を実行し、返り値を返す。
fallback() external payable {
  // 関数セレクターからファセットを取得
  address facet = selectorTofacet[msg.sig];
  require(facet != address(0));
  // ファセットの外部関数をdelegatecallで実行し、返り値を返す。
  assembly {
    // 関数セレクターと引数をコピー
    calldatacopy(0, 0, calldatasize())
    // ファセットを使って関数呼び出しを実行
    let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
    // 返り値を取得
    returndatacopy(0, 0, returndatasize())
    // 返り値またはエラーを呼び出し元に返す
    switch result
      case 0 {revert(0, returndatasize())}
      default {return (0, returndatasize())}
  }
}
```

このダイアグ
ラムはダイヤモンドの構造を示しています:

<img src="../assets/eip-2535/DiamondDiagram.png" alt="ファセットとストレージのマッピング">

### ストレージ

状態変数またはストレージレイアウトの組織パターンが必要です。これは、Solidityの組み込みストレージレイアウトシステムがプロキシコントラクトやダイヤモンドをサポートしていないためです。具体的なストレージレイアウトは、この EIP では定義されていませんが、後の提案で定義される可能性があります。ダイヤモンドと連携するストレージレイアウトパターンの例としては、[DiamondStorage](../assets/eip-2535/storage-examples/DiamondStorage.sol)と[AppStorage](../assets/eip-2535/storage-examples/AppStorage.sol)があります。

ファセットは、同じストレージ位置の同じ構造体を使うことで、状態変数を共有できます。ファセットは、同じコントラクトを継承したり、同じライブラリを使ったりすることで、内部関数とライブラリを共有できます。このように、ファセットは別個の独立したユニットですが、状態と機能を共有できます。

以下のダイアグラムは、ファセットが独自のデータと共有データを持つ様子を示しています。

すべてのデータはダイヤモンドのストレージに保存されていますが、異なるファセットが異なるデータにアクセスできることに注意してください。

このダイアグラムでは

- `FacetA`のみが`DataA`にアクセスできます
- `FacetB`のみが`DataB`にアクセスできます
- ダイヤモンド自身のコードのみが`DataD`にアクセスできます
- `FacetA`と`FacetB`が`DataAB`を共有できます
- ダイヤモンド自身のコード、`FacetA`、`FacetB`が`DataABD`を共有できます

<img src="../assets/eip-2535/diamondstorage1.png" alt="コード、データ、ファセットのマッピング">

### ファセットとしてのSolidityライブラリ

スマートコントラクトまたはデプロイ済みのSolidityライブラリがダイヤモンドのファセットになることができます。

外部関数を1つ以上持つSolidityライブラリのみが、ブロックチェーンにデプロイされてファセットになることができます。

内部関数のみを含むSolidityライブラリはデプロイできず、ファセットにもなれません。Solidityライブラリの内部関数は、それらを使うファセットやコントラクトのバイトコードに含まれます。内部関数のみのSolidityライブラリは、ファセット間で内部関数を共有するのに役立ちます。

ファセットとして使用されるSolidityライブラリには、その用途に合った以下のような特性があります:
* 削除できない
* ステートレス。コントラクトストレージを持たない
* ダイヤモンドストレージ以外の状態変数の宣言を防ぐ構文

### 関数の追加/置換/削除

#### `IDiamond` インターフェース

すべてのダイヤモンドは `IDiamond` インターフェースを実装しなければなりません。

ダイヤモンドの展開時に、不変関数と、ダイヤモンドに追加された外部関数は、`DiamondCut` イベントで通知されなければなりません。

**外部関数が追加、置換、削除されるたびに、`DiamondCut` イベントを発行しなければなりません。** これは、`diamondCut` を通じてであれ、そうでなくてもアップグレードのすべてに、すべての関数の変更に適用されます。

```solidity
interface IDiamond {
    enum FacetCutAction {Add, Replace, Remove}
    // Add=0, Replace=1, Remove=2

    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
}
```

`DiamondCut` イベントは、ダイヤモンドへのすべての関数変更を記録します。

#### `IDiamondCut` インターフェース

ダイヤモンドには、関数セレクターとファセットアドレスのマッピングが含まれています。関数は、このマッピングを変更することで追加/置換/削除されます。

ダイヤモンドは、展開後に関数セレクターマッピングの変更を許可する場合、`IDiamondCut` インターフェースを実装する必要があります。

`diamondCut` 関数は、単一のトランザクション内で任意の数の関数を任意の数のファセットから更新します。複数のトランザクションにわたるアップグレードでは、データ破損が発生する可能性があるため、すべての変更を単一のトランザクション内で実行することが重要です。

`diamondCut` は相互運用性のために指定されています。ダイヤモンドツール、ソフトウェア、ユーザーインターフェイスは、標準の `diamondCut` 関数を期待して使用する必要があります。

```solidity
interface IDiamondCut is IDiamond {
    /// @notice 任意の数の関数を追加/置換/削除し、必要に応じて
    ///         デリゲートコールで関数を実行する
    /// @param _diamondCut ファセットアドレスと関数セレクターを含む
    /// @param _init _calldata を実行する契約またはファセットのアドレス
    /// @param _calldata 関数呼び出し、関数セレクターと引数を含む
    ///                  _calldata は _init でデリゲートコールされる
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external;
}
```

`_diamondCut` 引数は、`FacetCut` 構造体の配列です。

各 `FacetCut` 構造体には、ファセットアドレスと、ダイヤモンドで更新される関数セレクターの配列が含まれています。

各 `FacetCut` 構造体について:

 * `action` が `Add` の場合、各 `functionSelectors` 項目のファセットアドレスへの関数セレクターマッピングを更新する。マッピングされたファセットがある場合は、代わりに例外を発生させる。
 * `action` が `Replace` の場合、各 `functionSelectors` 項目のファセットアドレスへの関数セレクターマッピングを更新する。マッピングされた値が `facetAddress` と等しいか、セレクターが設定されていない場合は、代わりに例外を発生させる。
 * `action` が `Remove` の場合、各 `functionSelectors` 項目のファセントアドレスへのマッピングを削除する。以前にセットされていなかったセレクターがある場合は、代わりに例外を発生させる。

不変関数を置換または削除しようとすると、例外を発生させる必要がある。

関数の追加/置換/削除について明示的かつ慎重に行うことで、アップグレードの間違いを防ぐことができる。

##### `_calldata` の実行

関数の追加/置換/削除の後、`_calldata` 引数が `_init` でデリゲートコールされて実行される。この実行は、関数の追加、置換、削除後に必要なデータの初期化やセットアップ、または不要になったものの削除を行うために行われる。

`_init` の値が `address(0)` の場合、`_calldata` の実行はスキップされる。この場合、`_calldata` は0バイトまたはカスタム情報を含むことができる。

### ファセットと関数の検査

> ルーペは、ダイヤモンドを見るために使用される小さな拡大鏡です。

ダイヤモンドは、`IDiamondLoupe` インターフェースを実装することで、ファセットと関数の検査をサポートしなければなりません。

#### `IDiamondLoupe` インターフェース

```solidity
// ルーペはダイヤモンドを見るための小さな拡大鏡です。
// これらの関数はダイヤモンドを見ます
interface IDiamondLoupe {
    struct Facet {
        address facetAddress;
        bytes4[] functionSelectors;
    }

    /// @notice すべてのファセットアドレスとそれらの4バイトの関数セレクターを取得する。
    /// @return facets_ ファセット
    function facets() external view returns (Facet[] memory facets_);

    /// @notice 特定のファセットがサポートするすべての関数セレクターを取得する。
    /// @param _facet ファセットアドレス。
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);

    /// @notice ダイヤモンドで使用されているすべてのファセットアドレスを取得する。
    /// @return facetAddresses_
    function facetAddresses() external view returns (address[] memory facetAddresses_);

    /// @notice 指定のセレクターをサポートするファセットを取得する。
    /// @dev ファセットが見つからない場合はaddress(0)を返す。
    /// @param _functionSelector 関数セレクター。
    /// @return facetAddress_ ファセットアドレス。
    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
}
```

[リファレンス実装](#リファレンス実装)を参照して、これがどのように実装できるかを確認してください。

ルーペ関数は、ユーザーインターフェイスソフトウェアで使用できます。ユーザーインターフェイスはこれらの関数を呼び出して、ダイヤモンドに関する情報を提供し、可視化できます。

ルーペ関数は、展開機能、アップグレード機能、テスト、その他のソフトウェアで使用できます。

### 実装ポイント

ダイヤモンドは以下を実装しなければなりません:

1. ダイヤモンドにはフォールバック関数と、ダイヤモンド内部で定義された0個以上の不変関数が含まれている。
1. ダイヤモンドは関数セレクターとファセットを関連付ける。
1. ダイヤモンドで関数が呼び出されると、それが「不変関数」であれば即座に実行される。そうでなければ、ダイヤモンドのフォールバック関数が実行される。フォールバック関数は関数に関連付けられたファセットを見つけ、`delegatecall`を使ってその関数を実行する。ファセットがない場合は、オプションでデフォルト関数が実行される。ファセットがなく、デフォルト関数もなく、それ以外の対処方法もない場合は、実行が巻き戻される。
1. 関数が追加、置換、削除されるたびに、`DiamondCut` イベントが発行されて記録される。
1. ダイヤモンドは DiamondLoupe インターフェースを実装する。
1. すべての不変関数は、新しく追加された関数として `DiamondCut` イベントで通知されなければならない。ルーペ関数は、不変関数が存在する場合、それに関する情報を返さなければならない。不変関数のファセットアドレスはダイヤモンドのアドレスである。不変関数を削除または置換しようとすると、例外を発生させる必要がある。

ダイヤモンドは以下を実装できます:

1. [EIP-165](./eip-165.md)の `supportsInterface`。ダイヤモンドに `diamondCut` 関数がある場合、使用されるインターフェースIDは `IDiamondCut.diamondCut.selector` です。ダイヤモンドルーペインターフェースに使用されるインターフェースIDは `IDiamondLoupe.facets.selector ^ IDiamondLoupe.facetFunctionSelectors.selector ^ IDiamondLoupe.facetAddresses.selector ^ IDiamondLoupe.facetAddress.selector` です。

ダイヤモンドのアドレスは、ユーザーが対話するアドレスです。ダイヤモンドのアドレスは変わりません。ファセットアドレスのみが、`diamondCut` 関数、またはその他の関数を使って変更できます。

## 根拠

### 関数セレクターの使用

ユーザーインターフェイスソフトウェアは、ダイヤモンドから関数セレクターとファセットアドレスを取得して、ダイヤモンドが持つ関数を表示できます。

この標準は、ユーザーインターフェイスソフトウェアとうまく連携するようにダイヤモンドを設計しています。コントラクトのABIとともに提供される関数セレクターは、ユーザーインターフェイスソフトウェアに
とって有用な情報を提供します。

### ガス消費の考慮

関数呼び出しのデリゲートには、いくらかのガスオーバーヘッドがあります。これは以下の方法で軽減されます:

1. ダイヤモンドには最大サイズの制限がないため、ガス最適化された関数をユースケース用に追加できます。例えば、ダイヤモンドを使って[EIP-721](./eip-721.md)標準を実装し、ガスを節約(およびバッチ転送をより便利に)するためのバッチ転送関数を実装できます。
1. 1つのトランザクションで複数のコントラクトを呼び出す必要がある一部のコントラクトアーキテクチャでは、それらのコントラクトをダイヤモンドに凝縮し、直接コントラクトストレージにアクセスすることでガス節約ができます。
1. ファセットには少数の外部関数しか含まれないため、ガスコストが削減される。関数が多数ある契約を呼び出すよりも、関数が少ない契約を呼び出す方がガスが安い。
1. Solidityのオプティマイザを高い設定にすると、より多くのバイトコードが生成されますが、ファセットの実行時のガス消費が低くなります。

### 関数のバージョン

ソフトウェアやユーザーは、`facetAddress` 関数(` IDiamondLoupe` インターフェースから)を呼び出して、どのバージョンの関数が呼び出されているかを確認できます。この関数は関数セレクターを引数として受け取り、それが実装されているファセットアドレスを返します。

### デフォルト関数

Solidityでは `fallback` 関数を提供しており、コントラクトに存在しない関数が呼び出された場合に特定の機能を実行できます。同様の動作をダイヤモンドで実装するには、デフォルト関数を実装して使用することができます。デフォルト関数は、ダイヤモンドに存在しない関数が呼び出された場合に実行される関数です。

デフォルト関数は複数の方法で実装できますが、この標準では実装方法を指定していません。

### ルーペ関数と `DiamondCut` イベント

通常のコントラクトが持つ関数を知るには、検証済みのソースコードを見るだけで十分です。

ダイヤモンドの検証済みソースコードには、そのコントラクトが持つ関数が含まれていないため、別のメカニズムが必要です。

ダイヤモンドには、ダイヤモンドが持つ関数を示すための4つの標準関数、ルーペ関数があります。

ルーペ関数は以下のようなことに使用できます:
1. ダイヤモンドが使用するすべての関数を表示する。
2. Etherscanやファイルからダイヤモンドが使用するすべてのソースコードを取得して表示する。
3. EtherscanやファイルからダイヤモンドのABI情報を取得する。
4. 関数の追加/置換/削除のトランザクションが成功したことを確認するためにテストや検証に使用する。
5. ダイヤモンドの関数を呼び出す前に、ダイヤモンドが持つ関数を知るために使用する。
6. ツールやプログラミングライブラリがダイヤモンドを展開およびアップグレードするために使用する。
7. ユーザーインターフェイスがダイヤモンドに関する情報を表示するために使用する。
8. ユーザーインターフェイスがユーザーにダイヤモンドの関数を呼び出させるために使用する。

ダイヤモンドはさらに別の形の透明性をサポートしています。それは、ダイヤモンドに加えられたすべてのアップグレードの履歴記録です。これは `DiamondCut` イベントを使って行われ、ダイヤモンドに追加、置換、削除された関数をすべて記録します。

### ファセット間での関数の共有

場合によっては、別のファセットで定義された関数を呼び出す必要があるかもしれません。これを行う方法は以下のようなものがあります:

1. 1つのファセットの内部関数のコードを別のファセットにコピーする。
2. 共通の内部関数を複数のファセットが継承するコントラクトに置く。
3. 共通の内部関数をSolidityライブラリに置き、ファセットでそのライブラリを使う。
4. 別のファセットで定義された外部関数を型安全に呼び出す方法は、以下のようにすることです: `MyOtherFacet(address(this)).myFunction(arg1, arg2)`
5. 別のファセットで定義された外部関数をより効率的に呼び出す方法は、デリゲートコールを使うことです。以下はその例です:
```solidity
DiamondStorage storage ds = diamondStorage();
bytes4 functionSelector = bytes4(keccak256("myFunction(uint256)"));
// 関数のファセットアドレスを取得
address facet = ds.selectorToFacet[functionSelector];
bytes memory myFunctionCall = abi.encodeWithSelector(functionSelector, 4);
(bool success, bytes memory result) = address(facet).delegatecall(myFunctionCall);
```
6. 別のファセットで定義された外部関数の代わりに、内部関数バージョンを作成することもできます。その内部関数バージョンをそれを必要とするファセットに追加します。

### ファセットは再利用可能で構成可能

展開されたファセットは、任意の数のダイヤモンドで使用できます。

異なるダイヤモンドで、異なるファセットの組み合わせを使用できます。

再利用可能なファセットのセットを作成し、それらを異なるダイヤモンドで使い回すことができます。

同じデプロイ済みファセットを複数のダイヤモンドで使うことで、デプロイコストを削減できます。

ファセットを、他のファセットと使用/構成/互換性のあるように実装することも、そうでないように実装することもできます。

関数シグネチャは、関数名と引数の型です。例: `myfunction(uint256)`。制限として、同じ関数シグネチャを持つ2つの外部関数を同じダイヤモンド(または任意のコントラクト)に追加することはできません。

ファセットのすべての関数をダイヤモンドに追加する必要はありません。ファセットの一部の関数のみをダイヤモンドに追加できます。

## 下位互換性

この標準は、新しい標準や機能を追加したり、既存の関数を置換または削除したりすることで、アップグレード可能なダイヤモンドとの下位互換性を確保します。

## リファレンス実装

リファレンス実装のすべてのSolidityコードが1つのファイルにまとめられています: [Diamond.sol](../assets/eip-2535/reference/Diamond.sol)

同じリファレンス実装が複数のファイルとディレクトリに整理されており、デプロイスクリプトとテストも含まれています。ダウンロードはこちら: [`EIP2535-Diamonds-Reference-Implementation.zip`](../assets/eip-2535/reference/EIP2535-Diamonds-Reference-Implementation.zip)

## セキュリティ上の考慮事項

### 所有権と認証

> **注意:** ダイヤモンドの所有権/認証の設計と実装は、この標準の一部ではありません。この標準と参考実装で示されている例は、**例**にすぎません。

この提案では、さまざまな認証または所有権スキームを作成できます。認証スキームは非常に単純でも複雑でも、細かい粒度でも粗い粒度でも構いません。この提案はそれを何も制限しません。例えば、所有権/認証は、単一のアカウントアドレスが関数の追加/置換/削除の権限を持つというシンプルなものから、分散型自治組織が特定の関数の追加/置換/削除のみ許可するというものまで、さまざまな形態が考えられます。

複数の異なる人が呼び出して変更を承認してから、`diamondCut` 関数で実行するといった、承認機能を実装することもできます。これらはあくまで例です。

ダイヤモンドの所有権、制御、認証に関する標準と実装の開発が奨励されます。

### `diamondCut`による任意の実行

`diamondCut` 関数は、ダイヤモンドのストレージにアクセスできる(`delegatecall`を通じて)任意の実行を許可します。この関数へのアクセスは慎重に制限する必要があります。

### 自己破壊の禁止
ファセットでの `selfdestruct` の使用は強く推奨されません。誤用すると、ダイヤモンドやファセットが削除される可能性があります。

### 関数セレクターの衝突

関数セレクターの衝突は、2つの異なる関数シグネチャが同じ4バイトのハッシュになる場合に発生します。これにより、新しい関数を追加しようとしたのに、既存の関数が置き換えられてしまう予期せぬ結果が生じる可能性があります。適切に実装された `diamondCut` 関数を使えば、この問題は発生しません。なぜなら、既に存在するセレクターの追加を防ぐからです。

### 透明性

ダイヤモンドは、1つ以上の関数が追加、置換、削除されるたびにイベントを発行します。すべてのソースコードを検証できます。これにより、人とソフトウェアがコントラクトの変更を監視できます。ダイヤモンドに悪意のある関数が追加された場合、それを発見できます。

セキュリティおよびドメイン専門家が、ダイヤモンドの変更履歴を確認して、悪意のある履歴がないかを検出できます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。