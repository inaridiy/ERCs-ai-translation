---
original: f8f33831b5b08d9ccdcc5bb5069e4adc472c74edb2304efce2ded21181ae815c
---

---
eip: 5773
title: コンテキスト依存型マルチアセットトークン
description: オーナーの好みによって制御されるアセットタイプの出力を持つマルチアセットトークンのインターフェース。
author: Bruno Škvorc (@Swader), Cicada (@CicadaNCR), Steven Pineda (@steven2308), Stevan Bogosavljevic (@stevyhacker), Jan Turk (@ThunderDeliverer)
discussions-to: https://ethereum-magicians.org/t/multiresource-tokens/11326
status: 最終
type: 標準トラック
category: ERC
created: 2022-10-10
requires: 165, 721
---

## 概要

マルチアセットNFTスタンダードは、コンテキスト依存の情報出力を持つ新しいプリミティブの構築を可能にします。

コンテキスト依存の情報出力とは、トークンがどのように アクセスされるかに応じて、適切な形式のアセットが表示されることを意味します。例えば、トークンがe-bookリーダーで開かれた場合はPDFアセットが表示され、マーケットプレイスで開かれた場合はPNGやSVGアセットが表示され、ゲーム内からアクセスされた場合は3Dモデルアセットが表示され、IoT(Internet of Things)ハブからアクセスされた場合は必要なアドレッシングと仕様情報を提供するアセットが表示されます。

NFTには複数のアセット(出力)を持つことができ、これらは任意のファイル形式で消費者に提供されます。これらのアセットは優先順位順に並べられます。mimetype やtokenURIが一致する必要はなく、互いに依存することもありません。アセットは独立したエンティティではなく、NFTの所有者によって任意の順序で並べ替えることができますが、トークンの所有者とトークンの発行者の両方の合意がない限り、変更、更新、追加、または削除することはできません。

## 動機

Ethereum エコシステムでは、NFTが広く使用されるトークンの形式となっており、様々なユースケースに使用されています。そのため、NFTの追加機能を標準化する時期が来ています。単一のNFTに複数のアセットを関連付けることで、より大きな効用、使いやすさ、前方互換性が得られます。

[ERC-721](./eip-721.md)が公開されてから4年が経ち、追加機能の必要性から数多くの拡張が行われてきました。このEIPは以下の点でERC-721を改善しています:

- [クロスメタバース互換性](#クロスメタバース互換性)
- [マルチメディア出力](#マルチメディア出力)
- [メディアの冗長性](#メディアの冗長性)
- [NFTの進化](#nftの進化)

### クロスメタバース互換性

この提案書を書いている時点では、メタバースはまだ発展途上で、完全に定義されていません。メタバースの定義がどのように進化しても、この提案は様々な実装をサポートできます。

クロスメタバース互換性は、クロスエンジン互換性とも呼ばれます。ゲームAのコスメティックアイテムがゲームBで使えない例がこれに当たります。これは、フレームワークが互換性がないためです。

このようなNFTにさらなる効用を与えるために、新しい追加アセットを付与することができます:より多くのゲーム、より多くのコスメティックアイテムなどを、同じNFTに追加することができます。つまり、ゲームのコスメティックアイテムとしてのNFTは、無限の効用を持つ常に進化し続けるNFTになります。

より具体的な例を挙げると、1つのアセットはゲームAのコスメティックアイテムのファイル、別のアセットはゲームBのコスメティックアセットファイル、3つ目はカタログ、マーケットプレイス、ポートフォリオトラッカーなどの一般的なNFTビューアで表示されるためのジェネリックアセット(コスメティックアイテムの表現、スタイライズされたサムネイル、アニメーションデモ/トレーラーなど)です。

このEIPは抽象化レイヤーを追加することで、ゲーム開発者がユーザーのNFTからダイレクトにアセットデータを取得できるようになります。

### マルチメディア出力

電子書籍のNFTは、ロードするソフトウェアに応じて、PDFやMP3などの形式で表現できます。電子書籍リーダーでロードされた場合はPDFが表示され、オーディオブックアプリケーションでロードされた場合はMP3表現が使用されます。その他のメタデータ(おそらく本の表紙画像など)は、マーケットプレイス、検索エンジン結果ページ(SERP)、ポートフォリオトラッカーなどでの識別に使用できます。

### メディアの冗長性

多くのNFTは最良の実践を考慮せずに急ぐように作られています。具体的には、多くのNFTのメタデータがどこかのサーバー上で集中管理されているか、時にはIPFSゲートウェイにハードコーディングされており、これらも停止する可能性があります。

同じメタデータファイルを異なるアセットとして追加する(例えば、Arweaveのメタデータとリンクされた画像、Siaのこの組み合わせ、IPFSのこの組み合わせなど)ことで、メタデータとその参照情報の耐性が指数関数的に高まります。これは、すべてのプロトコルが同時に停止する可能性が低くなるためです。

### NFTの進化

特にゲーム関連のNFTは、進化が必要です。これは、メタバースと呼ばれるものの多くが実際はユーザー名/パスワードログインを置き換えるだけのマルチプレイヤーゲームにすぎず、ユーザーのNFTバランスを読み取るだけのものである現代のメタバースの場合に特に当てはまります。

サーバーが停止したり、ゲームが閉鎖された場合、プレイヤーは何も残らない(経験値の損失)か、関連性のないものが残る(ゲーム体験とは無関係のアセットやアクセサリ、他の「バース」と互換性がない - [クロスメタバース](#クロスメタバース互換性)の互換性を参照)ことになります。

マルチアセットNFTでは、ミンターや事前承認された別のエンティティが新しいアセットを提案し、トークンの所有者がそれを受け入れるか拒否することができます。アセットは既存のアセットを置き換えることもできます。

アセットを置き換えることは、ERC-721トークンのURIを置き換えるのと似ています。アセットを置き換えると、古いアセットへのトレーサビリティが明確に残ります。URIを置き換えると、このような系譜が不明確になります。また、発行者がNFTのアセットを自由に置き換えられないことで、トークンの所有者に対する信頼性も高まります。この提案の提案-承認アセット置換メカニズムはこの保証を提供します。

これにより、十分な経験が蓄積されたら、ユーザーがレベルアップを受け入れることができるレベルアップメカニックが可能になります。レベルアップは、NFTに新しいアセットが追加されることで構成され、受け入れられると、古いアセットが置き換えられます。

具体的な例としては、ポケモン™️の進化が考えられます。十分な経験が蓄積されたら、トレーナーはモンスターを進化させることができます。マルチアセットNFTでは、メタデータを中央集権的に制御して置き換える必要がなく、ユーザーのウォレットに別のNFTをエアドロップする必要もありません。代わりに、ピカチュウにライチュウのアセットがミントされ、受け入れられると、ピカチュウのアセットが消え、ライチュウのアセットに置き換えられ、新しい属性、値などを持つことになります。

この別の例としては、IoTデバイスのファームウェアのバージョン管理が考えられます。アセットは現在のファームウェアを表し、アップデートが利用可能になると、現在のアセットが更新されたファームウェアを含むアセットに置き換えられる可能性があります。

## 仕様

この文書における「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されるものとします。

```solidity
/// @title ERC-5773 コンテキスト依存型マルチアセットトークン
/// @dev https://eips.ethereum.org/EIPS/eip-5773を参照
/// @dev 注: このインターフェースのERC-165識別子は0x06b4329aです。

pragma solidity ^0.8.16;

interface IERC5773 /* is ERC165 */ {
    /**
     * @notice `assetId`でアセットオブジェクトが初期化されたことをリスナーに通知するために使用されます。
     * @param assetId 初期化されたアセットのID
     */
    event AssetSet(uint64 assetId);

    /**
     * @notice `assetId`のアセットオブジェクトがトークンの保留中のアセット配列に追加されたことをリスナーに通知するために使用されます。
     * @param tokenIds 新しい保留中のアセットを受け取ったトークンのID配列
     * @param assetId トークンの保留中のアセット配列に追加されたアセットのID
     * @param replacesId 置き換えられるアセットのID
     */
    event AssetAddedToTokens(
        uint256[] tokenIds,
        uint64 indexed assetId,
        uint64 indexed replacesId
    );

    /**
     * @notice `assetId`のアセットオブジェクトがトークンによって受け入れられ、トークンの保留中のアセット配列から有効なアセット配列に移行したことをリスナーに通知するために使用されます。
     * @param tokenId 新しいアセットが受け入れられたトークンのID
     * @param assetId 受け入れられたアセットのID
     * @param replacesId 置き換えられたアセットのID
     */
    event AssetAccepted(
        uint256 indexed tokenId,
        uint64 indexed assetId,
        uint64 indexed replacesId
    );

    /**
     * @notice `assetId`のアセットオブジェクトがトークンから拒否され、トークンの保留中のアセット配列から削除されたことをリスナーに通知するために使用されます。
     * @param tokenId アセットが拒否されたトークンのID
     * @param assetId 拒否されたアセットのID
     */
    event AssetRejected(uint256 indexed tokenId, uint64 indexed assetId);

    /**
     * @notice トークンの優先順位配列が再編成されたことをリスナーに通知するために使用されます。
     * @param tokenId アセットの優先順位配列が更新されたトークンのID
     */
    event AssetPrioritySet(uint256 indexed tokenId);

    /**
     * @notice オーナーがトークンのアセットを管理するためのユーザーへの承認を付与したことをリスナーに通知するために使用されます。
     * @dev 承認は譲渡時にクリアされる必要があります
     * @param owner 承認を付与したアカウントのアドレス
     * @param approved トークンのアセットを管理する承認を受けたアカウントのアドレス
     * @param tokenId 承認が付与されたトークンのID
     */
    event ApprovalForAssets(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );

    /**
     * @notice オーナーが自身のすべてのトークンのアセットを管理するためのオペレーターへの承認を付与したことをリスナーに通知するために使用されます。
     * @param owner 承認を付与したアカウントのアドレス
     * @param operator トークンのアセットを管理する承認を受けたアカウントのアドレス
     * @param approved 権限が付与された(`true`)か取り消された(`false`)かを示すブール値
     */
    event ApprovalForAllForAssets(
        address indexed owner,
        address indexed operator,
        bool approved
    );

    /**
     * @notice 指定したトークンの保留中のアセット配列からアセットを受け入れます。
     * @dev トークンの保留中のアセット配列からトークンの有効なアセット配列にアセットを移行します。
     * @dev 有効なアセットは誰も削除できませんが、新しいアセットに置き換えることはできます。
* @dev 要件:
     *
     *  - 呼び出し元がトークンの所有者であるか、トークンのアセットを管理する承認を受けている必要があります
     *  - `tokenId`が存在する必要があります。
     *  - `index`が保留中のアセット配列の長さの範囲内にある必要があります。
     * @dev {AssetAccepted}イベントを発行します。
     * @param tokenId アセットを受け入れるトークンのID
     * @param index 保留中の配列のどのインデックスのアセットを受け入れるか
     * @param assetId そのインデックスにあると期待されるアセットのID
     */
    function acceptAsset(
        uint256 tokenId,
        uint256 index,
        uint64 assetId
    ) external;

    /**
     * @notice 指定したトークンの保留中のアセット配列からアセットを拒否します。
     * @dev トークンの保留中のアセット配列からアセットを削除します。
     * @dev 要件:
     *
     *  - 呼び出し元がトークンの所有者であるか、トークンのアセットを管理する承認を受けている必要があります
     *  - `tokenId`が存在する必要があります。
     *  - `index`が保留中のアセット配列の長さの範囲内にある必要があります。
     * @dev {AssetRejected}イベントを発行します。
     * @param tokenId アセットが拒否されるトークンのID
     * @param index 保留中の配列のどのインデックスのアセットを拒否するか
     * @param assetId そのインデックスにあると期待されるアセットのID
     */
    function rejectAsset(
        uint256 tokenId,
        uint256 index,
        uint64 assetId
    ) external;

    /**
     * @notice 指定したトークンの保留中のアセット配列からすべてのアセットを拒否します。
     * @dev 事実上、保留中の配列を削除します。
     * @dev 要件:
     *
     *  - 呼び出し元がトークンの所有者であるか、トークンのアセットを管理する承認を受けている必要があります
     *  - `tokenId`が存在する必要があります。
     * @dev assetId = 0の{AssetRejected}イベントを発行します。
     * @param tokenId 保留中の配列をクリアするトークンのID
     * @param maxRejections この操作の直前に到着したアセットを拒否するのを防ぐため
     */
    function rejectAllAssets(uint256 tokenId, uint256 maxRejections) external;

    /**
     * @notice 指定したトークンの新しい優先順位配列を設定します。
     * @dev 優先順位配列は、最小値が最高優先度とみなされる非順次の`uint16`のリストです。
     * @dev 優先順位の値`0`は、初期化されていないことを示す特別なケースです。
     * @dev 要件:
     *
     *  - 呼び出し元がトークンの所有者であるか、トークンのアセットを管理する承認を受けている必要があります
     *  - `tokenId`が存在する必要があります。
     *  - `priorities`の長さは、有効なアセット配列の長さと等しくなければなりません。
     * @dev {AssetPrioritySet}イベントを発行します。
     * @param tokenId 優先順位を設定するトークンのID
     * @param priorities 有効なアセットの優先順位の配列。優先順位配列の項目の順序は、有効な配列の項目の順序と一致します
     */
    function setPriority(uint256 tokenId, uint64[] calldata priorities)
        external;

    /**
     * @notice 指定したトークンの有効なアセットのIDを取得するために使用されます。
     * @dev アセットデータは参照で保存されているため、IDに対応するデータにアクセスするには、`getAssetMetadata(tokenId, assetId)`を呼び出す必要があります。
     * @dev 安全に10,000件取得できます
     * @param tokenId 有効なアセットのIDを取得するトークンのID
     * @return uint64[] 指定したトークンの有効なアセットのIDの配列
     */
    function getActiveAssets(uint256 tokenId)
        external
        view
        returns (uint64[] memory);

    /**
     * @notice 指定したトークンの保留中のアセットのIDを取得するために使用されます。
     * @dev アセットデータは参照で保存されているため、IDに対応するデータにアクセスするには、`getAssetMetadata(tokenId, assetId)`を呼び出す必要があります。
     * @param tokenId 保留中のアセットのIDを取得するトークンのID
     * @return uint64[] 指定したトークンの保留中のアセットのIDの配列
     */
    function getPendingAssets(uint256 tokenId)
        external
        view
        returns (uint64[] memory);

    /**
     * @notice 指定したトークンの有効なアセットの優先順位を取得するために使用されます。
     * @dev アセットの優先順位は、有効なアセットの優先順位と同じサイズの配列の非順次の`uint16`値です。
     * @param tokenId 有効なアセットの優先順位を取得するトークンのID
     * @return uint16[] 指定したトークンの有効なアセットの優先順位の配列
     */
    function getActiveAssetPriorities(uint256 tokenId)
        external
        view
        returns (uint64[] memory);

    /**
     * @notice トークンの保留中の配列から受け入れられた場合に置き換えられるアセットのIDを取得するために使用されます。
     * @dev アセットデータは参照で保存されているため、IDに対応するデータにアクセスするには、`getAssetMetadata(tokenId, assetId)`を呼び出す必要があります。
     * @param tokenId チェックするトークンのID
     * @param newAssetId 受け入れられる保留中のアセットのID
     * @return uint64 置き換えられるアセットのID
     */
    function getAssetReplacements(uint256 tokenId, uint64 newAssetId)
        external
        view
        returns (uint64);

    /**
     * @notice 指定したトークンの有効なアセットのメタデータを取得するために使用されます。
     * @dev 列挙、フォールバック、その他のカスタムロジックを実装するために上書きできます。
     * @param tokenId メタデータを取得するトークンのID
     * @param assetId アセットID、有効なアセット配列に存在する必要があります
     * @return string トークンの有効なアセット配列の指定したインデックスに属するアセットのメタデータ
     */
    function getAssetMetadata(uint256 tokenId, uint64 assetId)
        external
        view
        returns (string memory);

    /**
     * @notice トークンのアセットを管理するためのユーザーへの承認を付与するために使用されます。
     * @dev これは譲渡の承認とは異なり、承認を受けた当事者がアセットを受け入れたり拒否したり、アセットの優先順位を設定したりしても、承認がクリアされることはありません。この承認は、トークンの譲渡時にクリアされます。
     * @dev 一度に1つのアカウントにしか承認できないため、`0x0`アドレスに承認すると、以前の承認がクリアされます。
     * @dev 要件:
     *
     *  - 呼び出し元がトークンの所有者であるか、承認されたオペレーターである必要があります。
     *  - `tokenId`が存在する必要があります。
     * @dev {ApprovalForAssets}イベントを発行します。
     * @param to アセットの管理承認を付与するアカウントのアドレス
     * @param tokenId 承認が付与されるトークンのID
     */
    function approveForAssets(address to, uint256 tokenId) external;

    /**
     * @notice 指定したトークンのアセットを管理する承認を受けたアドレスを取得するために使用されます。
     * @dev 要件:
     *
     *  - `tokenId`が存在する必要があります。
     * @param tokenId 承認されたアドレスを取得するトークンのID
     * @return address 指定したトークンのアセットを管理する承認を受けたアカウントのアドレス
     */
    function getApprovedForAssets(uint256 tokenId)
        external
        view
        returns (address);

    /**
     * @notice 呼び出し元のオペレーターを追加または削除するために使用されます。
     * @dev オペレーターは、呼び出し元が所有するすべてのトークンに対して{acceptAsset}、{rejectAsset}、{rejectAllAssets}、または{setPriority}を呼び出すことができます。
     * @dev 要件:
     *
     *  - `operator`は呼び出し元であってはいけません。
     * @dev {ApprovalForAllForAssets}イベントを発行します。
     * @param operator オペレーターの役割が付与または取り消されるアカウントのアドレス
     * @param approved オペレーターの役割が付与されるか(`true`)、取り消される(`false`)かを示すブール値
     */
    function setApprovalForAllForAssets(address operator, bool approved)
        external;

    /**
     * @notice 指定のアドレスがあるアドレスによってオペレーターの役割を付与されているかどうかを確認するために使用されます。
     * @dev {setApprovalForAllForAssets}を参照してください。
     * @param owner オペレーターの役割が付与されているかどうかを確認するアカウントのアドレス
     * @param operator オペレーターの役割を持っているかどうかを確認するアカウントのアドレス
     * @return bool 確認対象のアカウントがオペレーターの役割を付与されているかどうかを示すブール値
     */
    function isApprovedForAllForAssets(address owner, address operator)
        external
        view
        returns (bool);
}
```

`getAssetMetadata`関数は、アセットのメタデータURIを返します。アセットのメタデータURIが指すメタデータには、以下のようなJSONレスポンスが含まれる可能性があります:

```json
{
  "name": "アセット名",
  "description": "トークンまたはアセットの説明",
  "mediaUri": "ipfs://アセットまたはトークンのメディア",
  "thumbnailUri": "ipfs://アセットまたはトークンのサムネイル",
  "externalUri": "https://プロジェクトのWebサイトのURI",
  "license": "ライセンス名",
  "licenseUri": "ライセンスのURI",
  "tags": ["タグ", "を", "使用して", "マーケットプレイス", "でアセット", "またはトークン", "を分類する"],
  "preferThumb": false, // UIでサムネイルURIを優先的に使用するかどうかを示すブール値
  "attributes": [
    {
      "label": "レアリティ",
      "type": "string",
      "value": "epic",
      // 下位互換性のため
      "trait_type": "rarity"
    },
    {
      "label": "色",
      "type": "string",
      "value": "red",
      // 下位互換性のため
      "trait_type": "color"
    },
    {
      "label": "高さ",
      "type": "float",
      "value": 192.4,
      // 下位互換性のため
      "trait_type": "height",
      "display_type": "number"
    }
  ]
}
```

これがアセットメタデータの提案JSONスキーマですが、実装者の好みに応じて完全に異なる構造になる可能性があります。

## 根拠

提案を設計する際、以下の点を検討しました:

1. **アセットとリソースのどちらを使ってトークンを構成するエンティティを参照するべきですか?**
   オリジナルのアイデアは「マルチリソース」と呼ぶことでしたが、これはトークンが保持できる構造の広さを示していましたが、「アセット」という用語の方がよりよく表現できます。
   アセットは、個人、企業、または組織が所有するお金、不動産、土地などのものと定義されます。これは、この提案のアセットが表すものを最もよく表しています。このプロポーザルのアセットは、マルチメディアファイル、技術情報、土地の権利書、実装者が決めたトークンのアセットとなるものなどです。
2. **なぜ[EIP-712](./eip-712.md)のpermit形式の署名を使ってアプローバルを管理しないのですか?**
   一貫性のため。このプロポーザルはERC-721を拡張するものですが、ERC-721ではトークンの操作に1つのトランザクションを使用しています。署名メッセージをサポートするのは一貫性がありません。
3. **なぜインデックスを使うのですか?**
   ガス消費を削減するため。アセットIDを使ってアセットを受け入れたり拒否したりすると、配列の反復処理が必要になり、操作のコストはアクティ
ブまたは保留中のアセット配列のサイズに依存することになります。インデックスを使えば、コストが固定されます。トークンごとにアクティブおよび保留中のアセット配列のリストを維持する必要があるため、それらを取得するメソッドがプロポーザルのインターフェースに含まれています。
   インデックスの変更によるレースコンディションを避けるため、操作にはアセットIDの期待値が含まれ、インデックスを使ってアクセスされるアセットが期待されるアセットであることを確認します。
   マッピングを使ってインデックスを内部的に追跡する実装を試みましたが、トークンにアセットを追加するコストが25%以上増加し、アセットの受け入れと拒否のコストも4.6%と7.1%それぞれ増加しました。このプロポーザルには必要ではないと判断し、コストを受け入れる使用例向けの拡張機能として実装できます。提供されるサンプル実装には、これを可能にするいくつかのフックがあります。
4. **なぜすべてのアセットを取得するメソッドが含まれていないのですか?**
   すべてのアセットを取得することが、すべての実装者にとって必要な操作とは限りません。さらに、拡張機能として追加したり、インデックサーを使ってエミュレートしたりすることができます。
5. **なぜページネーションが含まれていないのですか?**
   アセットIDは`uint64`を使用しており、ガス制限に到達する前に読み取れるIDの上限は約30,000件であることをテストで確認しています。これは一般的な使用例とは考えられないため、インターフェースの一部ではありません。ただし、実装者がこのユースケース向けの拡張機能を作成することはできます。
6. **このプロポーザルは、同様の問題に取り組む他の提案とどのように異なりますか?**
   レビューした結果、以下のような制限が少なくとも1つ含まれていることがわかりました:
   - 新しいアセットが必要になるたびにURIを置き換えるため、トークンの所有者に対する信頼性の問題がある。
   - 特定のアセットタイプにのみ焦点を当てており、このプロポーザルはアセットタイプに依存しない。
   - 新しい使用例ごとに別のトークンを持つため、トークンが前方互換性を持たない。

### マルチアセットストレージスキーマ

アセットはトークン内で`uint64`識別子の配列として保存されます。

オンチェーンの文字列ストレージの冗長性を削減するために、マルチアセットトークンはリファレンスによってアセットを保存します。ストレージ内のアセットエントリは、`uint64`マッピングでアセットデータに保存されます。

アセット配列は、これらの`uint64`アセットID参照の配列です。

このような構造により、汎用的なアセットをストレージに1回追加し、その参照をトークンコントラクトに望む回数だけ追加できます。実装者は、アセットの基本*SRC*とトークンID*を使ってコンテンツアドレス可能なアーカイブへのリンクを手続き的に生成することができます。新しいトークンにアセットを格納する場合、トークンごとのアセット配列に16バイトのストレージしか必要ありません。

このようにトークンのアセットを構造化することで、特にトークンIDによってのみ異なる場合、URIを連結によって導出することができます。

### アセット追加のプロポーズ-コミットパターン

既存のトークンにアセットを追加する際は、第三者による制限付きの変更を可能にするため、プロポーズ-コミットパターンの形式で行う必要があります。トークンにアセットを追加する際は、まず*「保留中」*の配列に配置され、トークンの所有者によって*「有効」*の配列に移行される必要があります。*「保留中」*のアセット配列は、スパムやグリーフィングを防ぐため、128スロットに制限されるべきです。

### アセット管理

アセット管理のための複数の関数が含まれています。*「保留中」*から*「有効」*への許可付きの移行に加えて、トークンの所有者は*「有効」*と*「保留中」*の両方からアセットを削除することもできます - 保留中の配列のすべてのエントリをクリアするための緊急関数も含まれている必要があります。

## 下位互換性

マルチアセットトークン標準は、ERC-721の堅牢なツーリングを活用し、既存のERC-721インフラストラクチャとの互換性を確保するために、[ERC-721](./eip-721.md)と互換性を持つように設計されています。

## テストケース

テストは[`multiasset.ts`](../assets/eip-5773/test/multiasset.ts)に含まれています。

ターミナルでそれらを実行するには、以下のコマンドを使用できます:

```
cd ../assets/eip-5773
npm install
npx hardhat test
```

## リファレンス実装

[`MultiAssetToken.sol`](../assets/eip-5773/contracts/MultiAssetToken.sol)を参照してください。

## セキュリティ上の考慮事項

[ERC-721](./eip-721.md)と同様のセキュリティ上の考慮事項が適用されます:非監査のコントラクトには隠れたロジックが存在する可能性があります。

監査されていないコントラクトを扱う際は注意が必要です。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)によって放棄されています。