---
original: 87b7b7dee4c1afbcbfc75b225b8b35ace894e8f4ff72356463f2768ed70f995d
---

---
eip: 5850
title: `bytes32`型に格納されるコンプレックス数
description: コンプレックス数の実部と虚部を、`bytes32`型の最下位16バイトと最上位16バイトにそれぞれ格納する。
author: Paul Edge (@genkifs)
discussions-to: https://ethereum-magicians.org/t/eip-5850-store-real-and-imaginary-parts-of-complex-numbers-in-the-least-significant-and-most-significant-16-bytes-respectively-of-a-bytes32-type/11532
status: 停滞中
type: Standards Track
category: ERC
created: 2022-10-29
---

## 概要

このEIPは、コンプレックス数を`bytes32`データ型に格納し、取り出す自然な方法を提案します。 格納領域を正確に2等分し、最も重要なことに、実数部を最下位16バイトに、虚数部を最上位16バイトに割り当てます。

## 動機

コンプレックス数は、多くの数学的および科学的計算に不可欠なツールです。 例えば、フーリエ変換、特性関数、AC回路、ナビエ・ストークス方程式などはすべてこの概念を必要とします。

コンプレックス数は、多様な形式(多項式、直交座標、極座標、指数関数)で表現できます。 このEIPは、直交座標、極座標、指数関数の各形式に対応できる標準を作成します。直交座標表現の例コードを示します。ここでは、コンプレックス数は実数部と虚数部の組み合わせとして表されます。両方のコンポーネントに等しい格納容量が割り当てられ、出現順序が明示的に定義されています。

コンプレックス数を単一の`bytes32`データオブジェクトにパッキングすることで、格納コストが半減し、ソリディティエコシステムを介して自然にコードオブジェクトを渡すことができます。既存のコードを書き換える必要がない可能性があります。 たとえば、`bytes32`によるマッピングは一般的であり、2次元コンプレックス平面でのインデックス付けにより、コードの可読性が向上する可能性があります。

ソリディティでは、10進数(固定小数点または浮動小数点)がまだ完全にサポートされていないため、コンプレックス数の同様の標準を強制するのは時期尚早です。 prb-mathのような固定小数点メソッドを使用して18桁の小数点以下を使用するか、abdkのような浮動小数点メソッドを使用することをお勧めします。 ただし、この EIPは、16バイトの空間に収まる限り、任意の10進数表現をサポートすることに注意してください。

## 仕様

コンプレックス数は`bytes32`として定義され、直交座標表現は`cnNew`関数で初期化され、`RealIm`で変換されます。両方の関数を以下に示します。

コンプレックス数を作成するには、次のように使用します。

```solidity
function cnNew(int128 _Real, int128 _Imag) public pure returns (bytes32){
    bytes32 Imag32 = bytes16(uint128(_Imag));
    bytes32 Real32 = bytes16(uint128(_Real));
    return (Real32>> 128) | Imag32;
}
```

変換するには、次のように使用します。

```solidity
function RealIm(bytes32 _cn)  public pure returns (int128 Real, int128 Imag){
    bytes16[2] memory tmp = [bytes16(0), 0];
    assembly {
        mstore(tmp, _cn)
        mstore(add(tmp, 16), _cn)
    }
    Imag=int128(uint128(tmp[0]));
    Real=int128(uint128(tmp[1]));
}
```

## 根拠

この提案は、複数のアプリで使用できるコンプレックス数の格納/型の標準を定義するため、EIPが必要です。

このEIPでは、実部と虚部の両方を既存のデータ型`bytes32`にパッケージ化することを提案しています。これにより、構造体を必要とせずにコンパクトな格納が可能になり、ライブラリの実装が容易になります。`bytes32`は、非コンプレックス数の用途に引き続き使用できます。

この EIPでは、実部と虚部の分割と位置のみを定義しています。コンプレックス数の操作(加算、乗算など)、小数点以下の桁数、その他のトピックについては、他のEIPの議論に委ねています。これにより、このEIPがより焦点を絞られ、成功する可能性が高くなります。

16の最下位バイトに実数を定義することで、正の整数2**127未満の`uint128`から`bytes32`への直接変換が可能になります。
`bytes32`から`uint`、`int`への直接変換は推奨されません。コンプレックス数に虚部が含まれている可能性があり、実部が負の場合があるためです。常に`RealIm`を使用して複素部を分離するのが良いでしょう。

コンプレックス数操作ライブラリは、`Using Complex for bytes32`構文で実装できます。ここで`Complex`はライブラリの名前です。

## 下位互換性

`bytes32`データ型の他の用途には影響はありません。

## セキュリティ上の考慮事項

コンプレックス数を`bytes32`形式で操作する場合は、手動でオーバーフローチェックを実行する必要があります。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)により放棄されています。