---
original: e49c38ccbcd81d139b145769158f536d1607381da68c4575738f558a44b74fdf
---

---
eip: 7521
title: スマートコントラクトウォレットのための一般的なインテント
description: 署名時にインテントの構造を承認できる、スマートコントラクトウォレットのための一般化されたインテント仕様
author: Stephen Monn (@pixelcircuits), Bikem Bengisu (@supiket)
discussions-to: https://ethereum-magicians.org/t/erc-7521-generalized-intents-for-smart-contract-wallets/15840
status: Draft
type: Standards Track
category: ERC
created: 2023-09-19
---

## 概要

時間の経過とともに進化するさまざまなインテント標準をサポートできるよう、一般化されたインテント仕様のエントリーポイントコントラクトです。スマートコントラクトウォレットは、新しいインテント標準が登場するたびに、それらをサポートするためにアップグレードする必要がなくなります。代わりに、署名検証を処理する単一のエントリーポイントコントラクトを信頼し、低レベルのインテントデータ処理と定義をユーザーがインテント署名時に指定した他のコントラクトに委譲します。これらの署名メッセージは「UserIntent」と呼ばれ、MEVサーチャーが調べて自身の「UserIntent」と組み合わせて「IntentSolution」オブジェクトを作成するためにメンプールストラテジーを介して伝播されます。MEVサーチャーは、構築した「IntentSolution」オブジェクトをトランザクションにパッケージ化し、特別なコントラクトに「handleIntents」コールを行います。このトランザクションは、最終的にブロックに含まれるためのMEVチャンネルを通過します。

## 動機

["ERC-4337: Account Abstraction via Entry Point Contract specification"](./eip-4337.md)と関連リンクを参照してください。

この提案は、エントリーポイントコントラクトのアイデアを使用して、進化するインテントランドスケープへの将来的なアクセスを解放するための単一のインターフェイスを可能にします。以下の目標を達成することを目指しています:

- **ユーザーのインテントを可能にすることが重要な目標**: ユーザーが任意の検証ロジックを含むスマートコントラクトウォレットを使用して、さまざまなインテント標準コントラクトによって処理されるインテント実行を指定できるようにする。
- **分散化**
  - MEVサーチャーが署名されたインテントを解決するプロセスに参加できるようにする
  - 開発者が独自のインテント標準定義を追加できるようにする
- **将来のインテント標準との互換性を考慮**: 現在の「handleIntents」実行コンテキストに関する可能な限り多くの情報にアクセスできるようにするため、インテント標準定義コントラクトのインターフェイスを定義する。
- **ガスコストを最小限に抑える**: 一般的な使用例のガス効率を最適化するために、インテントの実行順序などの主要なインテント処理ロジックをエントリーポイントコントラクト自体に含める。
- **良いユーザーエクスペリエンスを実現する**
  - ユーザーがnewly開発されたインテント標準を使用したい場合に、スマートコントラクトウォレットのアップグレードを回避する。
  - 単一の署名で複雑なインテントの組み合わせを可能にする。

## 仕様

ユーザーは、ウォレットに参加させたいインテントをABIエンコーディングされた構造体「UserIntent」にパッケージ化します:

| フィールド     | 型        | 説明                                                                          |
| ------------ | --------- | ------------------------------------------------------------------------------------ |
| `sender`     | `address` | インテントを行うウォレット                                                         |
| `intentData` | `bytes[]` | 実行のために複数のセグメントに分割された、インテント標準によって定義されたデータ |
| `signature`  | `bytes`   | 検証ステップでウォレットに渡されるデータとノンス                                  |

`intentData`パラメーターは任意のバイトの配列で、インテント標準によって定義された使用法があります。この配列の各アイテムは「インテントセグメント」と呼ばれます。各セグメントの最初の32バイトは、そのセグメントデータが属する「インテント標準ID」を指定するために使用されます。ユーザーは「UserIntent」オブジェクトをメンプールストラテジーに送信します。特殊なクラスのMEVサーチャー「ソルバー」は、これらのインテントを探し、他のインテント(自身のものを含む)と組み合わせて「IntentSolution」というABIエンコーディング構造体を作成します:

| フィールド     | 型           | 説明                                   |
| ----------- | -------------- | --------------------------------------------- |
| `timestamp` | `uint256`      | インテントを評価する時間                    |
| `intents`   | `UserIntent[]` | 実行するインテントのリスト                  |
| `order`     | `uint256[]`    | 含まれるインテントの実行順序               |

ソルバーは次に「ソリューショントランザクション」を作成し、`IntentSolution`オブジェクトを単一の`handleIntents`コールとしてプレパブリッシュされたグローバル**エントリーポイントコントラクト**にパッケージ化します。

エントリーポイントコントラクトのコアインターフェイスは次のとおりです:

```solidity
function handleIntents
    (IntentSolution calldata solution)
    external;

function validateIntent
    (UserIntent calldata intent)
    external view;

function registerIntentStandard
    (IIntentStandard intentStandard)
    external returns (bytes32);

function verifyExecutingIntentForStandard
    (IIntentStandard intentStandard)
    external returns (bool);
```

インテント標準に必要なコアインターフェイスは次のとおりです:

```solidity
function validateUserIntent
    (UserIntent calldata intent)
    external;

function executeUserIntent
    (IntentSolution calldata solution, uint256 executionIndex, uint256 segmentIndex, bytes memory context)
    external returns (bytes memory);
```

ウォレットに必要なコアインターフェイスは次のとおりです:

```solidity
function validateUserIntent
    (UserIntent calldata intent, bytes32 intentHash)
    external view returns (address);

function generalizedIntentDelegateCall
    (bytes memory data)
    external returns (bool);
```

### エントリーポイントコントラクトの必要な機能

`handleIntents`関数は次の手順を実行する必要があります。**検証ループ**と**実行ループ**の2つのループを行います。

検証ループでは、`handleIntents`コールは各`UserIntent`について次の手順を実行する必要があります:

- `IntentSolution`の`timestamp`値を**検証**し、`block.timestamp`の許容範囲内または前の時間であることを確認する。
- ウォレットの`validateUserIntent`を**呼び出す**。`UserIntent`とインテントのハッシュを渡す。ウォレットはインテントの署名を検証する。`validateUserIntent`の呼び出しが失敗した場合、`handleIntents`はその少なくともそのインテントの実行をスキップし、完全に元に戻す可能性がある。

実行ループでは、`handleIntents`コールは各`UserIntent`の`intentData`バイト配列パラメーターのすべての**セグメント**について次の手順を実行する必要があります:

- `intentData`の最初の32バイト(インテント標準ID)で指定されたインテント標準の`executeUserIntent`を**呼び出す**。この呼び出しには、完全な`IntentSolution`、現在の`executionIndex`(この関数がこれまでにどの標準やインテントに対して呼び出されたか)、`segmentIndex`(実行するための`intentData`配列内のインデックス)、および`context`データを渡す。`executeUserIntent`関数は任意のバイトを返し、次の`executeUserIntent`呼び出しに渡す必要がある。

インテント標準は、`intentData`セグメントバイトの解析方法と、連続するインテント実行に渡される`context`データブロブの利用方法を選択する。

`intentData`配列内のインテントセグメントの実行順序は常に同じ順序に従います。ただし、`UserIntent`オブジェクト間のセグメントの実行順序は、`IntentSolution`オブジェクトの`order`パラメーターで指定できます。たとえば、`order`配列が`[1,1,0,1]`の場合、2番目のインテントが2回実行され(インテント2のセグメント1と2)、次に1番目のインテントが実行され(インテント1のセグメント1)、最後に2番目のインテントが3回目に実行されます(インテント2のセグメント3)。順序が指定されていない場合、または順序配列の最後まで行ってもすべてのインテントのセグメントが処理されていない場合は、デフォルトの順序が使用されます。このデフォルトの順序は、すべてのインテントのセグメントが実行されるまで、最初のインテントから最後まで繰り返します。インテントが既に実行されたすべてのセグメントの後に実行されるよう順序が指定された場合、`executeUserIntent`の呼び出しはスキップされ、すべてのインテントの実行が続行されます。

ソルバーは`validateIntent`関数をローカルに呼び出して`UserIntent`を検証する必要があります。これにより、署名とデータ形式が正しいことを確認できます。詳細については、[ソルバーのインテント検証](#ソルバーのインテント検証)セクションを参照してください。

#### 新しいエントリーポイントインテント標準の登録

エントリーポイントの`registerIntentStandard`関数は、新しいインテント標準コントラクトの無許可登録を可能にする必要があります。登録プロセス中、エントリーポイントコントラクトは、インテント標準コントラクトの`isIntentStandardForEntryPoint`関数を呼び出して、コントラクトがエントリーポイントに登録されることを意図したものであることを確認する必要があります。この関数にはエントリーポイントコントラクトアドレスが渡され、インテント標準はそれを検証して true または false を返します。インテント標準コントラクトが true を返す場合、エントリーポイントはそれを登録し、チェーンIDとエントリーポイントコントラクトに固有の**標準ID**を付与します。

### インテント標準の実行時の動作

インテント標準の`executeUserIntent`関数には、将来的に有用と見なされる可能性のあるあらゆるロジックを実装できるよう、`IntentSolution`全体へのアクセスが与えられています。各インテント標準コントラクトは、`UserIntent`オブジェクトの`intentData`パラメーターを解析し、関連する制約の検証や操作を行うことが期待されています。インテント標準は、`executeUserIntent`関数の最後で返される`context`データを利用することもできます。このデータはエントリーポイントによって保持され、次に`executeUserIntent`関数が呼び出されるときのパラメーターとして渡されます。これにより、インテント実行中の状態変化(トークンのリリースと別のトークンの受け取りなど)を探索するインテント標準にアクセスできます。

### インテントの実行時のスマートコントラクトウォレットの動作

エントリーポイントは、検証中および実行中にスマートコントラクトウォレットから何も期待していません。ただし、インテント標準がウォレットに対して何らかのアクションを実行することを望む場合があります。スマートコントラクトウォレットの`generalizedIntentDelegateCall`関数は、呼び出し元のインテント標準コントラクトを`verifyExecutingIntentForStandard`関数を使ってエントリーポイントコントラクトで検証した上で、指定のコールデータでデリゲートコールを実行する必要があります。

### インテントの検証時のスマートコントラクトウォレットの動作

エントリーポイントは、各`UserIntent`のウォレットの`validateUserIntent`を呼び出します。この関数には、完全な`UserIntent`オブジェクトとインテントのプリコンピュートされたハッシュが渡されます。スマートコントラクトウォレットは、この情報を分析して、`sender`フィールドから送信されたものであることを確認する必要があります。インテントが有効でない場合、スマートコントラクトウォレットは`validateUserIntent`関数でエラーをスローする必要があります。`validateUserIntent`は`view`のみに制限されることに注意してください。ノンス管理などの状態の更新は、インテント自体の個別のセグメントで行う必要があります。これにより、ユーザーがインテントを定義する方法の最大限のカスタマ
イズが可能になり、エントリーポイントに必要な最小限の検証のみが確立されます。

`validateUserIntent`関数には、検証に失敗したが、前に署名集約コントラクトによって検証された可能性がある場合の、オプションの`address`返り値があります。この場合、スマートコントラクトウォレットは、信頼された署名集約スマートコントラクトのアドレスを返します。[署名集約の拡張](#拡張-署名集約)セクションを参照してください。検証に問題がなかった場合、スマートコントラクトウォレットは単に`address(0)`を返す必要があります。

### ソルバーのインテント検証

`UserIntent`を検証するために、ソルバーは`validateIntent(intent)`をエントリーポイントに対するビューコールで行います。この関数は、署名が有効であり、インテントのセグメントが適切に書式化されていることを確認します。エラーでコールが元に戻された場合、ソルバーは`UserIntent`を拒否する必要があります。

### シミュレーション

ソルバーは、典型的なMEVワークフローでシミュレーションを処理することが期待されます。これは、おそらく現在のブロック高さでソリューションをドライランすることを意味し、期待どおりの結果を判断します。成功したソリューションは次のブロックに含めるためにブロックビルダーに提出できます。

### 拡張

エントリーポイントコントラクトは、一般的なシナリオのガスコストを削減するための追加の機能を有効にする可能性があります。

#### 拡張: 署名集約

エントリーポイントコントラクトに`handleIntentsAggregated`という追加の関数を追加し、個別のインテントの署名を検証する代わりに集約された署名を提供できるようにします。さらに、**署名集約**ロジックを処理する契約のインターフェイスを導入します。

エントリーポイントに必要なコアインターフェイスは次のとおりです:

```solidity
handleIntentsAggregated(
        IntentSolution[] calldata solutions,
        IAggregator aggregator,
        bytes32 intentsToAggregate,
        bytes calldata signature
    ) external;
```

`handleIntentsAggregated`関数は、ソリューションのリスト、集約コントラクトのアドレス、集約された署名を表すビットフィールド(含まれるものは1、除外されるものは0)、最後に集約された署名自体を受け取ります。エントリーポイントコントラクトは、集約コントラクトに呼び出して集約された署名を検証します。その後、通常の検証中に、エントリーポイントコントラクトは、集約された署名に含まれるインテントを送信したスマートコントラクトウォレットがすべて、使用された署名集約コントラクトのアドレスを返すことを確認します。[インテントの検証時のスマートコントラクトウォレットの動作](#インテントの検証時のスマートコントラクトウォレットの動作)セクションを参照してください。

集約コントラクトに必要なコアインターフェイスは次のとおりです:

```solidity
function validateSignatures
    (UserIntent[] calldata intents, bytes calldata signature)
    external view;

function aggregateSignatures
    (UserIntent[] calldata intents)
    external view returns (bytes memory aggregatedSignature);
```

`validateSignatures`関数は、エントリーポイントコントラクトが集約された署名を検証するために呼び出す主要な関数です。`aggregateSignatures`関数は、ソルバーがオフラインで集約された署名を計算するために使用できます(最適化されたカスタムコードを持っていない場合)。

#### 拡張: 埋め込みインテント標準

エントリーポイントのロジックを拡張して、いくつかの識別された**一般的なインテント標準**のロジックを含めます。これらの標準は、エントリーポイントコントラクト作成時に独自の標準IDで登録されます。これらの標準の`validateUserIntent`および`executeUserIntent`関数は、外部呼び出しを削減してガスを節約するためにエントリーポイントコントラクトのコードの一部として含まれます。

#### 拡張: handleMulti

エントリーポイントコントラクトに`handleIntentsMulti(IntentSolution[] calldata solutions)`という追加の関数を追加します。これにより、複数のソリューションを単一のトランザクションで実行できるようになり、類似の領域のストレージに影響するインテントでガス節約が可能になります。

#### 拡張: ノンス管理

エントリーポイントコントラクトに`getNonce(address sender, uint256 key)`および`setNonce(uint256 key, uint256 nonce)`関数を追加します。これらの関数により、ノンスデータをエントリーポイントコントラクトのストレージに保存できます。ノンスはユーザーごとに保存され、誰でも読み取れるようになります。ただし、エントリーポイントコントラクトは、現在実行中のインテント標準によってのみ、実行中のインテントの`sender`に対してノンスを設定できるよう強制します。

#### 拡張: データブロブ

エントリーポイントコントラクトに、`sender`フィールドが`address(0)`または`intentData`フィールドが空の`UserIntent`オブジェクトの検証をスキップする(失敗させない)機能を追加します。同様に、実行中もスキップされます。`intentData`フィールドまたは`sender`フィールドは、任意の任意のデータをインテント実行に注入する方法として扱うことができます。このデータは、知る必要があり証明する秘密を持つインテント標準を解決したり、他のインテントの存在によってその動作が変化するインテントを解決したりするのに役立つ可能性があります。たとえば、インテントの実行順序で次の順番のインテントの送信者にトークンを転送するよう、スマートコントラクトウォレットに合図するインテント標準などです。

## 根拠

一般化されたインテント標準の主な課題は、進化し続けるインテントの世界に適応することです。ユーザーは、自分のスマートコントラクトウォレットを絶えずアップグレードする必要なく、自分のインテントを滑らかに表現できる必要があります。

この提案では、ウォレットに`validateUserIntent`関数があり、`UserIntent`を入力として受け取り、署名を検証することを期待しています。信頼されたエントリーポイントコントラクトはこの関数を使ってシグネチャを検証し、`intentData`配列のそれぞれのセグメントの最初の32バイトで指定されたインテント標準コントラクトにインテント処理ロジックを転送します。ウォレットには、`verifyExecutingIntentForStandard`関数を使ってセキュリティを確保しながら、インテント標準コントラクトからのインテント関連アクションを実行できる`generalizedIntentDelegateCall`関数が必要です。

エントリーポイントベースのアプローチにより、検証と実行の間のクリーンな分離が可能になり、ユーザーが使用したい最新のインテント標準構成をサポートするためにウォレットソフトウェア開発者を説得する必要がなくなります。代替案では、新しいインテント標準の開発者がウォレットソフトウェア開発者に自分の新しいインテント標準のサポートを説得する必要があります。この提案では、インテントの核心的な定義をユーザーの署名時に移動します。

### ソルバー

ソルバーは、ユーザーのインテントの達成を促進し、自身のMEVを探索します。また、インテントを オンチェーンで実行するためのトランザクション発信者の役割も果たし、ガス代の支払いの負担をユーザーから取り除きます。

ソルバーは、ゴシップネットワークやインテント自体の性質およびそれらが使用する個々のインテント標準によって決まる解決アルゴリズムに依存します。

### エントリーポイントのアップグレード

ウォレットはガス効率とウォレットのアップグレード可能性のためにDELEGATECALL転送コントラクトであることが推奨されます。ウォレットコードは、ガス効率のためにエントリーポイントをハードコーディングすることが期待されます。新しいエントリーポイントが導入された場合(新機能の追加、ガス効率の改善、重大なセキュリティバグの修正など)、ユーザーは自己呼び出しを行ってウォレットのコードアドレスを新しいコードアドレスに置き換えることができます。アップグレードプロセス中、インテント標準コントラクトも新しいエントリーポイントに再登録する必要があると予想されます。

#### インテント標準のアップグレード

インテント標準がウォレットにハードコーディングされていないため、ユーザーは新しく登録されたインテント標準を使用するために何も操作する必要はありません。ユーザーは単に新しいインテント標準でインテントに署名できます。

## 下位互換性

このERCはコンセンサスレイヤーを変更しないため、Ethereumの全体としての下位互換性の問題はありません。既存のスマートコントラクトウォレットとの統合を試みる際にはやや困難があります。ウォレットが既に[ERC-4337](./eip-4337.md)のサポートを持っている場合、`validateUserIntent`関数の実装は`validateUserOp`関数とよく似ていますが、ユーザーによるアップグレードが必要になります。

## 参考実装

`https://github.com/essential-contributions/ERC-7521`を参照してください

## セキュリティ上の考慮事項

エントリーポイントコントラクトは非常に徹底的に監査および正式に検証される必要があります。なぜなら、[ERC-7521](./eip-7521.md)をサポートするすべてのウォレットの中心的な信頼ポイントとして機能するためです。この設計全体では、個々の*ウォレット*が行う監査と正式な検証の負荷が大幅に軽減されるため、エコシステムの監査と検証の負荷が全体的に軽減されます。ウォレットは`validateUserIntent`関数とその「署名チェック」ロジックのみを検証する必要があり、`generalizedIntentDelegateCall`への呼び出しを`verifyExecutingIntentForStandard`関数を使ってゲートすればよいからです。ただし、非常に高度に集中されたセキュリティリスクであるエントリーポイントコントラクトは、非常に堅牢であることを検証する必要があります。

検証では、次の主要な主張(ソルバーとインテント標準関連のインフラストラクチャを保護するために必要な主張を除く)をカバーする必要があります:

- **任意の乗っ取りに対する安全性**: エントリーポイントは、`UserIntent`の署名を正常に検証し、現在`intentData`フィールドの`standard`で指定されたインテント標準の`executeUserIntent`を呼び出している最中に、`msg.sender`ウォレットが同じ`sender`を持っている場合にのみ、`verifyExecutingIntentForStandard`で true を返します。

ユーザーが相互作用することを決めたインテント標準コントラクトについても、追加の徹底的な監査と正式な検証が必要です。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。