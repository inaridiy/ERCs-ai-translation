---
original: 15d8c8e23de7ac342ef951ebbd5be92f97df6d57327da675d9f9affde2ef26fb
---

---
eip: 7401
title: 親トークンによる非代替性トークンのネスティング
description: 親トークンの関係に対する制御に重点を置いた、非代替性トークンのネスティングのためのインターフェース。
author: Bruno Škvorc (@Swader), Cicada (@CicadaNCR), Steven Pineda (@steven2308), Stevan Bogosavljevic (@stevyhacker), Jan Turk (@ThunderDeliverer)
discussions-to: https://ethereum-magicians.org/t/eip-6059-parent-governed-nestable-non-fungible-tokens/11914
status: Final
type: Standards Track
category: ERC
created: 2023-07-26
requires: 165, 721
---

## 概要

❗️ **[ERC-7401](./eip-7401.md) は [ERC-6059](./eip-6059.md) に取って代わります。** ❗️

親トークン主導型NFTネスティング標準は、[ERC-721](./eip-721.md)を拡張し、新しいトークン間の関係と相互作用を可能にします。

提案の核となるアイデアは単純です。NFTの所有者は外部所有アカウント(EOA)やスマートコントラクトである必要はなく、NFTそのものでもあり得ます。

NFTをネストするプロセスは、他のユーザーに送信するのと機能的に同じです。ある1つのトークンから別のトークンを送信するプロセスには、親トークンを所有するアカウントからトランザクションを発行することが含まれます。

NFTは単一の他のNFTによって所有されることができますが、自身が所有するNFTを複数持つこともできます。この提案は、NFTの親子関係のフレームワークを確立します。親トークンは他のトークンを所有するトークンです。子トークンは他のトークンに所有されているトークンです。1つのトークンが同時に親と子になることもできます。ある親トークンの子トークンは、その親トークンの所有者によって完全に管理されますが、誰でも提案することができます。

![ネスト可能なトークン](../assets/eip-7401/img/eip-7401-nestable-tokens.png)

このグラフは、子トークンが同時に親トークンでもあり得るが、両者ともルートの親トークンの所有者によって管理されることを示しています。

## 動機

Ethereum エコシステムでは NFT が広く使用されており、様々なユースケースに利用されているため、それらの追加的な機能性を標準化する時期が来ています。トークンが他のトークンを所有できるようにすることで、より大きな機能性、使いやすさ、前方互換性が得られます。

[ERC-721](./eip-721.md) が公開されてから4年が経ち、追加の機能性に対するニーズが数多くの拡張につながっています。この ERC は ERC-721 を以下の点で改善しています:

- [バンドリング](#バンドリング)
- [コレクション](#コレクション)
- [メンバーシップ](#メンバーシップ)
- [委任](#委任)

この提案は、[ERC-6059](./eip-6059.md)のインターフェースの不整合を修正しています。インターフェースIDがインターフェースの仕様と一致していませんでしたが、提案の過程で1つのパラメータが追加されていませんでした。しかし、その抜けているパラメータはインターフェースIDに存在していました。この修正以外は、この提案は[ERC-6059](./eip-6059.md)と機能的に同等です。

### バンドリング

[ERC-721](./eip-721.md)の最も一般的な用途の1つは、トークンに紐づけられたマルチメディアコンテンツを配布することです。ユーザーが複数のコレクションからNFTのバンドルを提供したい場合、それらを一括で扱う標準的な方法がありませんでした。この提案は、そのための標準化された方法を導入します。すべてのトークンをシンプルなバンドルにネストし、そのバンドルを販売すれば、すべてのトークンの所有権が1つのトランザクションで買い手に移転します。

### コレクション

多くのNFTユーザーは、無数の基準に基づいてNFTをコレクションしています。ユーティリティ、ユニーク性、視覚的な魅力など、さまざまな目的でNFTを集めています。特定のアカウントに紐づけられたNFTをグループ化する標準的な方法はありませんでした。この提案では、所有者の好みに応じてNFTをネストすることで、それを実現できます。ルートの親トークンは特定のグループのトークンを表し、それに子トークンがネストされることになります。

ソウルバウンド(不可譲渡)トークンの台頭は、この提案に対するさらなるニーズを生み出しています。複数のソウルバウンドな特性(子トークン)を持つトークンを持つことで、多様なユースケースが可能になります。サプライチェーンのユースケースから具体的な例を挙げると、自身の特性を持つNFTで表される輸送コンテナに、その旅程の各段階を表す子トークンをネストできます。

### メンバーシップ

NFTに付随する一般的な機能の1つが、分散自治組織(DAO)やその他の閉鎖アクセスグループへのメンバーシップです。これらの組織やグループは時折、メンバーシップNFTの保有者にボーナスのNFTをミントすることがあります。トークンをトークンにネストしてミントする機能により、そのようなミントは単にメンバーシップNFTに直接ボーナスNFTをミントすることで簡素化できます。

### 委任

DAOの中核的な機能の1つが投票であり、様々なアプローチがあります。1つのメカニズムは、メンバーが投票トークンを他のメンバーに送ることで投票を委任するというものです。この提案を使うと、投票NFTをあなたが投票を委任したNFTにネストし、委任を解除したい場合にそれを転送することで、委任された投票を処理できます。

## 仕様

この文書における「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されるものとします。

```solidity
/// @title EIP-7401 Parent-Governed Nestable Non-Fungible Tokens
/// @dev See https://eips.ethereum.org/EIPS/eip-7401
/// @dev Note: the ERC-165 identifier for this interface is 0x42b0e56f.

pragma solidity ^0.8.16;

interface IERC7059 /* is ERC165 */ {
    /**
     * @notice 所有権の中核となる構造体。
     * @dev `DirectOwner`構造体は、親トークン、`ERC721Receiver`コントラクト、外部所有アカウントのいずれかである、次の直接の所有者に関する情報を格納するために使用されます。
     * @dev トークンが NFT によって所有されていない場合、`tokenId`は必ず`0`になります。
     * @param tokenId 親トークンのID
     * @param ownerAddress トークンの所有者のアドレス。所有者が別のトークンである場合、アドレスはそのトークンのコレクションスマートコントラクトのものでなければなりません。所有者が外部所有アカウントである場合、アドレスはそのアカウントのものでなければなりません。
     */
    struct DirectOwner {
        uint256 tokenId;
        address ownerAddress;
    }

    /**
     * @notice 子トークンに関する情報を保持する中核的な子トークン構造体。
     * @return tokenId 子トークンのコレクションスマートコントラクト内のトークンID
     * @return contractAddress 子トークンのスマートコントラクトのアドレス
     */
    struct Child {
        uint256 tokenId;
        address contractAddress;
    }

    /**
     * @notice トークンが転送されていることをリスナーに通知するために使用されます。
     * @dev `tokenId`トークンが`from`から`to`に転送されたときに発行されます。
     * @param from 前の直接の所有者のアドレス。トークンがネストされていた場合は、スマートコントラクトになります。
     * @param to 新しい直接の所有者のアドレス。トークンがネストされる場合は、スマートコントラクトになります。
     * @param fromTokenId 前の親トークンのID。トークンがネストされていなかった場合、値は必ず`0`になります。
     * @param toTokenId 新しい親トークンのID。トークンがネストされていない場合、値は必ず`0`になります。
     * @param tokenId 転送されたトークンのID
     */
    event NestTransfer(
        address indexed from,
        address indexed to,
        uint256 fromTokenId,
        uint256 toTokenId,
        uint256 indexed tokenId
    );

    /**
     * @notice ある親トークンに新しい子トークンが追加されたことをリスナーに通知するために使用されます。
     * @dev 子NFTが親トークンの保留中の子トークン配列に追加されたときに発行されます。
     * @param tokenId 新しい保留中の子トークンを受け取ったトークンのID
     * @param childIndex 親トークンの保留中の子トークン配列における提案された子トークンのインデックス
     * @param childAddress 提案された子トークンのコレクションスマートコントラクトのアドレス
     * @param childId 子トークンのコレクションスマートコントラクト内のID
     */
    event ChildProposed(
        uint256 indexed tokenId,
        uint256 childIndex,
        address indexed childAddress,
        uint256 indexed childId
    );

    /**
     * @notice ある親トークンが新しい子トークンを受け入れたことをリスナーに通知するために使用されます。
     * @dev 親トークンが保留中の配列から子トークンを受け入れ、アクティブな配列に移行させたときに発行されます。
     * @param tokenId 新しい子トークンを受け入れたトークンのID
     * @param childIndex 親トークンのアクティブな子トークン配列に新しく受け入れられた子トークンのインデックス
     * @param childAddress 子トークンのコレクションスマートコントラクトのアドレス
     * @param childId 子トークンのコレクションスマートコントラクト内のID
     */
    event ChildAccepted(
        uint256 indexed tokenId,
        uint256 childIndex,
        address indexed childAddress,
        uint256 indexed childId
    );

    /**
     * @notice ある親トークンの保留中の子トークンがすべて拒否されたことをリスナーに通知するために使用されます。
     * @dev トークンが保留中の子トークンをすべて削除したときに発行されます。
     * @param tokenId 保留中の子トークンをすべて拒否したトークンのID
     */
    event AllChildrenRejected(uint256 indexed tokenId);

    /**
     * @notice ある子トークンが親トークンから転送されたことをリスナーに通知するために使用されます。
     * @dev トークンが子トークンを自身から転送し、所有権を移転したときに発行されます。
     * @param tokenId 子トークンを転送したトークンのID
     * @param childIndex 子トークンが転送された配列内のインデックス
     * @param childAddress 子トークンのコレクションスマートコントラクトのアドレス
     * @param childId 子トークンのコレクションスマートコントラクト内のID
     * @param fromPending 子トークンが保留中の子トークン配列にあった場合は`true`、アクティブな子トークン配列にあった場合は`false`
     * @param toZero 子トークンが`0x0`アドレスに転送された場合は`true`、そうでない場合は`false`
     */
    event ChildTransferred(
        uint256 indexed tokenId,
        uint256 childIndex,
        address indexed childAddress,
        uint256 indexed childId,
        bool fromPending,
        bool toZero
    );

    /**
     * @notice 指定したトークンの*ルート*所有者を取得するために使用されます。
     * @dev トークンの*ルート*所有者は、階層の最上位にあり、NFTではない所有者です。
     * @dev トークンが別のNFTによって所有されている場合、親の*ルート*所有者を再帰的に検索する必要があります。
     * @param tokenId *ルート*所有者が取得されたトークンのID
     * @return owner トークンの*ルート*所有者
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @notice 指定したトークンの直接の所有者を取得するために使用されます。
     * @dev 直接の所有者が別のトークンである場合、返されるアドレスは必ず親トークン
のコレクションスマートコントラクトのものでなければなりません。
* @param tokenId 所有者が取得されるトークンのID
* @return address トークンの所有者のアドレス
* @return uint256 親トークンのID。所有者がNFTでない場合は必ず`0`になります。
* @return bool 所有者がNFTであるかどうかを示すブール値
*/
    function directOwnerOf(uint256 tokenId)
        external
        view
        returns (
            address,
            uint256,
            bool
        );

    /**
     * @notice 指定したトークンを焼却するために使用されます。
     * @dev トークンが焼却されると、その子トークンもすべて再帰的に焼却されます。
     * @dev 最大再帰焼却数を指定する際は、焼却すべき子トークンがまだ残っている場合、実行がリバートされるようにする必要があります。
     * @dev `maxRecursiveBurn`の値を0に設定した場合は、指定されたトークンのみを焼却しようとし、子トークンが存在する場合はリバートされるべきです。
     * @param tokenId 焼却するトークンのID
     * @param maxRecursiveBurns 再帰的に焼却する最大トークン数
     * @return uint256 再帰的に焼却された子トークンの数
     */
    function burn(uint256 tokenId, uint256 maxRecursiveBurns)
        external
        returns (uint256);

    /**
     * @notice 指定した親トークンに子トークンを追加するために使用されます。
     * @dev これにより、子トークンが親トークンの保留中の子トークン配列に追加されます。
     * @dev 宛先トークンは、転送されるトークンの子トークンまたはその下流の子トークンであってはなりません。
     * @dev このメソッドは直接呼び出してはいけません。`nestTransfer`または`ERC7059`インターフェースを実装したコントラクトに対する`transferChild`の一部としてのみ呼び出されるべきです。
     * @dev 要件:
     *
     *  - 子コントラクトの`directOwnerOf`が呼び出しコントラクトを解決する必要があります。
     *  - 親コントラクトの保留中の配列が満杯でないこと。
     * @param parentId 新しい子トークンを受け取る親トークンのID
     * @param childId 新しく提案された子トークンのID
     */
    function addChild(uint256 parentId, uint256 childId) external;

    /**
     * @notice 指定した親トークンの保留中の子トークンを受け入れるために使用されます。
     * @dev これにより、子トークンが親トークンの保留中の子トークン配列からアクティブな子トークン配列に移行します。
     * @param parentId 子トークンを受け入れる親トークンのID
     * @param childIndex 保留中の子トークン配列における受け入れる子トークンのインデックス
     * @param childAddress 指定されたインデックスに存在することが期待される子トークンのコレクションスマートコントラクトのアドレス
     * @param childId 指定されたインデックスに存在することが期待される子トークンのID
     */
    function acceptChild(
        uint256 parentId,
        uint256 childIndex,
        address childAddress,
        uint256 childId
    ) external;

    /**
     * @notice 指定した親トークンの保留中の子トークンをすべて拒否するために使用されます。
     * @dev 保留中の配列マッピングから子トークンを削除します。
     * @dev 子トークンの所有権構造は更新されません。
     * @dev 要件:
     *
     * - `parentId`は存在する必要があります
     * @param parentId 保留中の子トークンをすべて拒否する親トークンのID
     * @param maxRejections 拒否する予定の子トークンの最大数。この操作の直前に新しい子トークンが追加されるのを防ぐために使用されます。
     */
    function rejectAllChildren(uint256 parentId, uint256 maxRejections) external;

    /**
     * @notice 指定した親トークンから子トークンを転送するために使用されます。
     * @dev 子トークンをアクティブまたは保留中の子トークンから削除する必要があります。
     * @dev 子トークンを転送する際、トークンの所有者は`to`に設定されるか、`to`が`0x0`アドレスの場合は更新されません。
     * @param tokenId 子トークンが転送される親トークンのID
     * @param to 子トークンを転送する先のアドレス(トークンでない場合は`0x0`)
     * @param destinationId 子トークンを受け取るトークンのID(トークンでない場合は`0`)
     * @param childIndex 転送する子トークンが属する配列(アクティブまたは保留中)内のインデックス
     * @param childAddress 子トークンのコレクションスマートコントラクトのアドレス
     * @param childId 子トークンのコレクションスマートコントラクト内のID
     * @param isPending 転送される子トークンが親トークンの保留中の配列にあるかどうかを示すブール値(`true`の場合は保留中、`false`の場合はアクティブ)
     * @param data `to`に送信される追加のデータ(フォーマットは指定されていない)
     */
    function transferChild(
        uint256 tokenId,
        address to,
        uint256 destinationId,
        uint256 childIndex,
        address childAddress,
        uint256 childId,
        bool isPending,
        bytes data
    ) external;

    /**
     * @notice 指定した親トークンのアクティブな子トークンを取得するために使用されます。
     * @dev 親トークンのアクティブな子トークンを含む Child 構造体の配列を返します。
     * @dev Child 構造体は以下の値で構成されます:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId 子トークンを取得する親トークンのID
     * @return struct[] 親トークンのアクティブな子トークンを含む Child 構造体の配列
     */
    function childrenOf(uint256 parentId)
        external
        view
        returns (Child[] memory);

    /**
     * @notice 指定した親トークンの保留中の子トークンを取得するために使用されます。
     * @dev 指定された親トークンの保留中の Child 構造体の配列を返します。
     * @dev Child 構造体は以下の値で構成されます:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId 保留中の子トークンを取得する親トークンのID
     * @return struct[] 親トークンの保留中の子トークンを含む Child 構造体の配列
     */
    function pendingChildrenOf(uint256 parentId)
        external
        view
        returns (Child[] memory);

    /**
     * @notice 指定した親トークンの特定のアクティブな子トークンを取得するために使用されます。
     * @dev 親トークンのアクティブな子トークン配列の`index`番目の Child 構造体を返します。
     * @dev Child 構造体は以下の値で構成されます:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId 子トークンを取得する親トークンのID
     * @param index 親トークンのアクティブな子トークン配列におけるインデックス
     * @return struct 指定された子トークンに関するChild構造体
     */
    function childOf(uint256 parentId, uint256 index)
        external
        view
        returns (Child memory);

    /**
     * @notice 指定した親トークンの特定の保留中の子トークンを取得するために使用されます。
     * @dev 親トークンの保留中の子トークン配列の`index`番目の Child 構造体を返します。
     * @dev Child 構造体は以下の値で構成されます:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId 保留中の子トークンを取得する親トークンのID
     * @param index 親トークンの保留中の子トークン配列におけるインデックス
     * @return struct 指定された子トークンに関するChild構造体
     */
    function pendingChildOf(uint256 parentId, uint256 index)
        external
        view
        returns (Child memory);

    /**
     * @notice トークンを別のトークンにネストして転送するために使用されます。
     * @dev 宛先トークンは、転送されるトークンまたはその下流の子トークンであってはなりません。
     * @param from 転送されるトークンの直接の所有者のアドレス
     * @param to トークンを受け取るコレクションスマートコントラクトのアドレス
     * @param tokenId 転送されるトークンのID
     * @param destinationId トークンを受け取るトークンのID
     * @param data 指定のフォーマットのない追加のデータ
     */
    function nestTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        uint256 destinationId,
        bytes memory data
    ) external;
}
```

IDは決して`0`値であってはいけません。この提案では、`0`値はトークン/宛先がNFTでないことを示すために使用されます。

## 根拠

提案を設計する際、以下の点を検討しました:

1. **提案の名称をどうするか?**\
提案の最も重要な側面であるパレントセンタリックなネスティングの制御に焦点を当てることで、提案の名称を決定しました。子トークンの役割は単にネスト可能であり、トークンに所有されることができるというものです。これが「パレントセンタリック」という言葉を使った理由です。
2. **[EIP-712](./eip-712.md)のペルミット形式の署名を使った自動的な子トークンの受け入れは、なぜこの提案に含まれていないのか?**\
一貫性のために。この提案はERC-721を拡張しており、トークンの操作に1つのトランザクションを使用しています。署名メッセージを使ったアセットの操作をサポートするのは、一貫性がありません。
3. **なぜインデックスを使うのか?**\
ガス消費を削減するためです。トークンIDを使ってトークンを受け入れたり拒否したりする場合、配列の反復が必要となり、操作のコストはアクティブまたは保留中の子トークンの配列のサイズに依存します。インデックスを使えば、コストは固定されます。トークンごとのアクティブおよび保留中の子トークンのリストを維持する必要があり、それらを取得するメソッドがこの提案のインターフェースの一部となっています。\
インデックスが変わるレースコンディションを避けるため、期待されるトークンIDおよびトークンのコレクションスマートコントラクトも、インデックスを使う操作に含まれています。\
内部的にインデックスを追跡するマッピングを使うことを試みましたが、子トークンを受け入れる最小コストが20%以上増加し、ミントのコストも15%以上増加しました。この提案には必要ではなく、コストの増加を受け入れられるユースケースのための拡張として実装できると結論付けました。提供されるサンプル実装には、これを可能にするいくつかのフックがあります。
4. **保留中の子トークンの配列は制限されているが、ページネーションはサポートされていないのはなぜか?**\
保留中の子トークンの配列は、親トークンのルート所有者が保持したいトークンを集めるためのバッファーではなく、簡単に移動できるトークン候補のリストであるべきです。定期的に保留中の子トークンを受け入れるか拒否する必要があります。保留中の子トークンの配列に制限を設けることにも意味があります。アクティブな子トークンの配列は無制限であるため。\
保留中の子トークンの配列に制限を設けることのもう1つの利点は、スパムやグリーフィングに対する防御です。悪意のあるトークンやスパムトークンをミントするのは比較的簡単で安価です。制限付きの保留中の配列により、すべての保留中のトークンを簡単に識別でき、スパムトークンの洪水の中に正当なトークンが埋もれてしまうことを防げます。\
この問題に関連して検討したのは、保留中の子トークンの配列をクリアする際に、正当なトークンが誤って拒否されないようにすることでした。保留中の子トークンを拒否する最大数の引数を追加したことで、意図した数の保留中の子トークンのみが拒否され、クリアの過程で新しいトークンが保留中の子トークンの配列に追加された場合でも、そのクリアがトランザクションをリバートさせるはずです。
5. **トークンを自身の子トークンの1つにネストすることを許可すべ
きか?**
この提案では、親トークンがその子トークンの1つ、またはその下流の子トークンの1つにネストされることを禁止しています。親トークンとその子トークンはすべて、親トークンのルート所有者によって管理されます。つまり、トークンが自身の子トークンの1つにネストされると、所有権のループが生まれ、そのループ内のトークンはもはや管理できなくなります。
6. **「安全な」ネストトランスファーメソッドはなぜ存在しないのか?**
`nestTransfer`は常に「安全」です。宛先の`IERC7059`互換性をチェックするためです。
7. **この提案は、同様の問題に取り組む他の提案とどのように異なるのか?**
このインターフェースでは、トークンを送信したり受け取ったりすることができます。提案-受け入れパターンと親主導パターンにより、より安全な使用が可能になります。下位互換性はERC-721のみに追加されているため、インターフェースがより単純になっています。また、提案は異なるコレクション間のネストをサポートするため、単一のスマートコントラクトに限定されません。\
さらに、この提案は[ERC-6059](./eip-6059.md)のインターフェースID、インターフェース仕様、サンプル実装の間の不整合に対処しています。

### 子トークン管理のための提案-コミットパターン

親トークンに子トークンを追加する際は、第三者による変更可能性を制限するために、提案-コミットパターンを使う必要があります。子トークンを親トークンに追加する際は、まず「保留中」の配列に置かれ、親トークンのルート所有者によって「アクティブ」の配列に移行される必要があります。「保留中」の子トークンの配列は、スパムやグリーフィングを防ぐために128スロットに制限されるべきです。

ルート所有者のみが子トークンを受け入れられるという制限により、提案には信頼性が生まれます。これにより、トークンのルート所有者が完全な制御権を持つことが保証されます。ユーザーが受け入れたくない子トークンを強制されることはありません。

### 親主導パターン

ネストされたトークンの親NFTとその親のルート所有者が、すべての面でそのトークンの真の所有者です。トークンを別のトークンに送信すると、所有権を放棄することになります。

ERC-721の`ownerOf`機能を引き続き使用しますが、これはトークンの所有者がNFTではない最上位の所有者に再帰的に辿り着くようになります。これを「ルート所有者」と呼びます。さらに、`directOwnerOf`を提供し、トークンの直接の所有者を3つの値(所有者アドレス、トークンIDが0の場合はNFTではない、NFTかどうかのフラグ)で返します。

ルート所有者または承認された当事者は、子トークンに対して以下の操作を行えるようにする必要があります: `acceptChild`、`rejectAllChildren`、`transferChild`。

ルート所有者または承認された当事者は、トークンがNFTによって所有されていない場合にのみ、以下の操作を行えるようにする必要があります: `transferFrom`、`safeTransferFrom`、`nestTransferFrom`、`burn`。

トークンがNFTによって所有されている場合、操作は親NFT自体のみが行えるようにする必要があります。転送は`transferChild`メソッドを使って親トークンから行う必要があり、このメソッドは内部で`nestTransferFrom`または`safeTransferFrom`を呼び出すべきです(宛先がNFTかどうかに応じて)。焼却の場合、まずトークンをEOAに転送してから焼却する必要があります。

この制限を設けるのは、親トークンから子トークンを削除する際の一貫性を保つためです。`transferChild`メソッドのみがこの役割を果たします。

### 子トークン管理

この提案では、いくつかの子トークン管理機能を導入しています。「保留中」から「アクティブ」の子トークン配列への許可付きの移行に加えて、主要な子トークン管理機能は`transferChild`関数です。`transferChild`関数を使って、以下の子トークンの状態遷移が可能です:

1. 子トークンを拒否する
2. 子トークンを放棄する
3. 子トークンのネストを解除する
4. 子トークンをEOAまたは`ERC721Receiver`に転送する
5. 子トークンを新しい親トークンにネストする

これらの状態遷移がどのように実現されるかを理解するには、`transferChild`に渡されるパラメータを見る必要があります:

```solidity
    function transferChild(
        uint256 tokenId,
        address to,
        uint256 destinationId,
        uint256 childIndex,
        address childAddress,
        uint256 childId,
        bool isPending,
        bytes data
    ) external;
```

目的の状態遷移に応じて、これらのパラメータの値を適切に設定する必要があります(以下の例で示されていないパラメータは、管理対象の子トークンに依存します):

1. **子トークンを拒否する**\
![子トークンを拒否する](../assets/eip-7401/img/eip-7401-reject-child.png)
2. **子トークンを放棄する**\
![子トークンを放棄する](../assets/eip-7401/img/eip-7401-abandon-child.png)
3. **子トークンのネストを解除する**\
![子トークンのネストを解除する](../assets/eip-7401/img/eip-7401-unnest-child.png)
4. **子トークンをEOAまたは`ERC721Receiver`に転送する**\
![子トークンをEOAに転送する](../assets/eip-7401/img/eip-7401-transfer-child-to-eoa.png)
5. **子トークンを新しい親トークンにネストする**\
![子トークンを親トークンに転送する](../assets/eip-7401/img/eip-7401-transfer-child-to-token.png)\
この状態変化により、トークンは新しい親トークンの保留中の配列に置かれます。子トークンがアクティブな配列に移行されるには、新しい親トークンのルート所有者によって受け入れられる必要があります。

## 下位互換性

ネスト可能なトークン標準は[ERC-721](./eip-721.md)と互換性を持つように作られており、ERC-721の堅牢なツーリングを活用し、既存のERC-721インフラストラクチャとの互換性を確保しています。

ERC-721との唯一の非互換性は、ネスト可能なトークンがトークンID 0を使用できないことです。

`ownerOf`メソッドの動作は、ERC-721と比べて少し異なります。`ownerOf`メソッドは、NFTではない所有者に再帰的に辿り着くようになります。これを「ルート所有者」と呼びます。さらに、直接の所有者を3つの値(所有者アドレス、NFTでない場合は0、NFTかどうかのフラグ)で返す`directOwnerOf`を提供しています。トークンがEoAまたはERC-721 Receiverによって所有されている場合、`ownerOf`メソッドはERC-721と同様に動作します。

## テストケース

テストは [`nestable.ts`](../assets/eip-7401/test/nestable.ts) に含まれています。

ターミナルでそれらを実行するには、以下のコマンドを使用できます:

```
cd ../assets/eip-7401
npm install
npx hardhat test
```

## リファレンス実装

[`NestableToken.sol`](../assets/eip-7401/contracts/NestableToken.sol) を参照してください。

## セキュリティ上の考慮事項

[ERC-721](./eip-721.md)と同様のセキュリティ上の考慮事項が適用されます。関数(焼却、子の追加、子の受け入れなど)に隠されたロジックが存在する可能性があります。

現在のトークンの所有者がトークンを管理できるため、親トークンが販売リストに掲載された後に、売り手が予想外の子トークンを削除する可能性があります。これは、この標準の設計に固有のリスクです。マーケットプレイスは、この点を考慮し、期待される子トークンが存在することを確認する方法を提供するか、そのような悪意のある行動を別の方法で防ぐ必要があります。

`balanceOf`メソッドは、アドレスが直接所有するトークンのみを考慮することに注意が必要です。このアドレスが所有するトークンにネストされたトークンは、必要な再帰的な検索が深すぎて破損する可能性があるため、この値に反映されません。

監査されていないコントラクトを扱う際は注意が必要です。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。