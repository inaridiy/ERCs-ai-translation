---
original: 935a861ff743060a8d9410601b620db45c27ac72248e008760a8bbd66469c571
---

---
eip: 1775
title: アプリケーションキー、アプリケーション固有のウォレットアカウント
author: Vincent Eli (@Bunjin)、Dan Finlay (@DanFinlay)
discussions-to: https://ethereum-magicians.org/t/eip-erc-app-keys-application-specific-wallet-accounts/2742
status: 停滞
type: Standards Track
category: ERC
created: 2019-02-20
---

## 簡単な要約

他の暗号化アプリケーションの中でも、Ethereum ブロックチェーンのスケーラビリティとプライバシーソリューションでは、ユーザーが多数の署名操作を行う必要があります。また、状態を監視し、データに自動的に署名する準備をする必要もあります(例えば、状態に署名したり、引き出しを争うなど)。現在のウォレットがアカウントを実装する方法には、UX、セキュリティ、プライバシーの面で、Web3.0 体験を完全に実現するうえで、いくつかの障害があります。

この提案では、各アプリケーションに特化して派生したウォレットアカウントの標準とAPIについて説明します。これらを「アプリケーションキー」と呼ぶことを提案します。アプリケーション間でアカウントを分離することで、プライバシーが向上する可能性があります。また、アカウント管理と署名の委任に関してアプリケーション開発者により多くの制御権を与えることもできます。これらのアプリケーションキーについては、メインアカウントのセキュリティを維持しつつ、より許可レベルの高いセキュリティ(例えば、ユーザーの確認を要求しない)をウォレットに設定できます。最後に、ウォレットは、トランザクションを送信せずに署名することを許可するなど、異なる動作を実装することもできます。

この新しいアカウントタイプにより、UXを大幅に改善し、暗号化された許可付きのWebアプリケーションの新しいデザインを可能にすることができます。

## 概要
ウォレットでは、ユーザーはほとんどの資金をメインアカウントに保持しています。これらのアカウントには高いセキュリティレベルが必要で、いかなる方法でも委任してはいけません。これにより、ユーザーが毎回アクションを手動で確認しなければならない場合、暗号化アプリケーションの設計に大きな影響を与えます。また、ユーザーが同じアカウントを複数のアプリで使用することは、プライバシーと潜在的なセキュリティの問題にもなります。

ここでは、署名の委任とアプリケーション間のアカウント分離によるプライバシーとセキュリティを可能にする、新しいアカウントタイプであるアプリケーションキーを紹介します。

このEIPでは、各アプリケーションを一意に識別および認証する方法、ユーザーの秘密鍵(ルート秘密鍵または派生/非派生のその他の秘密鍵)から、ドメイン固有のマスターアカウント(またはアプリケーションキー)を派生させる方法を提案します。このEIPは、ユーザーがウォレットを復元し、アプリケーションを再度使用する際に、ユーザーの追加入力なしに再生成できる、アプリケーション固有のキーの標準化を目指しています。

これらのアプリケーションキーには、[EIP-2255](./eip-2255.md)で導入された `requestPermission` モデルを通じて、異なる一連の権限を与えることができます。これにより、ユーザーがメインアカウントのセキュリティを損なうことなく、一部のアプリに暗号化操作を代行させることができる可能性があります。

## 動機
ウォレット開発者は、BIP32、BIP44、SLIP44を使用してEthereum アカウントのHD派生パスで合意してきました[(ここでの議論を参照)](https://github.com/ethereum/EIPs/issues/84)。Web3 ウォレットは、ほぼ同様の方法でeth rpcを実装してきました。[EIP-1102](./eip-1102.md)は、ウォレットアカウントをアプリに自動的に参加させないことで、プライバシーを向上させました。

しかし、暗号化された許可付きアプリの適切な設計とUXを可能にするには、いくつかの制限が残されています。

ほとんどのGUIベースの現在のウォレットでは、以下のことができません:
* 各アプリに異なるキー/アカウントを自動的かつ簡単に使用できる
* メインアカウントと同じレベルのセキュリティで、アプリのアクションに署名できる
* 匿名性を向上させるためのスロー可能なキーを使用できる
* アプリのトランザクションに署名してから送信せずに、通常どおりメインアカウントからトランザクションを行うことができる
* ユーザーのニーモニックまたはハードウェアウォレットと、アプリのENS名によって一意に決まるHDパスを使って、完全に復元できる

これらの制限を克服するために、メインアカウントと並行して使用できる新しいアカウントタイプであるアプリケーションキーを導入しようとしています。

これらの新しいアプリケーションキーにより、暗号化アプリ開発者により多くの権限と柔軟性を与えることができます。これにより、暗号化 dapps のUXを大幅に改善し、これまでは不可能だった新しいデザインを生み出すことができます。これらの機能は、ユーザーの大部分の資金を保持するメインアカウントに要求されていたセキュリティレベルとは両立できませんでした。

## 仕様

### アプリケーション

アプリは、ウォレットにこの用途専用の暗号化キーへのアクセスを要求したいウェブサイト(またはその他)です。これは、Ethereum ベースのみならず、あらゆる形態の暗号化/ID依存アプリケーションになり得ます。

ウォレットに接続すると、アプリケーションは、以下のアルゴリズムを使用して、ユーザーが選択したアカウントに固有に派生したアカウントにアクセスすることを要求できます。

### プライベートアプリケーションキーの生成アルゴリズム

ここでは、アプリケーションキーを生成するアルゴリズムを提案します。これらのキーは:
- ユーザーが選択したアカウントに関して一意に定義される
- したがって、ユーザーアカウントを変更する際に分離できるため、パーソナ管理が可能(次のセクション参照)
- 各アプリケーションに固有
- ユーザーのマスターシードニーモニックとアプリケーション名から完全に復元できる

#### 異なるアカウントをパーソナとして使用する

ユーザーは、各アカウントを使ってアプリケーションキーの異なるセットを生成することができます。したがって、同じマスターシードニーモニックから、ユーザーは各アカウントインデックスを使ってアプリケーションキーの代替セットを使用できます。これを「パーソナ」の使用と呼ぶことができます。

これにより、ユーザーは、同じニーモニックを使って、ある特定のアプリに対して完全に分離された個人用と業務用のプロファイルを作成することができます。ドメインは、両方のプロファイルの背後にいるのが同じ人物とニーモニックであることを認識しないでしょう。

アプリケーションがユーザーの複数のメインアカウントと対話する場合、これらのアカウントの1つをマスターアカウントとして使用し、他のものを補助アカウントとして使用することができます。

このEIPは、アプリケーションキーを生成するために使用するプライベートキーを生成する方法について、特に定めていません。ただし、互換性の目的と、パーソナとクリプトカレンシーアカウントの明確な区別のために、このEIPとは別の新しいEIPを近々提案する予定です。

#### アプリケーションの一意の識別子

各アプリケーションは、その発信元であるドメイン文字列によって一意に定義され、認証されます。これは、ドメインネームサービス(DNS)名、または将来的にはイーサリアムネームサービス(ENS)名やIPFSハッシュになる可能性があります。

IPFSやswarmの発信元の場合は、IPFSやswarmアドレスを発信元として使用するか、それらがENSエントリを通じて指し示されるよう要求し、ENSアドレスを発信元として使用することができます。ただし、参照するコンテンツが変更される可能性があるため、セキュリティとアップデート可能性のモデルが異なります。

ENSドメインがIPFSアドレスを指し示す場合は、プロトコルプレフィックスを要求する必要があるでしょう:
`ens://ipfs.snap.eth`

#### プライベートアプリケーションキーの生成アルゴリズム

アプリケーションのドメイン名を使用して、ユーザーのアカウントごとにアプリケーション固有の秘密鍵を生成します:

`const appKeyPrivKey = keccak256(privKey + originString)`

ここで、`+`は連結、`privKey`はユーザーが選択したアカウントの秘密鍵、`originString`はアプリケーションキーへのアクセス要求が発信されたオリジンURLを表します。

これは、任意のドメインがリクエストされたアカウント(利用可能な場合)に関連するアプリケーションキーを要求できるようにするRPCメソッドとして公開されます:

```
const appKey = await provider.send({
  method: 'wallet_getAppKeyForAccount',
  params: [address1]
});
```

実装例は以下を参照してください:
https://github.com/MetaMask/eth-simple-keyring/blob/master/index.js#L169

#### アプリケーションキーとHierarchical Deterministic keys

前述のアルゴリズムで生成されたアプリケーションキーはBIP32準拠ではありません。したがって、アプリは直接、複数のアプリケーションキーを作成したり、非ハードニングや拡張公開鍵の技術を使用したりすることはできません。アプリは(発信元ごと、パーソナごとに)単一の秘密鍵を取得します。

ただし、この秘密鍵を初期エントロピーとして使用し、新しいHDツリーを生成し、ハードニングされているかどうかに関わらず、アドレスを生成することができます。したがって、ユースケースを失うことはありません。

## 根拠

### アプリケーションキーの共有
このEIPでは、ページ間でこれらのアプリケーションキーを共有する場合を明示的に扱っていませんが、合成によってこのニーズを満たすことができます。

ドメインはパーソナごとに一意のキーを取得するため、ドメイン間で通信できるため、ある1つのドメイン(アプリ)が別のドメイン(署名者)に、そのアプリケーションキーをシードとして、暗号化操作の実行を要求できます。これにより、新しい署名戦略を簡単に追加できるようになります。

これを、信頼できる暗号化関数の実装のスタティックハッシュを表すドメインに渡すこともできます。これは、監査済みの内部依存関係を呼び出すのと同じくらい安全です。

### プライバシーと資金の履歴

アプリケーションがキーを使用して行う必要があるのがメッセージの署名のみで、資金調達を必要としない場合、このEIPにより、ウォレット間で互換性のある単純な決定論的標準を使用して、各アプリケーション用の個別のキーを使用することでプライバシーが確保できます。

ただし、これらのアプリケーションキーに資金が必要な場合、履歴が残り、アプリケーションキーの使用ではプライバシー問題は完全に解決されません。

ミキサーや、Ethereum アドレスに匿名で資金を供給する方法(リングシグネチャなど)と、この提案を組み合わせれば、プライバシーを保証できます。

プライバシーが匿名の資金調達方法なしでは完全には解決されない場合でも、アプリケーションごとに異なるアカウント/アドレスを簡単に作成および復元する方法が必要です。

## 下位互換性
ウォレットの観点からは、これらは以前ウォレットが使用していたアカウントとは別のアカウントであり、相
互に補完的に使用されるため、互換性の問題はないようです。

ただし、ユーザーのメインアカウントとなんらかの関連付けを行っていたアプリケーションは、`アプリケーションキー`の活用と、それが可能にする新しいアプリデザインへの移行について検討する必要があるかもしれません。

## 実装

以下は、標準(非HW)のMetaMaskアカウントに対するアプリケーションキーの初期実装です。
https://github.com/MetaMask/eth-simple-keyring/blob/6d12bd9d73adcccbe0b0c7e32a99d279085e2934/index.js#L139-L152

MetaMaskのプラグインと共にアプリケーションキーを実装したフォークは以下にあります:
https://github.com/MetaMask/metamask-snaps-beta
https://github.com/MetaMask/metamask-snaps-beta/wiki/Plugin-API

## 使用例

* トランザクションに署名してから送信しない
https://github.com/MetaMask/metamask-extension/issues/3475

* トークンコントラクト
https://github.com/ethereum/EIPs/issues/85

* dappsのデフォルトアカウント
https://ethereum-magicians.org/t/default-accounts-for-dapps/904

* ウォレット/暗号以外のアカウント
[EIP1581: BIP32ツリーから派生したキーの非ウォレット使用](./eip-1581.md)

* ステートチャンネルアプリケーション

* プライバシーソリューション

* 非保管型の暗号通貨間取引など

## 謝辞
MetaMaskチーム、Christian Lundkvist、Counterfactualチーム、Liam Horne、Erik Bryn、Richard Moore、Jeff Coleman。

## 参考文献

### HDとニーモニック
#### BIPs
* [BIP32: 階層的決定性ウォレット:](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)

* [BIP39: 決定論的キー生成用ニーモニックコード:](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)

* [SLIP44: BIP44の登録された通貨の種類](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)


#### Eth用の派生パス
* [Issue 84](https://github.com/ethereum/EIPs/issues/84)

* [Issue 85](https://github.com/ethereum/EIPs/issues/85)

* [EIP600 Deterministic Walletsの目的割り当て](./eip-600.md)


* [EIP601 Deterministic Walletsの階層](./eip-601.md)


### アプリケーションキーに関連する以前の提案と議論
* [Meta: プライバシーをもっと大切にすべきだ](https://ethereum-magicians.org/t/meta-we-should-value-privacy-more/2475)

* [EIP1102: オプトイン式アカウントエクスポージャー](./eip-1102.md)

* [EIP1581: BIP-32ツリーから派生したキーの非ウォレット使用](./eip-1581.md)

* [EIP1581: 議論](https://ethereum-magicians.org/t/non-wallet-usage-of-keys-derived-from-bip-32-trees/1817/4)

* [SLIP13: 決定論的階層を使った認証](https://github.com/satoshilabs/slips/blob/master/slip-0013.md)


## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。