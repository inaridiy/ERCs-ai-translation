---
original: 3f06353d818295ae91d5411623ddd91f08da6d17e22934650c74b4b5f6776847
---

---
eip: 7390
title: ERC-20トークンのバニラオプション
description: 単純な期限付きコール/プット(バニラ)オプションの作成、管理、実行のためのインターフェース。
author: Ewan Humbert (@Xeway) <xeway@protonmail.com>, Lassi Maksimainen (@mlalma) <lassi.maksimainen@gmail.com>
discussions-to: https://ethereum-magicians.org/t/erc-7390-vanilla-option-standard/15206
status: Draft
type: Standards Track
category: ERC
created: 2022-09-02
requires: 20, 1155
---

## 概要

このスタンダードは、バニラオプションの円滑な相互作用(作成、管理、行使など)を可能にする包括的な関数とイベントを定義しています。

バニラオプションは、指定された期間内に資産を設定された価格で買う権利(コールオプション)または売る権利(プットオプション)を付与しますが、義務はありません。

このスタンダードは、満期日後に使用できなくなる単純なオプションを表すものではありません。代わりに、必要な発行を保存できます。各発行はIDで識別され、他の発行とは独立して購入、行使、キャンセルなどができます。
各発行は担保付きで、つまり発行者はバイヤーが購入する前に契約に担保を提供する必要があります。バイヤーが行使期間内に行使しない場合、発行者は担保を取り戻すことができます。
バイヤーは発行の一部分のみを購入することを決めることができ(つまり複数のバイヤーが可能)、それに応じて発行の一部分を表す[ERC-1155](./eip-1155.md)トークンを受け取ります。これらのトークンを「償還トークン」と呼びます。これらのトークンはユーザー間で交換でき、オプションの行使に使用されます。このメカニズムにより、バイヤーは購入したものの一部分のみを行使することを決めることができます。
また、発行者は、オプションがまだ購入されていない場合、発行をキャンセルすることができます。プレミアム価格を随時更新する権利も持っています。これは既に購入されたオプションには影響しません。
基礎資産トークン、ストライクトークン、プレミアムトークンは[ERC-20](./eip-20.md)トークンです。

以下では、複数形の「オプション」という用語を使うことがあります。これは、バイヤーが購入し、行使できる償還トークンの量を指す場合があります。

## 動機

オプションは広く使用される金融商品であり、投資家や取引者にとって真の有用性があります。リスク管理ツールと投機的な機会を提供します。
分散型ファイナンスでは、多くのオプション販売プラットフォームが登場しましたが、これらのプロトコルのそれぞれが独自のオプションの定義を実装しています。これにより、互換性がなくなるのは残念です。なぜなら、オプションは代替可能/非代替可能トークンのように相互運用可能であるべきだからです。
バニラオプション契約の標準インターフェースを導入することで、より包括的で相互運用可能な派生商品エコシステムの育成を目指します。このスタンダードは、ユーザーエクスペリエンスを向上させ、分散型オプションプラットフォームの開発を促進し、ユーザーが異なるアプリケーション間でシームレスにオプションを取引できるようにします。さらに、このスタンダードは最も一般的なタイプのオプションであるバニラオプションを表すように設計されています。このスタンダードは、エキゾチックオプションなどのより複雑なオプションの基礎として使用できます。

## 仕様

このプロポーザルの実装では、一部の購入を可能にするために、ERC-1155も実装する必要があります。

### インターフェース

```solidity
interface IERC7390 {
    enum Side {
        Call,
        Put
    }

    struct VanillaOptionData {
        Side side;
        address underlyingToken;
        uint256 amount;
        address strikeToken;
        uint256 strike;
        address premiumToken;
        uint256 premium;
        uint256 exerciseWindowStart;
        uint256 exerciseWindowEnd;
        address[] allowed;
    }

    struct OptionIssuance {
        VanillaOptionData data;
        address writer;
        uint256 exercisedAmount;
        uint256 soldAmount;
    }

    error Forbidden();
    error TransferFailed();
    error TimeForbidden();
    error AmountForbidden();
    error InsufficientBalance();

    event Created(uint256 indexed id);
    event Bought(uint256 indexed id, uint256 amount, address indexed buyer);
    event Exercised(uint256 indexed id, uint256 amount);
    event Expired(uint256 indexed id);
    event Canceled(uint256 indexed id);
    event PremiumUpdated(uint256 indexed id, uint256 amount);
    event AllowedUpdated(uint256 indexed id, address[] allowed);

    function create(VanillaOptionData calldata optionData) external returns (uint256);

    function buy(uint256 id, uint256 amount) external;

    function exercise(uint256 id, uint256 amount) external;

    function retrieveExpiredTokens(uint256 id, address receiver) external;

    function cancel(uint256 id, address receiver) external;

    function updatePremium(uint256 id, uint256 amount) external;

    function updateAllowed(uint256 id, address[] memory allowed) external;

    function issuance(uint256 id) external view returns (OptionIssuance memory);
}
```

### 状態変数の説明

作成時に、ユーザーは `VanillaOptionData` 構造体のインスタンスを提供する必要があり、これには、オプション発行の初期化に必要なすべての重要な情報が含まれています。

#### `side`

**型: `enum`**

オプションの側面。`Call`または`Put`の値を取ることができます。`Call`オプションは、オプションのバイヤーに、発行者から`strikeToken`を使って`underlying`トークンを`strike`価格で購入する権利を与えます。同様に、`Put`オプションは、オプションのバイヤーに、`underlying`トークンを発行者に`strike`価格で売る権利を与えます。

#### `underlyingToken`

**型: `address` ([ERC-20](./eip-20.md)コントラクト)**

基礎資産トークン。

#### `amount`

**型: `uint256`**

行使できる基礎資産トークンの最大量。

> トークンの小数点以下の桁数に注意してください!

#### `strikeToken`

**型: `address` (ERC-20コントラクト)**

ストライク価格の基準となるトークン。

#### `strike`

**型: `uint256`**

ストライク価格。オプションのバイヤーは、発行の一部分のみを行使できる可能性があり、支払うストライク価格は、契約によって調整される必要があります。

`strike`は、`underlyingToken`の1単位あたりの`strikeToken`の価格を表すことに注意してください。

> トークンの小数点以下の桁数に注意してください!

#### `premiumToken`

**型: `address` (ERC-20コントラクト)**

プレミアムトークン。

#### `premium`

**型: `uint256`**

プレミアム価格は、発行者がオプションの発行によるリスクを補償するために、バイヤーが発行者に支払う価格です。オプションのプレミアムは、基礎資産トークンの変動性、ストライク価格、オプション満期までの残り時間などの様々な要因によって変化します。

**プレミアム価格は、発行の全`amount`の行使に設定されることに注意してください。バイヤーは発行の一部分のみを購入できる可能性があり、支払うプレミアム価格は、契約によって調整される必要があります。**

> トークンの小数点以下の桁数に注意してください!

#### `exerciseWindowStart`

**型: `uint256`**\
**フォーマット: *Unix時代からの秒数としてのタイムスタンプ***

オプション行使ウィンドウの開始時間。現在の時間が`exerciseWindowStart`以上で、`exerciseWindowEnd`以下の場合、オプションの所有者はそれらを行使できます。

#### `exerciseWindowEnd`

**型: `uint256`**\
**フォーマット: *Unix時代からの秒数としてのタイムスタンプ***

オプション行使ウィンドウの終了時間。現在の時間が`exerciseWindowStart`以上で、`exerciseWindowEnd`以下の場合、オプションの所有者はそれらを行使できます。現在の時間が`exerciseWindowEnd`を超えると、バイヤーは行使できず、発行者は残りの基礎資産(コール)またはストライク(プット)トークンを取り戻すことができます。

#### `allowed`

**型: `address[]`**

発行を購入できる許可されたアドレス。配列が空の場合、すべてのアドレスが発行を購入できます。

`VanillaOptionData`は`OptionIssuance`構造体に保存され、オプション発行データを保持します。他の情報も含まれています。

#### `writer`

**型: `address`**

オプションを作成したアドレス、つまり発行者のアドレス。

#### `exercisedAmount`

**型: `uint256`**

行使された基礎資産トークンの量。

#### `soldAmount`

**型: `uint256`**

この発行で購入された基礎資産トークンの量。

#### `transferredExerciseCost`

**型: `uint256`**

オプション発行の買い手(コール)または売り手(プット)に転送された`strikeToken`トークンの量。\
これは、`exercisedAmount`が更新されるたびに計算する必要がないように使用される補助変数です。計算は`(amount * selectedIssuance.data.strike) / (10**underlyingToken.decimals())`です。

#### `exerciseCost`

**型: `uint256`**

行使コスト。これは、発行者が契約に預託しなければならない担保(プット)、または全てのバイヤーが行使を決めた場合に発行者が受け取ることができる`strikeToken`トークンの量(コール)を表します。\
これは、常に行使コストを計算する必要がないように使用される補助変数です。オプション作成時に計算します。計算は`(strike * amount) / (10 ** underlyingToken.decimals())`です。

### 関数の説明

#### `constructor`

このスタンダードには構築関数は必要ありませんが、コントラクトはERC-1155インターフェースも実装する必要があります。したがって、コントラクトはERC-1155の構築関数を呼び出す必要があります。

#### `create`

```solidity
function create(VanillaOptionData calldata optionData) external returns (uint256);
```

オプション発行者は新しいオプショントークンを作成し、`create()`を使ってオプションパラメータを定義します。引数として、オプション発行者は `VanillaOptionData` データ構造体のインスタンスを記入し、メソッドに渡す必要があります。オプショントークンの作成の一環として、この関数は発行者から契約に担保を転送します。

オプション発行が完全に担保付きになることが強く推奨されます。コールオプション(プットオプション)発行の場合、発行者は`create()`を呼び出す前に、`amount`(`strike`)トークンの`underlyingToken`(`strikeToken`)の転送を許可する必要があります。

このスタンダードでは、オプション契約が担保不足を許可する場合の発行者による「再充填」の機能は定義していません。契約はそのAPIとアプリケーションを適切に調整する必要があります。

`underlyingToken`または`strikeToken`がゼロアドレスの場合は、必ず元に戻す必要があります。\
`premium`が0でなく`premiumToken`がゼロアドレスの場合は、必ず元に戻す必要があります。\
`amount`または`strike`が0の場合は、必ず元に戻す必要があります。\
`exerciseWindowStart`が現在の時間より前の場合、または`exerciseWindowEnd`が`exerciseWindowStart`より前の場合は、必ず元に戻す必要があります。

*オプション発行が成功した場合、作成されたオプション発行を参照するIDを返します。*
*オプション発行が成功した場合、`Created`イベントを発行します。*

#### `buy`

```solidity
function buy(uint256 id, uint256 amount) external;
```

バイヤーが`id`で定義されたオプション発行から`amount`のオプショントークンを購入できるようにします。

バイヤーは、指定された`premiumToken`の(全体の一部分の)`premium`をトークンコントラクトに転送することを許可する必要があります。関数呼び出し中に、プレミアムは直接発行者に転送されます。

`allowed`配列が空でない場合、バイヤーのアドレスがこのリストに含まれている必要があります。\
`amount`が0または購入可能
な残りのオプションよりも大きい場合は、必ず元に戻す必要があります。\
`exerciseWindowEnd`を超えた現在の時間の場合は、必ず元に戻す必要があります。

*購入が成功した場合、バイヤーのアドレスに`amount`の償還トークンをミントします。*
*購入が成功した場合、`Bought`イベントを発行します。*

#### `exercise`

```solidity
function exercise(uint256 id, uint256 amount) external;
```

バイヤーが`id`で定義されたオプション発行から`amount`のオプショントークンを行使できるようにします。

- オプションがコールの場合、バイヤーは発行者に指定されたストライク価格で支払い、指定された基礎資産トークンを受け取ります。
- オプションがプットの場合、バイヤーは基礎資産トークンを発行者に転送し、指定されたストライク価格で支払いを受け取ります。

バイヤーは、`exercise()`を呼び出す前に、`strikeToken`または`underlyingToken`の使用を許可する必要があります。

行使は、`exerciseWindowStart` <= 現在時間 <= `exerciseWindowEnd`の場合にのみ行うことができます。\
`amount`が0の場合、またはバイヤーがオプションを行使するのに必要な償還トークンを持っていない場合は、必ず元に戻す必要があります。

*行使が成功した場合、バイヤーのアドレスから`amount`の償還トークンを焼却します。*
*オプション行使が成功した場合、`Exercised`イベントを発行します。*

#### `retrieveExpiredTokens`

```solidity
function retrieveExpiredTokens(uint256 id, address receiver) external;
```

発行者が行使されなかった担保トークンを取り戻すことを可能にします。これらのトークンは`receiver`に転送されます。\
オプションがコールの場合、`receiver`は基礎資産トークンを取り戻します。オプションがプットの場合、`receiver`はストライクトークンを取り戻します。

関数を呼び出しているアドレスがオプション発行の発行者ではない場合は、必ず元に戻す必要があります。\
`exerciseWindowEnd`が現在時間以上の場合は、必ず元に戻す必要があります。\
ゼロアドレスの場合、`receiver`を呼び出し元のアドレスに設定する必要があります。

*行使されなかった担保をライターのアドレスに転送します。*
*取り戻しが成功した場合、オプション発行をコントラクトから削除する可能性があります。*
*取り戻しが成功した場合、`Expired`イベントを発行します。*

#### `cancel`

```solidity
function cancel(uint256 id, address receiver) external;
```

発行者がオプションをキャンセルし、担保として使用されたトークンを取り戻すことを可能にします。これらのトークンは`receiver`に転送されます。\
オプションがコールの場合、`receiver`は基礎資産トークンを取り戻します。オプションがプットの場合、`receiver`はストライクトークンを取り戻します。

関数を呼び出しているアドレスがオプション発行の発行者ではない場合は、必ず元に戻す必要があります。\
少なくとも1つのオプションの一部が購入されている場合は、必ず元に戻す必要があります。\
ゼロアドレスの場合、`receiver`を呼び出し元のアドレスに設定する必要があります。

*行使されなかった担保をライターのアドレスに転送します。*
*キャンセルが成功した場合、オプション発行をコントラクトから削除する可能性があります。*
*キャンセルが成功した場合、`Canceled`イベントを発行します。*

#### `updatePremium`

```solidity
function updatePremium(uint256 id, uint256 amount) external;
```

発行者がオプションを購入するバイヤーが提供する必要があるプレミアムを更新できるようにします。

**`amount`は全体の基礎資産量に対するものであり、まだ購入可能なオプションのみに対するものではないことに注意してください。**

関数を呼び出しているアドレスがオプション発行の発行者ではない場合は、必ず元に戻す必要があります。\
`exerciseWindowEnd`を超えた現在の時間の場合は、必ず元に戻す必要があります。

*関数呼び出しが正常に処理された場合、`PremiumUpdated`イベントを発行します。*

#### `updateAllowed`

```solidity
function updateAllowed(uint256 id, address[] memory allowed) external;
```

発行者がオプション発行を購入できる許可されたアドレスのリストを更新できるようにします。\
すでにオプションを購入したバイヤーのアドレスが新しいリストにない場合でも、購入したオプションを行使することができます。

関数を呼び出しているアドレスがオプション発行の発行者ではない場合は、必ず元に戻す必要があります。\
`exerciseWindowEnd`を超えた現在の時間の場合は、必ず元に戻す必要があります。

*関数呼び出しが正常に処理された場合、`AllowedUpdated`イベントを発行します。*

#### `issuance`

```solidity
function issuance(uint256 id) external view returns (OptionIssuance memory);
```

指定された`id`のオプション発行に関するすべての重要な情報を返します。

### イベント

#### `Created`

```solidity
event Created(uint256 id);
```

ライターがオプション発行データを正常に提供し(そして担保をコントラクトにロックダウンした)場合に発行されます。与えられた`id`は特定のオプション発行を識別します。

#### `Bought`

```solidity
event Bought(uint256 indexed id, uint256 amount, address indexed buyer);
```

オプションが購入された場合に発行されます。オプション発行の`id`、`buyer`のアドレス、および購入された`amount`のオプションに関する情報を提供します。

#### `Exercised`

```solidity
event Exercised(uint256 indexed id, uint256 amount);
```

`id`で指定されたオプション発行から`amount`のオプションが行使された場合に発行されます。

#### `Expired`

```solidity
event Expired(uint256 indexed id);
```

`id`のオプション発行の発行者が行使されなかった担保を取り戻した場合に発行されます。

#### `Canceled`

```solidity
event Canceled(uint256 indexed id);
```

`id`で指定されたオプション発行がライターによってキャンセルされた場合に発行されます。

#### `PremiumUpdated`

```solidity
event PremiumUpdated(uint256 indexed id, uint256 amount);
```

ライターが`id`で指定されたオプション発行のプレミアムを`amount`に更新した場合に発行されます。更新されたプレミアムは全発行に対するものです。

#### `AllowedUpdated`

```solidity
event AllowedUpdated(uint256 indexed id, address[] allowed);
```

ライターが`id`で指定されたオプション発行の許可されたアドレスのリストを更新した場合に発行されます。

### エラー

#### `Forbidden`

呼び出し元に一部の操作が許可されていない場合に戻します(汎用目的)。

#### `TransferFailed`

トークンの転送に失敗した場合に戻します。

#### `TimeForbidden`

実行時の現在時刻が無効な場合に戻します。

#### `AmountForbidden`

金額が無効な場合に戻します。

#### `InsufficientBalance`

呼び出し元の残高が不足している場合に戻します。

### 具体的な例

#### コールオプション

Bob がコール**オプションを売ると仮定しましょう。**
彼は2023年7月14日から2023年7月16日(深夜)の間に**TokenA**を**TokenB**で**25**ずつ**8個**買う権利を誰にでも与えます。
そのようなコントラクトに対して、彼は**TokenC**で**10**のプレミアムを受け取りたいと考えています。

オプションを作成する前に、Bobは担保をコントラクトに転送する必要があります。この担保は、オプションが完全に行使された場合に彼が渡さなければならないトークン(`amount`)に相当します。このオプションの場合、彼は8 TokenAを担保として提供する必要があります。これを行うには、TokenAのコントラクトで`approve(address spender, uint256 amount)`関数を呼び出し、パラメータとしてコントラクトのアドレス(`spender`)と`amount`: **8 \* 10^(TokenAの小数点以下の桁数)**を指定します。その後、Bobは以下のパラメータを使って`create()`をコントラクトで実行してオプションを発行できます:

- `side`: **Call**
- `underlyingToken`: **TokenAのアドレス**
- `amount`: **8 \* 10^(TokenAの小数点以下の桁数)**
- `strikeToken`: **TokenBのアドレス**
- `strike`: **25 \* 10^(TokenBの小数点以下の桁数)**
- `premiumToken`: **TokenCのアドレス**
- `premium`: **10 \* 10^(TokenCの小数点以下の桁数)**
- `exerciseWindowStart`: **1689292800** *(2023-07-14のタイムスタンプ)*
- `exerciseWindowEnd`: **1689465600** *(2023-07-16のタイムスタンプ)*
- `allowed`: `[]` (誰でも可)

発行のIDは88です。

Aliceは**4**個のTokenAだけ購入できるようにしたいと考えています。まず、プロポーショナルな分のプレミアムを支払うために、TokenCのコントラクトで`approve(address spender, uint256 amount)`を呼び出し、パラメータとしてコントラクトのアドレス(`spender`)と`amount`: **4\*10^(TokenAの小数点以下の桁数) \* 10\*10^(TokenCの小数点以下の桁数) / 8\*10^(TokenAの小数点以下の桁数)** (amountToBuy \* `premium` / `amount`)を指定します。その後、コントラクトで`buy(88, 4 * 10^(TokenAの小数点以下の桁数))`を実行し、4\*10^(TokenAの小数点以下の桁数)の償還トークンを受け取ります。

一方、Johnは**2**個のTokenAを購入したいと考えています。同じことを行い、**2\*10^(TokenAの小数点以下の桁数)**の償還トークンを受け取ります。

7月15日になり、Aliceはオプションを行使したいと考えています。なぜなら1 TokenAが50 TokenBで取引されているからです! Aliceは、自分のアカウントから**4\*10^(TokenAの小数点以下の桁数) \* 25\*10^(TokenBの小数点以下の桁数) / 10^(TokenAの小数点以下の桁数)** (amountToExercise \* `strike` / 10^(`TokenA`の小数点以下の桁数))のTokenBをコントラクトに転送することを許可する必要があります。`exercise(88, 4 * 10^(TokenAの小数点以下の桁数))`をコントラクトに呼び出すと、4 TokenAがAliceに、4\*25 TokenBがBobに転送されます。

Johnは自分のオプション行使権利をその友人Jimmyに譲渡することにしました。これは単に**2\*10^(TokenAの小数点以下の桁数)**の償還トークンをJimmyのアドレスに転送するだけで行うことができます。
Jimmyは1個のTokenAだけ購入することにしました。したがって、Bobに(コントラクトを通じて)**1\*10^(TokenAの小数点以下の桁数) \* 25\*10^(TokenBの小数点以下の桁数) / 10^(TokenAの小数点以下の桁数)**を支払います。

#### プットオプション

Bob がプット**オプションを売ると仮定しましょう。**
彼は2023年7月14日から2023年7月16日(深夜)の間に誰にでも**TokenA**を**TokenB**で**25**ずつ**8個**売る権利を与えます。
そのようなコントラクトに対して、彼は**TokenC**で**10**のプレミアムを受け取りたいと考えています。

オプションを作成する前に、Bobは担保をコントラクトに転送する必要があります。この担保は、オプションが完全に行使された場合に彼が渡さなければならない金額(`exerciseCost`)に相当します。このオプションの場合、彼は200 TokenB(8 \* 25)を担保として提供する必要があります。これを行うには、TokenBのコントラクトで`approve(address spender, uint256 amount)`を呼び出し、パラメータとしてコントラクトのアドレス(`spender`)と`amount`: **25\*10^(TokenBの小数点以下の桁数) \* 8\*10^(TokenB
の小数点以下の桁数) / 10^(TokenAの小数点以下の桁数)** (`strike` \* `amount` / 10^(`underlyingToken`の小数点以下の桁数))を指定します。その後、Bobは以下のパラメータを使って`create()`をコントラクトで実行してオプションを発行できます:

- `side`: **Put**
- `underlyingToken`: **TokenAのアドレス**
- `amount`: **8 \* 10^(TokenAの小数点以下の桁数)**
- `strikeToken`: **TokenBのアドレス**
- `strike`: **25 \* 10^(TokenBの小数点以下の桁数)**
- `premiumToken`: **TokenCのアドレス**
- `premium`: **10 \* 10^(TokenCの小数点以下の桁数)**
- `exerciseWindowStart`: **1689292800** *(2023-07-14のタイムスタンプ)*
- `exerciseWindowEnd`: **1689465600** *(2023-07-16のタイムスタンプ)*
- `allowed`: `[]` (誰でも可)

発行のIDは88です。

Aliceは**4**個のTokenAを売りたいと考えています。まず、プロポーショナルな分のプレミアムを支払うために、TokenCのコントラクトで`approve(address spender, uint256 amount)`を呼び出し、パラメータとしてコントラクトのアドレス(`spender`)と`amount`: **4\*10^(TokenAの小数点以下の桁数) \* 10\*10^(TokenCの小数点以下の桁数) / 8\*10^(TokenAの小数点以下の桁数)** (amountToSell \* `premium` / `amount`)を指定します。その後、コントラクトで`buy(88, 4 * 10^(TokenAの小数点以下の桁数))`を実行し、4\*10^(TokenAの小数点以下の桁数)の償還トークンを受け取ります。

一方、Johnは**2**個のTokenAを売りたいと考えています。同じことを行い、**2\*10^(TokenAの小数点以下の桁数)**の償還トークンを受け取ります。

7月15日になり、Aliceはオプションを行使したいと考えています。なぜなら1 TokenAが10 TokenBでしか取引されていないからです! Aliceは、自分のアカウントから**4 \* 10^(TokenAの小数点以下の桁数)**のTokenAをコントラクトに転送することを許可する必要があります。`exercise(88, 4 * 10^(TokenAの小数点以下の桁数))`をコントラクトに呼び出すと、4\*25 TokenBがAliceに、4 TokenAがBobに転送されます。

Johnは自分のオプション行使権利をその友人Jimmyに譲渡することにしました。これは単に**2\*10^(TokenAの小数点以下の桁数)**の償還トークンをJimmyのアドレスに転送するだけで行うことができます。
Jimmyは1個のTokenAだけ売却することにしました。したがって、Bobに(コントラクトを通じて)**1\*10^(TokenAの小数点以下の桁数)**を渡します。

#### 担保の取り戻し

Aliceがオプションを行使しなかったとしましょう。それは十分に有利ではなかったためです。担保を取り戻すには、Bobは`exerciseWindowEnd`よりも現在時間が大きくなるまで待つ必要があります。例では特性が2日に設定されているため、7月16日以降に単に`retrieveExpiredTokens()`を呼び出すことで担保を取り戻すことができます。

## 根拠

このコントラクトの概念はオラクルフリーです。なぜなら、合理的なバイヤーは自分にとって有利な場合にのみオプションを行使すると想定しているためです。

プレミアムは発行者が決定するものです。発行者は、*Black-Scholes model*や他の何かを使ってプレミアムを計算する自由があります。発行者は、基礎資産の価格、変動性、オプション満期までの時間などの変化に合わせてプレミアム価格を随時更新することができます。オフチェーンでプレミアムを計算することは、ガスコストの観点から良いです。

このERCは、バニラオプションを表すことを目的としています。ただし、エキゾチックオプションをこのERCの上に構築することができます。
満期日後に使用できなくなる単一のオプションを表すのではなく、このコントラクトは必要な発行を保存できます。各発行はIDで識別され、他の発行とは独立して購入、行使、キャンセルなどができます。これはガスコストの観点から良いアプローチです。

`exerciseWindowStart`と`exerciseWindowEnd`のデータポイントの導入により、オプションをヨーロピアンまたはアメリカンのいずれかにデザインできるようになっています。バイヤーは`exerciseWindowStart`と`exerciseWindowEnd`の間にのみ行使できます。

- 発行者がオプションをヨーロピアンと見なす場合、`exerciseWindowStart`を満期日と一致させ、`exerciseWindowEnd`を満期日+一定の時間範囲に設定できます。
- 発行者がオプションをアメリカンと見なす場合、`exerciseWindowStart`を現在時間に設定し、バイヤーはすぐにオプションを行使できるようになります。

このコントラクトは、単一のオプション発行に対して複数のバイヤーをサポートしています。これはERC-1155トークンを使ってオプションを表すことで実現されています。バイヤーが発行の一部分を購入する場合、発行の一部分を表すERC-1155トークンを受け取ります。これらのトークンはユーザー間で交換でき、オプションの行使に使用されます。このメカニズムにより、バイヤーは購入したものの一部分のみを行使することを決めることができます。

このコントラクトは`allowed`配列を実装しており、オプション発行を購入できるアドレスを制限することができます。これは、2人のユーザーがオフチェーンでオプションに合意し、それをオンチェーンで作成したい場合に便利です。これにより、発行の作成とセカンドユーザーによる購入の間に、オンチェーンのユーザーがすでに契約を購入してしまうリスクを防ぐことができます。

このERCはERC-20トークンを処理するように設計されています。ただし、このスタンダードは[ERC-721](./eip-721.md)トークンなどの他のタイプのトークンを処理するための良い基礎としても使用できます。一部の属性や関数シグネチャ(amountではなくidを提供するなど)を変更する必要がありますが、一般的なアイデアは同じままです。

## セキュリティ上の考慮事項

コントラクトには`exerciseWindowStart`と`exerciseWindowEnd`のデータポイントが含まれています。これらは、バイヤーがオプションを行使できる期間を定義します。現在の時間が`exerciseWindowEnd`を超えると、バイヤーは行使できず、発行者は残りの担保を取り戻すことができます。

発行者がヨーロピアンオプションと見なす発行の明白な裁定の場合を防ぐために、発行者に`exerciseWindowStart`が開始されたときに、プレミアム価格を大幅に引き上げるよう強くアドバイスします。これにより、ボットがまだ残っているオプションを購入して即座に行使することができなくなります。もちろん、このスタンダードはカスタマイズ可能であり、ユーザーは特に*Black-Scholes model*のような特定の動的メトリックに基づいてプレミアムを自動的に更新するツールを使うことが便利かもしれません。オプション発行がアメリカンと見なされる場合、そのような調整は必要ありません。

このスタンダードは`updatePremium`関数を実装しており、発行者がいつでもプレミアム価格を更新できるようになっています。この関数はバイヤーのセキュリティ上の問題につながる可能性があります。バイヤーがオプションを購入し、発行者がバイヤーのトランザクションをフロントランニングして非常に高い価格にプレミアムを更新する可能性があります。これを防ぐために、バイヤーは合意された金額のプレミアムのみをコントラクトで使用することを許可することをお勧めします。

このコントラクトは単一のオプション発行に対して複数のバイヤーをサポートしており、オプション発行の一部分を購入できます。エコシステムは整数をうまくサポートしていないため、分数は時に丸めエラーを引き起こす可能性があります。これは特に`buy`関数で予期せぬ結果につながる可能性があります。プレミアムが設定されている場合、バイヤーは購入したいオプションの量に比例したプレミアムのみを支払う必要があります。その分数が整数でない場合、これは切り捨てられ、したがって床に丸められます。これは、発行者が予想よりも少ないプレミアムを受け取ることを意味します。トークンの小数点以下の桁数が多いため、この危険性はかなり軽微であると考えていますが、認識しておく必要があります。一部のバイヤーは小さな分数を繰り返し購入することで、予想よりも少ないプレミアムを支払うことを利用する可能性があります。ただし、ガスコストを考えると、これはおそらく収益性のある戦略ではないでしょう。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。