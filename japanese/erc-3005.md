---
original: 60b31e9cb39e534d295376ee012bfdbfd41b5b793c47de4e097f9ae04eb00e3e
---

---
eip: 3005
title: バッチメタトランザクション
author: Matt (@defifuture)
discussions-to: https://ethereum-magicians.org/t/eip-3005-the-economic-viability-of-batched-meta-transactions/4673
status: 停滞
type: Standards Track
category: ERC
created: 2020-09-25
---

## 簡単な要約

ERC-20（およびその他の代替可能トークン規格）の拡張関数を定義し、メタトランザクションのバッチ処理を可能にします。

## 概要

このEIPでは、任意の代替可能トークン規格に拡張する新しい関数「processMetaBatch()」を定義しています。これにより、複数のメタトランザクションを1つのオンチェーントランザクションでバッチ処理できます。

この関数は、メタトランザクションデータを受け取り、検証してから、トークン転送を行う必要があります。

この関数により、ガスレスのトランザクションを可能にし、バッチ処理によってリレーヤーのガスコストを削減できます。

## 動機

メタトランザクションは、イーサリアムアカウントにイーサがなくてもERC-20トークンを転送できるソリューションとして有用であることが証明されています。

現在のメタトランザクションリレーの実装では、1つのメタトランザクションしか中継できません。一部のリレーでは、同じ送信者からのバッチメタトランザクションも許可されていますが、**複数の**送信者からのバッチメタトランザクションは提供されていません。

このEIPの動機は、**1つのオンチェーントランザクション**で**複数の送信者**からのバッチメタトランザクションを中継する方法を見つけ、リレーヤーが負担する**総ガスコストを削減**することです。

![](../assets/eip-3005/meta-txs-directly-to-token-smart-contract.png)

## 仕様

このドキュメントの「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されます。

このドキュメントの「MUST (BUT WE KNOW YOU WON'T)」、「SHOULD CONSIDER」、「REALLY SHOULD NOT」、「OUGHT TO」、「WOULD PROBABLY」、「MAY WISH TO」、「COULD」、「POSSIBLE」、「MIGHT」というキーワードは、RFC 6919に記載されているように解釈されます。

### メタトランザクションデータ

`processMetaBatch()`関数が正常にトークンを検証および転送するには、以下のメタトランザクションデータを処理する必要があります:

- 送信者アドレス
- 受信者アドレス
- トークン量
- リレーヤー手数料
- (メタトランザクションの)ノンス
- 有効期限(ブロック番号またはブロックタイムスタンプ)
- トークンアドレス
- リレーヤーアドレス
- 署名

これらのデータのすべてをリレーヤーが関数に送る必要はありません(関数インターフェイスの仕様を参照)。一部のデータは他のソース(トランザクションデータやコントラクトの状態)から推測または抽出できます。

### `processMetaBatch()`関数の入力データ

`processMetaBatch()`関数は以下のデータを受け取る必要があります:

- 送信者アドレス
- 受信者アドレス
- トークン量
- リレーヤー手数料
- 有効期限(ブロック番号またはブロックタイムスタンプ)
- 署名

以下のデータは、他のソースから抽出または派生できるため、関数に送る必要はありません:

- (メタトランザクションの)ノンス
- トークンアドレス
- リレーヤーアドレス

### メタトランザクションデータのハッシュ

メタトランザクションデータのハッシュを作成するための擬似コードは以下の通りです:

```
keccak256(address(sender)
	   ++ address(recipient)
	   ++ uint256(amount)
	   ++ uint256(relayerFee)
	   ++ uint256(nonce)
	   ++ uint256(expirationDate)
	   ++ address(tokenContract)
	   ++ address(relayer)
)
```

作成されたハッシュは、送信者の秘密鍵で署名される必要があります。

### 検証ルール

- 新しいトランザクションのノンスは、同じ送信者から同じトークンコントラクトに対して最後に正常に処理されたメタトランザクションのノンスより正確に1大きくなければなりません。
- 0x0アドレスへの送信は禁止されます。
- メタトランザクションは有効期限前に処理される必要があります。
- 各送信者のトークン残高は、それぞれのメタトランザクションのトークン量とリレーヤー手数料の合計以上でなければなりません。
- バッチ内の少なくとも1つのメタトランザクションが上記の要件を満たさない場合、トランザクション全体は取り消されるのではなく、失敗したメタトランザクションはスキップまたは無視されます。

### `processMetaBatch()`関数のインターフェイス

`processMetaBatch()`関数は以下のインターフェイスを持つ必要があります:

```solidity
function processMetaBatch(address[] memory senders,
                          address[] memory recipients,
                          uint256[] memory amounts,
                          uint256[] memory relayerFees,
                          uint256[] memory blocks,
                          uint8[] memory sigV,
                          bytes32[] memory sigR,
                          bytes32[] memory sigS) public returns (bool);
```

渡されるパラメータの概要は以下の通りです:

- `senders`: メタトランザクションの送信者アドレスの配列(トークンの送信者)
- `recipients`: トークンの受信者アドレスの配列
- `amounts`: それぞれの送信者から各受信者に送信されるトークン量の配列
- `relayerFees`: リレーヤー(`msg.address`)に支払われるトークンのリレーヤー手数料の配列
- `blocks`: メタトランザクションを処理する必要があるブロック番号の配列(または代わりにタイムスタンプを使用できる)
- `sigV`、`sigR`、`sigS`: メタトランザクション署名の3つの部分を表す配列

各配列の各エントリは、1つのメタトランザクションからのデータを表します。データの順序は非常に重要です。単一のメタトランザクションのデータは、すべての配列で同じインデックスを持つ必要があります。

### メタトランザクションのノンス

トークンスマートコントラクトは、各トークンホルダーのメタトランザクションノンスを追跡する必要があります。

```solidity
mapping (address => uint256) private _metaNonces;
```

`nonceOf()`関数のインターフェイスは以下の通りです:

```solidity
function nonceOf(address account) public view returns (uint256);
```

### トークン転送

メタトランザクションが正常に検証された後、メタトランザクション送信者のメタノンスを1増やす必要があります。

次に2つのトークン転送が行われる必要があります:

- 指定されたトークン量が受信者に送金される。
- リレーヤー手数料がリレーヤー(`msg.sender`)に送金される。

## 実装

**参照実装**では、既存のERC-20トークン規格に2つの関数が追加されています:

- `processMetaBatch()`
- `nonceOf()`

両関数の実装は、[ERC20MetaBatch.sol](https://github.com/defifuture/erc20-batched-meta-transactions/blob/master/contracts/ERC20MetaBatch.sol)ファイルで確認できます。これは、バッチメタトランザクション転送機能を追加したERC-20コントラクトの拡張版です。

### `processMetaBatch()`

`processMetaBatch()`関数は、トークン残高を変更するバッチメタトランザクションを受け取り、処理する責任があります。

```solidity
function processMetaBatch(address[] memory senders,
                          address[] memory recipients,
                          uint256[] memory amounts,
                          uint256[] memory relayerFees,
                          uint256[] memory blocks,
                          uint8[] memory sigV,
                          bytes32[] memory sigR,
                          bytes32[] memory sigS) public returns (bool) {
    
    address sender;
    uint256 newNonce;
    uint256 relayerFeesSum = 0;
    bytes32 msgHash;
    uint256 i;

    // すべてのメタトランザクションをループ
    for (i = 0; i < senders.length; i++) {
        sender = senders[i];
        newNonce = _metaNonces[sender] + 1;

        if(sender == address(0) || recipients[i] == address(0)) {
            continue; // 送信者または受信者が0x0アドレスの場合、このメタトランザクションをスキップ
        }

        // メタトランザクションは指定されたブロック番号以前に処理される必要があり、それ以降は無効
        if(block.number > blocks[i]) {
            continue; // 現在のブロック番号が要求された番号より大きい場合、このメタトランザクションをスキップ
        }

        // メタトランザクション送信者の残高が十分かどうかチェック
        if(_balances[sender] < (amounts[i] + relayerFees[i])) {
            continue; // 送信者の残高がトークン量とリレーヤー手数料の合計より少ない場合、このメタトランザクションをスキップ
        }

        // 署名の検証
        msgHash = keccak256(abi.encode(sender, recipients[i], amounts[i], relayerFees[i], newNonce, blocks[i], address(this), msg.sender));
        if(sender != ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", msgHash)), sigV[i], sigR[i], sigS[i])) {
            continue; // 署名が無効な場合、次のメタトランザクションに進む
        }

        // 送信者の新しいノンスを設定
        _metaNonces[sender] = newNonce;

        // トークン転送
        _balances[sender] -= (amounts[i] + relayerFees[i]);
        _balances[recipients[i]] += amounts[i];
        relayerFeesSum += relayerFees[i];
    }

	// リレーヤーにすべてのリレーヤー手数料を付与
    _balances[msg.sender] += relayerFeesSum;

    return true;
}
```

### `nonceOf()`

ノンスは、リプレイ攻撃の防止に必要です(「セキュリティ上の考慮事項」の「リプレイ攻撃」を参照)。

```solidity
mapping (address => uint256) private _metaNonces;

// ...

function nonceOf(address account) public view returns (uint256) {
    return _metaNonces[account];
}
```

完全な実装(ガス使用量の結果も含む)へのリンクは以下の通りです: [https://github.com/defifuture/erc20-batched-meta-transactions](https://github.com/defifuture/erc20-batched-meta-transactions)。

> OpenZeppelinのERC-20実装を使用しています。他の実装では`_balances`マッピングの名称が異なる可能性があり、`processMetaBatch()`関数に軽微な変更が必要になる可能性があります。

## 根拠

### オールインワン

GSNのようなオルタナティブな実装では、メタトランザクションを有効にするために複数のスマートコントラクトを使用しますが、これはガス使用量を増加させます。このEIP-3005の実装は、1つの関数内にすべてを保持することで、複雑さとガスコストを削減しています。

`processMetaBatch()`関数は、バッチメタトランザクションの受信、検証、トークン転送を行う役割を果たします。

### 関数パラメータ

参照実装の`processMetaBatch()`関数には以下のパラメータがあることがわかります:

- **送信者アドレス**の配列(メタトランザクションの送信者、リレーヤーではない)
- **受信者アドレス**の配列
- **金額**の配列
- **リレーヤー手数料**の配列(リレーヤーは`msg.sender`)
- **ブロック番号**の配列(メタトランザクションを処理する期限)
- 署名の3つの部分を表す配列(v、r、s)

これらの配列の**各項目**は、**1つのメタトランザクションのデータ**を表しています。そのため、配列の**正しい順序**が非常に重要です。

リレーヤーが順序を間違えると、`processMetaBatch()`関数は(署名の検証時に)それに気づきます。なぜなら、メタトランザクションの値のハッシュが署名されたハッシュと一致しないためです。無効な署名のメタトランザクションは**スキップ**されます。

### メタトランザクションデ
### 別のメタトランザクションデータの関数への渡し方

参照実装では、パラメータを配列として受け取ります。他のソースから推測または抽出できないデータごとに別の配列があります。

別のアプローチとしては、1つのメタトランザクションのすべてのデータをビットパックして1つの値にし、その後スマートコントラクト内で解凍する方法があります。バッチメタトランザクションのデータは配列で送信されますが、パックされたデータの配列は1つだけでよくなります。

### なぜノンスがパラメータに含まれていないのか

メタノンスは、署名されたハッシュの構築に使用されます(ノンスが`msgHash`行のkeccak256ハッシュに含まれています)。

新しいノンスは常に前のものより正確に1大きくなければならないため、`processMetaBatch()`関数のパラメータ配列に含める必要はありません。その値は推測できるためです。

これにより、「スタックが深すぎる」エラーを回避することもできます。

### EIP-2612のノンスマッピングを再利用できるか

EIP-2612(`permit()`関数)にもノンスマッピングが必要です。現時点では、スマートコントラクトがEIP-3005とEIP-2612の両方を実装する場合に、このマッピングを**再利用**できるかどうかは確実ではありません。

一見すると、EIP-2612の`nonces`マッピングを再利用できそうですが、セキュリティへの影響を慎重に検討(およびテスト)する必要があります。

### トークン転送

参照実装のトークン転送は、代替案として`_transfer()`関数(OpenZeppelinのERC-20実装の一部)を呼び出すこともできますが、ガス使用量が増加し、一部のメタトランザクションが無効な場合にバッチ全体が取り消されてしまいます(現在の実装では単にスキップされます)。

ガス使用量の最適化として、ループ内の各トークン転送の後ではなく、関数の最後にリレーヤー手数料の合計をリレーヤーに割り当てる(したがって、コストの高い複数のSSTOREコールを避ける)ことができます。

## 下位互換性

バッチメタトランザクションのコード実装は、ERC-20(など)の任意の代替可能トークン規格と下位互換性があります(1つの関数を拡張するだけです)。

## テストケース

テストへのリンク: [https://github.com/defifuture/erc20-batched-meta-transactions/tree/master/test](https://github.com/defifuture/erc20-batched-meta-transactions/tree/master/test)

## セキュリティ上の考慮事項

ここでは、潜在的なセキュリティ問題とその対策について説明します。

### メタトランザクションの偽造

ユーザーが秘密鍵で署名することで、リレーヤーがメタトランザクションを偽造するのを防ぐことができます。

`processMetaBatch()`関数は、`ecrecover()`を使って署名を検証します。

### リプレイ攻撃

`processMetaBatch()`関数は、2種類のリプレイ攻撃に対して安全です:

**同じトークンスマートコントラクト内で同じメタトランザクションを2回使用する**

ノンスが、同じメタトランザクションを複数回送信するリプレイ攻撃を防ぎます。

**異なるトークンスマートコントラクト間で同じメタトランザクションを2回使用する**

トークンスマートコントラクトのアドレスをメタトランザクションの署名ハッシュに含める必要があります。

このアドレスを`processMetaBatch()`関数のパラメータとして送る必要はありません。代わりに、関数は署名の検証時に`address(this)`を使用します。これにより、トークンスマートコントラクトに意図されていないメタトランザクションは拒否(スキップ)されます。

### 署名の検証

メタトランザクションの署名と署名の検証は、このスキームが機能するために不可欠です。

`processMetaBatch()`関数は、メタトランザクションの署名を検証し、**無効**な場合は**スキップ**します(ただし、オンチェーントランザクション全体は**取り消されません**)。

```solidity
msgHash = keccak256(abi.encode(sender, recipients[i], amounts[i], relayerFees[i], newNonce, blocks[i], address(this), msg.sender));

if(sender != ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", msgHash)), sigV[i], sigR[i], sigS[i])) {
    continue; // 署名が無効な場合、次のメタトランザクションに進む
}
```

なぜ全体のオンチェーントランザクションを取り消さないのか? 1つの問題のあるメタトランザクションだけで、他のメタトランザクションを破棄してはいけないからです。

ただし、リレーヤーは事前にメタトランザクションを検証することが期待されています。そのため、無効なメタトランザクションにはリレーヤー手数料は支払われません。

### 悪意のあるリレーヤーがユーザーに過剰支出を強制する

悪意のあるリレーヤーが、ユーザーがオンチェーントランザクションを行うまでユーザーのメタトランザクションの送信を遅延させる可能性があります。

その後、遅延されたメタトランザクションを中継すると、ユーザーが2つのトークントランザクションを行ったことになり(過剰支出)。

**解決策:** 各メタトランザクションには「有効期限」が必要です。これは、メタトランザクションをオンチェーンで中継する必要があるブロック番号の形式で定義されます。

```solidity
function processMetaBatch(...
                          uint256[] memory blocks,
                          ...) public returns (bool) {
    
    //...

	// すべてのメタトランザクションをループ
    for (i = 0; i < senders.length; i++) {

        // メタトランザクションは指定されたブロック番号以前に処理される必要があり、それ以降は無効
        if(block.number > blocks[i]) {
            continue; // 現在のブロック番号が要求された番号より大きい場合、このメタトランザクションをスキップ
        }

        //...
```

### フロントランニング攻撃

悪意のあるリレーヤーがイーサリアムメンプールをスカウトして、メタトランザクションを盗み、元のリレーヤーをフロントランニングする可能性があります。

**解決策:** `processMetaBatch()`関数が使用する保護は、メタトランザクション送信者にリレーヤーのイーサリアムアドレスをハッシュの1つの値として追加することです。

`processMetaBatch()`関数がハッシュを生成する際、`msg.sender`アドレスを含めます:

```solidity
msgHash = keccak256(abi.encode(sender, recipients[i], amounts[i], relayerFees[i], newNonce, blocks[i], address(this), msg.sender));

if(sender != ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", msgHash)), sigV[i], sigR[i], sigS[i])) {
    continue; // 署名が無効な場合、次のメタトランザクションに進む
}
```

メタトランザクションが「盗まれた」場合、`msg.sender`アドレスが意図したリレーヤーのアドレスと同じではないため、署名チェックが失敗します。

### 悪意のある(または焦りすぎている)ユーザーが複数のリレーヤーに同じノンスのメタトランザクションを送信する

ユーザーが悪意があるか、単に焦りすぎている場合、同じノンス(同じトークンコントラクト用)のメタトランザクションを複数のリレーヤーに送信する可能性があります。最初にオンチェーンに到着したリレーヤーだけがリレーヤー手数料を受け取り、他のリレーヤーは無効なメタトランザクションを受け取ることになります。

**解決策:** リレーヤーは、それぞれの**保留中のメタトランザクションのリストを共有**できます(メンプールのようなもの)。

リレーヤーは、自分の保留中のトランザクションが盗まれる心配はありません。なぜなら、フロントランニング保護があるためです(上記参照)。

リレーヤーが、ある送信者アドレスからのメタトランザクションで、同じノンスと同じトークンスマートコントラクトに送信されるものを見つけた場合、最初に登録されたメタトランザクションだけが処理され、他のものは破棄されるようにできます(または、メタトランザクションが同時に登録された場合は、残りのメタトランザクションをランダムに選択できます)。

最小限、リレーヤーは以下のメタトランザクションデータを共有する必要があります(メタトランザクションの競合を検出するため):

- 送信者アドレス
- トークンアドレス
- ノンス

### 大きすぎるブロック番号

リレーヤーが、メタトランザクション送信者に大きすぎるブロック番号(メタトランザクションを処理する必要があるブロック)を追加するよう誘導する可能性があります。たとえば、10年先のブロック番号などです。これは、リレーヤーが10年間メタトランザクションを送信できることを意味します。

この問題を解決する1つの方法は、スマートコントラクト内で上限制約を追加することです。たとえば、指定された有効期限ブロック番号が現在のブロック番号から100,000ブロック(約17日)以内でなければならないと定めることができます。

```solidity
// メタトランザクションは指定されたブロック番号以前に処理される必要があり、それ以降は無効
if(block.number > blocks[i] || blocks[i] > (block.number + 100000)) {
    // 現在のブロック番号が要求された有効期限ブロック番号より大きい場合、またはその番号が将来の100,000ブロックより大きい場合、このメタトランザクションをスキップ
    continue;
}
```

この追加は新しいセキュリティ上の影響を引き起こす可能性があるため、このプルーフオブコンセプトからは除外されています。ただし、実装する際はこの潜在的な制約についても知っておく必要があります。

**別の方法**は、`processMetaBatch()`関数をそのままにしておき、代わりに大きすぎるブロック番号を**リレーヤーレベル**で確認することです。この場合、ユーザーに問題を通知し、別のリレーヤーに新しいメタトランザクションを発行してもらう(同じノンスを使用)ことができます。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)によって放棄されています。