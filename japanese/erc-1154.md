---
original: 489ead0408e519863e4f74fcbeff87158a71fba577cdc1484283ae9e7a7f8cf8
---

---
eip: 1154
title: オラクルインターフェース
author: Alan Lu (@cag)
discussions-to: https://github.com/ethereum/EIPs/issues/1161
status: 取り下げられた
type: Standards Track
category: ERC
created: 2018-06-13
---

## 簡単な要約
オラクルのための標準インターフェース。

## 概要
Ethereumスマートコントラクトがオフチェーンシステムと対話するためには、オラクルを使用する必要があります。これらのオラクルは通常オフチェーンにある値を報告し、スマートコントラクトがオフチェーンシステムの状態に反応できるようにします。プッシュベースとプルベースのオラクルシステムの区別と選択が行われます。さらに、ここでは異なるオラクル実装を交換可能にする、オラクルの標準インターフェースが説明されています。

## 動機
Ethereumエコシステムには現在多くの異なるオラクル実装が利用可能ですが、統一されたインターフェースを提供していません。スマートコントラクトシステムは単一のオラクル実装セットにロックされるか、開発者がプロジェクトで選択したオラクルシステムに特化したアダプターやポートを書く必要があります。

命名の違いに加えて、オラクルレポートの解決トランザクションが影響を受けるコントラクトに _プッシュ_ 状態変更を行うか、オラクルの状態を変更してそれに依存するコントラクトが更新された値を _プル_ できるようにするかという問題もあります。これらの異なるシステムセマンティクスは、それらの間を適応する際に非効率を引き起こす可能性があります。

結局のところ、さまざまなオラクルシステムの価値は、その基礎となる解決メカニズムにあり、これらのシステムが事実上同一である部分は標準化されるべきです。

これらのオラクルは「現実世界のイベント」に関する質問に答えるために使用される可能性があり、各IDは質問とその答えの仕様に関連付けられます(つまり、おそらく予測市場用です)。

別の使用例は意思決定プロセスのためで、オラクルによって提供される結果は意思決定プロセスで下された決定を表します(例えば、futarchies)。DAOはこれらの意思決定プロセスで使用を要求する可能性があります。

IDと結果は意図的に構造化されていないため、時系列データ(IDを分割することで)や、結果の異なるタイプ(いくつかの選択肢の1つ、最大256個の部分集合、または最大256ビットの精度の範囲内の値など)を表現できます。

## 仕様

<dl>
  <dt>オラクル</dt>
  <dd>ブロックチェーンにデータを報告するエンティティ。</dd>

  <dt>オラクルコンシューマ</dt>
  <dd>オラクルからデータを受け取るスマートコントラクト。</dd>

  <dt>ID</dt>
  <dd>オラクルが報告するデータのインデックス化方法。質問に対する答えを表すために関連付けられる可能性があります。</dd>

  <dt>結果</dt>
  <dd>IDに関連付けられ、オラクルによって報告されるデータ。これらのデータは通常、IDに関連付けられた質問の答えになります。他の同等の用語には、answer、data、outcomeなどがあります。</dd>

  <dt>レポート</dt>
  <dd>オラクルがオラクルコンシューマに送信する(ID、結果)のペア。</dd>
</dl>

```solidity
interface OracleConsumer {
    function receiveResult(bytes32 id, bytes result) external;
}
```

`receiveResult`は、`msg.sender`が`result`を提供する権限を持つオラクルではない場合、リバートしなければなりません(`MUST revert`)。

`receiveResult`は、同じ`id`で前に呼び出されていた場合、リバートしなければなりません(`MUST revert`)。

`receiveResult`は、`id`または`result`をコンシューマが処理できない場合、リバートしてもかまいません(`MAY revert`)。

コンシューマは、オラクルと協調して、`bytes`への/からの結果のエンコーディング/デコーディング方法を決める必要があります。たとえば、Solidityでは`abi.encode`と`abi.decode`を使ってコーデックを実装できます。オラクルからコンシューマが予期しない結果形式を受け取った場合、`receiveResult`はリバートすべきです(`SHOULD revert`)。

オラクルは任意のEthereum アカウントになることができます。

## 根拠
仕様は現在、ChainLink(任意の名前付きコールバックを使用可能)とOraclize(``__callback``を使用)で実装されているものとよく似ています。

この仕様では、オラクルがコンシューマに _プッシュ_ 状態を行い、コンシューマはそれに応じて反応する必要があります。代替の _プル_ ベースのインターフェースを規定することもできます。

### 代替のプルベースのインターフェース
Gnosis予測市場コントラクトv1に緩く基づいた代替の仕様は以下の通りです。Reality Checkも同様のエンドポイント(`getFinalAnswer`)を公開しています。

```solidity
interface Oracle {
    function resultFor(bytes32 id) external view returns (bytes result);
}
```

`resultFor`は、`id`の結果が利用可能でない場合、リバートしなければなりません(`MUST revert`)。

`resultFor`は、`id`の結果が利用可能になった後、同じ結果を返さなければなりません(`MUST return`)。

### プッシュvsプル
プッシュベースのインターフェースをプルベースのインターフェースに適応させることができます。単にレシーブした結果を保存し、`resultFor`を適切に実装するオラクルコンシューマをデプロイするだけです。

同様に、すべてのプルベースのシステムをプッシュベースのシステムに適応させることもできます。オラクルスマートコントラクトにオラクルコンシューマアドレスを受け取り、そのアドレスの`receiveResult`を呼び出すメソッドを追加するだけです。

どちらの場合も、追加のトランザクションを実行する必要があるため、プッシュかプルかの選択は、これらのオラクルの主要な使用例に基づいて行う必要があります。

単一のアカウントがオラクルの質問の結果を決める権限を持つ単純な場合では、オラクルコントラクトをデプロイし、その結果をそのコントラクトに保存する必要はありません。同様に、結果が投票によって決まる場合は、既存の多重署名ウォレットをオラクルとして使用できます。

#### 複数のオラクルコンシューマ
単一のオラクル結果に依存する多数のオラクルコンシューマがあり、これらすべてのコンシューマがその結果をプッシュされることを期待する場合、信頼できないプッシュオラクルがすべてのコンシューマに同じ結果を送信できないため(ある意味、この信頼はオラクルアダプター実装に転送される)、前述のプッシュとプルの適応を組み合わせることができます。

プルベースのシステムでは、各コンシューマがオラクルコントラクトから結果をプルする必要がありますが、提案されたプッシュベースのシステムでは、適応されたオラクルを呼び出して結果をそれぞれのコンシューマにプッシュする必要があります。

トランザクション面では、このシナリオでは両方のシステムがおおよそ同等の効率性ですが、プッシュベースのシステムでは、コンシューマが結果を再度保存する必要があるのに対し、プルベースのシステムでは、コンシューマがオラクルから結果を参照し続けることができます。これはやや非効率かもしれませんが、コンシューマに結果の不変性に関する保証を提供することもできます。

#### 結果の不変性
提案された仕様と代替仕様の両方で、結果は一度決定されると不変になります。これは、一貫した結果状態を決定するためには、一般的にコンシューマが結果の不変性を要求すると期待されるためです。提案されたプッシュベースのシステムでは、コンシューマが結果の不変性要件を強制しますが、代替のプルベースのシステムでは、オラクルが仕様を正しく実装し、不変性要件を強制するか、コンシューマが結果の不変性も処理する必要があります。

時間とともに変化するデータの場合、`id`フィールドを「何」と「いつ」を指定するように構造化できます(「いつ」を指定するために128ビットを使用しても、数千年間は安全です)。

## 実装

* [Tidbit](https://github.com/levelkdev/tidbit)がこのEIPを追跡しています。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。