---
original: 954471595e5e2a9ea6a052b5a7463302057d276ecdafb60c6b0e7c76a3b5c385
---

---
eip: 5902
title: スマートコントラクトイベントフック
description: 他のコントラクトから発行されたイベントに半自動的に応答できるようにするフォーマット
author: Simon Brown (@orbmis)
discussions-to: https://ethereum-magicians.org/t/idea-smart-contract-event-hooks-standard/11503
status: 停滞
type: Standards Track
category: ERC
created: 2022-11-09
requires: 712
---

## 概要

このEIPは、パブリックリレーヤーネットワークをメッセージバスとして使用して、他のコントラクトによってトリガーされたイベントに自動的に応答するために呼び出されるスマートコントラクト関数を作成するための標準を提案しています。

既に多くの類似のソリューションが存在していますが、このプロポーザルは、多くのアプリケーションで公開、許可なし、分散型の方法で使用できる単純ながら強力なプリミティブを説明しています。

これは、パブリッシャーコントラクトとサブスクライバーコントラクトの2つのインターフェイスに依存しています。パブリッシャーコントラクトは、「リレーヤー」と呼ばれる独立したエンティティによって取得されるイベントを発行します。リレーヤーは、パブリッシャーコントラクトのフックイベントにサブスクライブし、パブリッシャーコントラクトがフックイベントを発行するたびに、それぞれのサブスクライバーコントラクトの関数を呼び出します。リレーヤーがパブリッシャーコントラクトから発行されたフックイベントの詳細をサブスクライバーコントラクトに通知するたびに、サブスクライバーから手数料を受け取ります。パブリッシャーとサブスクライバーの両方のコントラクトは、リレーヤーがフックを検出できるように、中央レジストリスマートコントラクトに登録されています。

## 動機

オフチェーンのパーティーがチェーンを監視し、オンチェーンのイベントに応答してトランザクションをブロードキャストする必要がある多くのユースケースがあります。このような場合、通常、スマートコントラクトから発行されたイベントにサブスクライブし、その後ネットワークにトランザクションをブロードキャストするロジックを実行するために、オフチェーンプロセスを実行する必要があります。これには、Ethereumノードとオープンなウェブソケット接続を備えた長期実行プロセスが必要であり、リソースの非効率的な使用につながります。

このプロポーザルにより、オフチェーンプロセスを実行することなく、他のスマートコントラクトからのイベントに応答するロジックをスマートコントラクトに含めることができます。スマートコントラクトは、他のスマートコントラクトによって発行されたイベントにサブスクライブし、必要に応じてロジックを実行するだけです。このアプローチは、オフチェーンの計算を必要としないが、通常はオフチェーンプロセスを必要とするすべてのコントラクトロジックに適しています。このアプローチでは、サブスクライバーは自分の専用のオフチェーンプロセスを持つ必要がありません。代わりに、単一の報酬付きリレーヤーが、複数のサブスクライバーコントラクトに代わってさまざまなイベントにサブスクライブできます。

このスキームから恩恵を受けるユースケースの例は以下の通りです:

### 担保付きレンディングプロトコル

担保付きレンディングプロトコルやステーブルコインは、価格オラクルの更新を受け取るたびにイベントを発行し、借り手が自分のオープンポジションを自動的に「トップアップ」して清算を回避できるようにします。

たとえば、Makerは「メディアナイザー」スマートコントラクトを使用し、価格フィードコントラクトのホワイトリストを維持しています。新しい価格更新が受信されるたびに、すべてのフィード価格のメディアンが再計算され、メディアン化された値が更新されます。この場合、メディアナイザースマートコントラクトがフックイベントを発行し、サブスクライバーコントラクトがCDPを再担保化するかどうかを決定できるようにします。

### 自動化された市場メーカー

AMM流動性プールは、流動性が追加または削除されるたびにフックイベントを発行できます。これにより、サブスクライバースマートコントラクトは、総プール流動性が特定のポイントに達したときに流動性を追加または削除できます。

AMM は、取引ペア内で取引が行われるたびにフックイベントを発行し、時間加重平均価格オラクルの更新をフックイベントを介して提供できます。サブスクライバーは、これを使用して、資産のスポット価格が事前に指定したしきい値を超えたときに自動的に買い付けまたは売却するオートメーションLimitOrderBook型のコントラクトを作成できます。

### DAO投票

フックイベントは、ガバナンスコントラクトによって発行され、提案が公開された、投票された、実行された、または拒否されたことを示すことができます。これにより、サブスクライバーコントラクトは、提案が可決された場合など、適切に応答することができます。たとえば、資金の支払い承認時に、スマートコントラクト関数を実行するなどです。

### 定期的な関数呼び出し

スケジューラーサービスを作成し、サブスクライバーが定期的な関数呼び出しを登録できるようにすることができます。これは、Unixのcron形式を使用して行うことができ、サービスはスマートコントラクトから別のスレッドでイベントを発行できます。サブスクライバーコントラクトは、それぞれのスレッドにサブスクライブして、特定のスケジュール(1日、1週間、1時間など)にサブスクライブできます。カスタムのcronスケジュールを登録することもできます。

### 定期的な支払い

サービスプロバイダーは、定期的にサービス料金を自動的に支払うことができるフックイベントを発行できます。サブスクライバーコントラクトがフックイベントを受信すると、サービスプロバイダーのコントラクトに資金を転送するための関数を呼び出すことができます。

### 委任による調整

フックイベントのペイロードには任意のデータを含めることができます。これにより、Delegatableフレームワークなどを使用して、オフチェーンの委任を署名し、承認された一連のエンティティがフックイベントを公開できるようになります。また、BLSしきい値署名を使用して、複数のオフチェーンパブリッシャーが有効なフックの発行を承認することもできます。

## 仕様

このドキュメントの「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されます。

### パブリッシャーの登録

パブリッシャーとサブスクライバーの両方のコントラクトは、[ERC-1820](./eip-1820.md)コントラクトにインターフェイスを登録するのと同様に、特定のレジストリコントラクトに登録する必要があります。レジストリコントラクトは、ファクトリコントラクトと特定のソルトを使用して決定論的な展開メカニズムを使用する必要があります。

パブリッシャーコントラクトのフックを登録するには、レジストリコントラクトの `registerHook` 関数を呼び出す必要があります。提供する必要のあるパラメーターは以下の通りです:

 - (address) パブリッシャーコントラクトアドレス
 - (uint256) フックイベントが参照するスレッドID(単一のコントラクトは任意の数のスレッドでフックイベントを発行できますが、サブスクライバーは特定のスレッドにサブスクライブできます)
 - (bytes) フックイベントに関連付けられた公開鍵(オプション)

`registerHook` 関数がレジストリコントラクトで呼び出されると、レジストリコントラクトは、パブリッシャーコントラクトアドレスに下流の呼び出しを行い、`verifyEventHookRegistration` 関数を呼び出します。この関数には、レジストリコントラクトの `registerHook` 関数に渡されたのと同じ引数が渡されます。パブリッシャーコントラクトの `verifyEventHookRegistration` 関数は、レジストリに発行者として追加されることを示すために true を返す必要があります。レジストリコントラクトは、新しいパブリッシャーコントラクトが追加されたことを示す `HookRegistered` イベントを発行する必要があります。

### フックの更新

パブリッシャーは、フックイベントの詳細を更新したり、フックイベントのサポートを完全に削除したりする必要がある場合があります。レジストリコントラクトは、既存のパブリッシャーコントラクトをレジストリで更新できるように、`updatePublisher` 関数を実装する必要があります。レジストリコントラクトは、パブリッシャーコントラクトが更新されたことを示す `PublisherUpdated` イベントを発行する必要があります。

### フックの削除

以前に登録されたフックを削除するには、レジストリコントラクトの `removeHook` 関数を呼び出す必要があります。この関数には、`updateHook` 関数と同じパラメーターが必要です。レジストリコントラクトは、`removeHook` 関数に渡されたパラメーターと `msg.sender` 値を使用して、`HookRemoved` イベントを発行する必要があります。

### サブスクライバーの登録

フックにサブスクライバーを登録するには、レジストリコントラクトの `registerSubscriber` 関数を呼び出す必要があります。以下のパラメーターを指定する必要があります:

 - (address) パブリッシャーコントラクトアドレス
 - (bytes32) サブスクライバーコントラクトアドレス
 - (uint256) サブスクライブするスレッドID
 - (uint256) サブスクライバーが更新を受け取るために支払う手数料
 - (uint256) サブスクライバーが許可する最大ガス量(グリーフィング攻撃を防ぐため)、または0を指定して最大値なしを示す
 - (uint256) サブスクライバーが手数料の上乗せとして許可する最大ガス価格、または0を指定して上限なしを示す
 - (uint256) サブスクライバーが更新を受け取りたいチェーンID
 - (address) 手数料の支払いに使用するトークンのアドレス、またはチェーンのネイティブアセット(ETH、MATICなど)の場合は0x0

サブスクライバーコントラクトは、固定手数料に加えてガス代の払い戻しを実装することができます。サブスクライバーがこれを行う場合は、グリーフィング攻撃から自身を保護するために、`maximum gas` および `maximum gas price` パラメーターを指定する必要があります。これは、悪意のあるまたは不注意なリレーヤーが過剰なガス価格を設定し、サブスクライバーコントラクトを枯渇させる可能性があるためです。サブスクライバーコントラクトは、ガス代を十分にカバーできると見積もられる手数料を設定することもできます。

オリジナルのバージョンの仕様には含まれていなかったチェーンIDとトークンアドレスの2つのパラメーターを追加することで、サブスクライバーがクロスチェーンメッセージを活用できるようになり、また、さまざまなトークンでリレーヤー手数料を支払えるようになります。

### サブスクリプションの更新

サブスクリプションを更新するには、`updateSubscriber` 関数を呼び出す必要があります。この関数には、`registerSubscriber` 関数と同じパラメーターセットが必要です。これは、サブスクリプションをキャンセルしたり、サブスクリプション手数料を変更したりするために行う可能性があります。`updateSubscriber` 関数は、`registerSubscriber` 関数が呼び出されたときと同じ `msg.sender` を維持する必要があります。

### サブスクリプションの削除

以前に登録されたサブスクリプションを削除するには、レジストリコントラクトの `removeSubscriber` 関数を
呼び出す必要があります。この関数には、`updateSubscriber` 関数と同じパラメーターが必要ですが、`fee` パラメーターは含まれていません(つまり、パブリッシャーとサブスクライバーのコントラクトアドレスとスレッドIDのみ)。手数料は0に設定され、サブスクライバーがこのサブスクリプションの更新を望まなくなったことを示します。レジストリコントラクトは、パブリッシャーコントラクトアドレス、サブスクライバーコントラクトアドレス、スレッドIDをトピックとして使用して、`SubscriptionRemoved` イベントを発行する必要があります。

### イベントの公開

パブリッシャーコントラクトは、少なくとも1つの関数からフックイベントを発行する必要があります。発行されるイベントは `Hook` と呼ばれ、以下のパラメーターを含む必要があります:

 - uint256 (indexed) - threadId
 - uint256 (indexed) - nonce
 - bytes32 digest
 - bytes payload
 - bytes32 checksum

`nonce` 値は、パブリッシャーコントラクトがフックイベントを発行するたびに増分される必要があります。すべてのフックイベントには一意の `nonce` 値が必要です。`nonce` プロパティは1に初期化されますが、これまでに発行された最初のフックイベントの `nonce` は2に設定する必要があります。これは、初期化されていない `nonce` 変数と明示的に0に初期化された `nonce` 変数との間の曖昧さを防ぐためです。

イベントの `digest` パラメーターは、ペイロードのkeccak256ハッシュでなければならず、`checksum` は、ダイジェストと現在のブロック高さの連結のkeccak256ハッシュでなければなりません。

`Hook` イベントは、任意のEOAまたは外部コントラクトからの関数呼び出しによってトリガーできます。これにより、ペイロードをパブリッシャーコントラクト内で動的に作成できます。サブスクライバーコントラクトは、受信したフックペイロードが有効であることを確認するために、パブリッシャーコントラクトの `verifyEventHook` 関数を呼び出す必要があります。

ペイロードは、パブリッシャーコントラクト自体の内部で生成する代わりに、関数呼び出しに渡すことができますが、署名が提供される場合は、ペイロードのハッシュに署名する必要があり、[EIP-712](./eip-712.md)標準を使用し、このプロポーザルの最後に概説されているデータ構造に従うことを強くお勧めします。この署名は、サブスクライバーが認証されたイベントを受け取っていることを確認するために検証する必要があります。署名は、イベントに登録された公開鍵に対応している必要があります。このアプローチでは、署名をペイロードの先頭に配置する必要があります(ECDSA署名の場合、r、s、vプロパティの場合は0〜65バイト)。この検証方法は、サブスクライバーがパブリッシャーコントラクトの `verifyHookEvent` を別のチェーンで呼び出すことができない場合のクロスチェーンフックイベントに使用できます。

ペイロードは、calldata内のバイト配列としてサブスクライバーに渡される必要があります。サブスクライバースマートコントラクトは、バイト配列を必要なデータ型に変換する必要があります。たとえば、ペイロードがsnarkプルーフの場合、パブリッシャーはそれを文字列化する必要があり、サブスクライバースマートコントラクトはそれを逆シリアル化する必要があります。

### リレーヤー

リレーヤーは、パブリッシャースマートコントラクトの `Hook` イベントをリッスンする独立したパーティーです。リレーヤーは、レジストリからさまざまなフックの登録されたサブスクライバーのリストを取得し、パブリッシャースマートコントラクトでフックイベントが発行されるのを待ちます。パブリッシャースマートコントラクトでフックイベントが発行されると、リレーヤーはサブスクライバーコントラクトの `verifyHook` 関数を実行するトランザクションをブロードキャストすることで、フックイベントのペイロードをサブスクライバーコントラクトに中継できます。リレーヤーは、これによって報酬を得ることができます。

リレーヤーは、サブスクライバーコントラクトが手数料の支払いに十分な残高を持っていることを確認するために、トランザクションをローカルでシミュレーションする必要があります。これには、サブスクライバーコントラクトが、リレーヤー手数料の支払いのためにETH(またはその他のアセット)の残高を維持する必要があります。サブスクライバーコントラクトは、ペイロードのデータに基づいて、トランザクションをリバートする論理条件を持つことができます。この場合、リレーヤーはローカルでトランザクションをシミュレーションし、フックイベントをサブスクライバーコントラクトに中継しないことを判断します。

### フックイベントの検証

サブスクライバーコントラクトの `verifyHook` 関数には、認証されたイベントを取得するためのロジックが含まれている必要があります。フックイベントに署名が含まれている場合、サブスクライバーコントラクトは必要なパラメーターのハッシュを作成し、ハッシュと発行者の公開鍵に対して署名が有効であることを確認する必要があります(参考実装を参照してください)。フック関数は、フックイベントのnonce も検証し、リプレイ攻撃を防ぐために内部で記録する必要があります。

署名のないフックイベントの場合、サブスクライバーコントラクトは、パブリッシャーコントラクトの `verifyHookEvent` を呼び出して、フックイベントが有効であることを確認する必要があります。パブリッシャースマートコントラクトは、ペイロードのハッシュ、スレッドID、nonce、およびフックイベントが発行されたブロック高を受け取り、フックイベントの信頼性を示すブール値を返す `verifyHookEvent` を実装する必要があります。

### インターフェイス

IRegistry.sol

```js
/// @title IRegistry
/// @dev レジストリコントラクトを実装します
interface IRegistry {
    /// @dev パブリッシャーによる新しいフックイベントの登録
    /// @param publisherContract パブリッシャーコントラクトのアドレス
    /// @param threadId これらのフックイベントが発行されるスレッドのID
    /// @param signingKey 外部生成されたペイロードの署名に対応する公開鍵(オプション)
    /// @return フックの登録が成功した場合はtrueを返す
    function registerHook(
        address publisherContract,
        uint256 threadId,
        bytes calldata signingKey
    ) external returns (bool);

    /// @dev レジストリに追加する前にパブリッシャースマートコントラクトでフックを検証する
    /// @param publisherAddress パブリッシャーコントラクトのアドレス
    /// @param threadId これらのフックイベントが発行されるスレッドのID
    /// @param signingKey フックの署名を検証するために使用される公開鍵
    /// @return フックの検証が成功した場合はtrueを返す
    function verifyHook(
        address publisherAddress,
        uint256 threadId,
        bytes calldata signingKey
    ) external returns (bool);

    /// @dev 以前に登録されたフックイベントを更新する
    /// @dev 新しいアドレスにフックの承認を転送するために使用できます
    /// @dev フックを削除するには、バーンアドレスに転送する
    /// @param publisherContract パブリッシャーコントラクトのアドレス
    /// @param threadId これらのフックイベントが発行されるスレッドのID
    /// @param signingKey フックの署名を検証するために使用される公開鍵
    /// @return フックの更新が成功した場合はtrueを返す
    function updateHook(
        address publisherContract,
        uint256 threadId,
        bytes calldata signingKey
    ) external returns (bool);

    /// @dev 以前に登録されたフックイベントを削除する
    /// @param publisherContract パブリッシャーコントラクトのアドレス
    /// @param threadId これらのフックイベントが発行されるスレッドのID
    /// @param signingKey フックの署名を検証するために使用される公開鍵
    /// @return フックの削除が成功した場合はtrueを返す
    function removeHook(
        address publisherContract,
        uint256 threadId,
        bytes calldata signingKey
    ) external returns (bool);

    /// @dev フックイベントにサブスクライバーを登録する
    /// @param publisherContract パブリッシャーコントラクトのアドレス
    /// @param subscriberContract フックイベントにサブスクライブするコントラクトのアドレス
    /// @param threadId これらのフックイベントが発行されるスレッドのID
    /// @param fee サブスクライバーコントラクトがリレーヤーに支払う手数料
    /// @param maxGas グリーフィング攻撃を防ぐために、サブスクライバーが許可する最大ガス量
    /// @param maxGasPrice サブスクライバーが払い戻しを許可する最大ガス価格
    /// @param chainId サブスクライバーが更新を受け取りたいチェーンID
    /// @param feeToken 手数料の支払いに使用するトークンのアドレス、またはチェーンのネイティブアセット(ETH)の場合は0x0
    /// @return サブスクライバーの登録が成功した場合はtrueを返す
    function registerSubscriber(
        address publisherContract,
        address subscriberContract,
        uint256 threadId,
        uint256 fee,
        uint256 maxGas,
        uint256 maxGasPrice,
        uint256 chainId,
        address feeToken
    ) external returns (bool);

    /// @dev サブスクライバーのサブスクリプションを更新する
    /// @param publisherContract パブリッシャーコントラクトのアドレス
    /// @param subscriberContract フックイベントにサブスクライブするコントラクトのアドレス
    /// @param threadId これらのフックイベントが発行されるスレッドのID
    /// @param fee サブスクライバーコントラクトがリレーヤーに支払う手数料
    /// @return サブスクライバーの更新が成功した場合はtrueを返す
    function updateSubscriber(
        address publisherContract,
        address subscriberContract,
        uint256 threadId,
        uint256 fee
    ) external returns (bool);

    /// @dev フックイベントのサブスクリプションを削除する
    /// @param publisherContract パブリッシャーコントラクトのアドレス
    /// @param subscriberContract フックイベントにサブスクライブするコントラクトのアドレス
    /// @param threadId これらのフックイベントが発行されるスレッドのID
    /// @return サブスクリプションの削除が成功した場合はtrueを返す
    function removeSubscription(
        address publisherContract,
        address subscriberContract,
        uint256 threadId
    ) external returns (bool);
}
```

IPublisher.sol

```js
/// @title IPublisher
/// @dev パブリッシャーコントラクトを実装します
interface IPublisher {
    /// @dev フックイベントを発行するときに呼び出される関数の例
    /// @param payload フックイベントの実際のペイロード
    /// @param digest ペイロードに署名されたハッシュ
    /// @param threadId フックイベントを発行するスレッド番号
    function fireHook(
        bytes calldata payload,
        bytes32 digest,
        uint256 threadId
    ) external;

    /// @dev 新しいフックイベントを内部に追加/更新する
    /// @param threadId フックのスレッドID
    /// @param signingKey フックイベントに署名する秘密鍵に対応する公開鍵
    function addHook(uint256 threadId, bytes calldata signingKey) external;

    /// @dev レジストリコントラクトによって呼び出されるとき、フックが有効であることを確認するために使用される
    /// @param threadId フックのスレッドID
    /// @param signingKey フックイベントに署名する秘密鍵に対応する公開鍵
    /// @return フックが有効で、レジストリに追加してよい場合はtrueを返す
    function verifyEventHookRegistration(
        uint256 threadId,
        bytes calldata signingKey
    ) external view returns (bool);

    /// @dev 指定されたフックが有効かどうかを返す
    /// @param payloadhash ペイロードデータのハッシュ
    /// @param threadId フックのスレッドID
    /// @param nonce 現在のスレッドのnonce
    /// @
@param blockheight フックが発行されたブロック高
    /// @return フックが有効な場合はtrueを返す
    function verifyEventHook(
        bytes32 payloadhash,
        uint256 threadId,
        uint256 nonce,
        uint256 blockheight
    ) external view returns (bool);
}
```

ISubscriber.sol

```js
/// @title ISubscriber
/// @dev サブスクライバーコントラクトを実装します
interface ISubscriber {
    /// @dev パブリッシャーによってフックが発行されたときに呼び出される関数の例
    /// @param publisher フックイベントを検証するためのパブリッシャーコントラクトのアドレス
    /// @param payload 署名されたフックイベントペイロードのハッシュ
    /// @param threadId このフックが発行されたスレッドのID
    /// @param nonce このフックの一意のnonce
    /// @param blockheight フックイベントが発行されたブロック高
    function verifyHook(
        address publisher,
        bytes calldata payload,
        uint256 threadId,
        uint256 nonce,
        uint256 blockheight
    ) external;
}
```

## 根拠

このデザインの根拠は、スマートコントラクト開発者が、オフチェーンプロセスを実行することなく、他のスマートコントラクトから発行されたイベントに応答するコントラクトロジックを記述できるようにすることです。これは、他のコントラクトのイベントに応答して比較的頻繁に実行される単純なスマートコントラクトロジックに最適です。

これは、パブリッシュ/サブスクライブのデザインパターンを実現するための既存のソリューションを改善したものです。詳しくは以下の通りです:現在、多くのサービスプロバイダーが「ウェブフック」を提供し、スマートコントラクトから発行されたイベントにサブスクライブできるようにしています。これは、イベントが発行されたときにAPIエンドポイントが呼び出されるか、スマートコントラクトのイベントをトリガーできるサーバーレス機能を提供するものです。このアプローチは非常に効果的ですが、APIエンドポイントやサーバーレス機能が常に利用可能である必要があり、専用のサーバー/プロセスが必要になり、秘密鍵を持ち、トランザクションを再ブロードキャストするためにETHを持つ必要があります。さらに、サードパーティプロバイダーのアカウントを維持する必要があります。

このアプローチは、「常時オン」のサーバーインスタンスが望ましくない場合に、より適切な代替手段を提供します。

このプロポーザルには、分散型の市場主導型のリレーネットワークが組み込まれていますが、これは非常にスケーラブルなアプローチであるためです。逆に、市場主導型のアプローチを使用せずに、この機能を実装することも可能です。単純に、他のコントラクトがサブスクライブできるようにするための標準を定義するだけです。このアプローチは概念的にはより単純ですが、欠点もあります。パブリッシャーコントラクトが自身の状態にサブスクライバーを記録する必要があるため、データ管理、アップグレード可能性などのオーバーヘッドが発生します。また、パブリッシャーコントラクトが各サブスクライバーコントラクトの `verifyHook` 関数を呼び出す必要があるため、パブリッシャーコントラクトに大きなガス代がかかる可能性があります。

## セキュリティ上の考慮事項

### グリーフィング攻撃

サブスクライバーコントラクトが、本質的な価値や関心のないイベントを発行するパブリッシャーコントラクトを信頼しないことが重要です。悪意のあるパブリッシャーコントラクトが多数のイベントを発行し、サブスクライバーコントラクトのETHを枯渇させる可能性があるためです。

### フロントランニング攻撃

署名のみに頼らずにフックイベントを検証することが重要です。パブリッシャーとサブスクライバーは、リレーヤーがパブリッシャーのトランザクションがブロックに含まれる前にフックイベントを中継できる可能性があることを認識する必要があります。通常のフローでは、「トリガー」トランザクションがパブリッシャースマートコントラクトの関数を呼び出し、それがイベントを発行し、リレーヤーがそれを取得します。競争力のあるリレーヤーは、パブリッシャーのトランザクションがパブリックメンプールにある間に、署名とペイロードを取り出し、トリガートランザクションが処理される前にサブスクライバーコントラクトに中継できます。実際、ガス代の動力学に基づいて、サブスクライバーコントラクトがトリガートランザクションよりも先にイベントを処理する可能性があります。これは、サブスクライバーコントラクトがパブリッシャーコントラクトの `verifyEventHook` 関数を呼び出すことで軽減できます。

リレーヤーに影響するもう1つのフロントランニングリスクは、一般化されたMEVサーチャーがメンプールでリレーヤーのトランザクションをフロントランニングする可能性があることです。このようなMEVキャプチャは公開メンプールで発生する可能性が高いため、リレーヤーはプライベートチャネルを使ってブロック作成者にトランザクションを送信することをお勧めします。

### リレーヤーの競争

分離されたメンプールにトランザクションをブロードキャストすることで、リレーヤーは一般化されたMEVボットによるフロントランニングから保護されますが、他のリレーヤーからの競争によってトランザクションが失敗する可能性があります。2つ以上のリレーヤーが同じパブリッシャーから同じサブスクライバーにフックイベントをリレーしようとする場合、ガス代の高いリレートランザクションが先に実行されます。これにより、他のリレーヤーのトランザクションが同じブロック内で後に含まれ、オンチェーンで失敗する可能性があります。現時点では、トランザクションが失敗しないようにする一定のトランザクション最適化サービスが存在しますが、これはこのドキュメントの範囲外です。

### 最適な手数料

リレーヤーに支払われる手数料はサブスクライバーの裁量ですが、特に変動ガス代を考慮すると、適切な水準に設定するのは非trivialです。これにより、サブスクライバーが「安全」だと考える水準の手数料を設定し、リレーヤーがフックイベントをリレーすることを確信できるようになります。これは必然的に価格発見が悪く、サブスクライバーが更新に過剰に支払うことになります。

この問題を解決する最良の方法は、リレーヤー間の入札メカニズムを通じて、リレーヤーがトランザクションをリレーする権利を競争できるようにすることです。これにより、サブスクライバーが更新に対して最適な価格を支払うことが保証されます。このような入札メカニズムを記述することは本提案の範囲外ですが、遅延を導入することなく、この要件を満たす一般的な目的の入札メカニズムに関する提案があります。FlashbotsのSUAVEなどがその一例です。

### 入札なしの場合

入札メカニズムを使用せずに信頼できるリレーヤー市場を育成・維持するためには、サブスクライバーコントラクトが、ガス代を指定された上限まで払い戻す(通常の条件下でフックの更新を実行できるようにする)ロジックを実装する必要があります。

別のアプローチは、`verifyHook` 関数を呼び出すトランザクションのガス価格を確認し、手数料をゼロに実質的に減らさないようにすることです。これには、サブスクライバースマートコントラクトが `verifyHook` 関数のガス消費量を把握し、`minFee >= fee - (gasPrice * gasUsed)` の条件が true であることを確認する必要があります。これにより、有効な手数料が下限を下回らないようにできます。つまり、トランザクションがリバートされる前に支払える最高のガス価格は `fee - minFee + ε` となります。ここで `ε ~= 1 gwei` です。これには、`verifyHook` 関数のガスコストの慎重な見積もりと、状態の変化に伴ってガス消費量が変化する可能性があることの認識が必要です。この方法の重要な洞察は、サブスクライバーが支払う手数料は常に最大値になるということです。これが、入札メカニズムの使用が望ましい理由です。

### リレーヤーのトランザクションバッチング

もう1つの重要な考慮事項は、フックイベントのバッチングです。リレーヤーは論理的にガス代を節約するためにバッチングを行うインセンティブがあります。バッチ処理により、ブロック内の単一のリレーヤーによる n 個のフックの処理では、ガス代が21,000 * n 節約されます。リレーヤーが複数のサブスクライバーコントラクトへのフックイベントの更新をマルチコールプロキシコントラクトにバッチ処理する場合、バッチ内の1つのトランザクションが失敗すると、バッチ全体が失敗する可能性があります。たとえば、リレーヤーAがxのフックを、リレーヤーBがyのフックをバッチングした場合、リレーヤーAのバッチがリレーヤーBのバッチの前に同じブロックに含まれ、両方のバッチに少なくとも1つの重複がある場合、リレーヤーBのバッチトランザクションはオンチェーンで失敗します。これは、リレーヤーにとって重要な考慮事項であり、リレーヤーは競合するトランザクションを特定する前にバンドルシミュレーションサービスにアクセスできるべきです。

### リプレイ攻撃

署名検証を使用する場合は、[EIP-712](./eip-712.md)標準を使用して、ネットワーク間のリプレイ攻撃を防ぐことをお勧めします。同じコントラクトが複数のネットワークにデプロイされている場合、同じフックイベントがその他のネットワークのサブスクライバーコントラクトにプッシュされる可能性があります。たとえば、PolygonのパブリッシャーコントラクトからのフックイベントがGnosis Chainのサブスクライバーコントラクトにリレーされる可能性があります。署名に使用されるキーが一意であることが理想的ですが、実際にはそうでない可能性があります。

このため、[ERC-721](./eip-712.md)の型付きデータ署名の使用をお勧めします。この場合、フックを開始するプロセスは、以下のデータ構造に従って署名を作成する必要があります:

```js
const domain = [
  { name: "name", type: "string"  },
  { name: "version", type: "string" },
  { name: "chainId", type: "uint256" },
  { name: "verifyingContract", type: "address" },
  { name: "salt", type: "bytes32" }
]
 
const hook = [
  { name: "payload", type: "string" },
  { type: "uint256", name: "nonce" },
  { type: "uint256", name: "blockheight" },
  { type: "uint256", name: "threadId" },
]
 
const domainData = {
  name: "Name of Publisher Dapp",
  version: "1",
  chainId: parseInt(web3.version.network, 10),
  verifyingContract: "0x123456789abcedf....publisher contract address",
  salt: "0x123456789abcedf....random hash unique to publisher contract"
}
 
const message = {
  payload: "bytes array serialized payload"
  nonce: 1,
  blockheight: 999999,
  threadId: 1,
}
 
const eip712TypedData = {
  types: {
    EIP712Domain: domain,
    Hook: hook
  },
  domain: domainData,
  primaryType: "Hook",
  message: message
}
```

注: リプレイ攻撃の例については、参考実装のユニットテストを参照してください。

同じネットワーク上でも、以前に発行されたフックイベントを再ブロードキャストすることでリプレイ攻撃が発生する可能性があります。このため、サブスクライバーコントラクトは、受信したフックイベントのnonceを検証し、コントラクトの状態に記録する必要があります
。nonce が有効でない、または既に記録されている場合は、トランザクションをリバートする必要があります。

### クロスチェーンメッセージング

`chainId` を、リプレイ攻撃の防止以外の目的、つまりほかのチェーンからのメッセージの受信にも使用できます。このユースケースでは、サブスクライバーコントラクトは、サブスクライバーコントラクトがデプロイされているのと同じチェーンに登録し、`chainId` にメッセージを受信したいチェーンを設定する必要があります。

## 著作権

著作権およびそれに関連する権利は、CC0の下で放棄されています。