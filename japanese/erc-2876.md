---
original: c852409329e24881be6e340104b29aa6742c7728a634c63ae6dc07731df96875
---

---
eip: 2876
title: デポジットコントラクトとアドレス標準
author: Jonathan Underwood (@junderw)
discussions-to: https://github.com/junderw/deposit-contract-poc/issues/1
status: 停滞
type: Standards Track
category: ERC
created: 2020-08-13
---

## 簡単な要約
このERCは、デポジットの管理のための単純なコントラクトインターフェースを定義します。また、メイン デポジット関数に渡される追加データをエンコードする新しいアドレス形式も定義しています。

## 概要
ERC-2876互換の**デポジットシステム**は、複数の預金者からETHの支払いを受け付けることができ、複数のキーの管理や、ホットウォレットの使用を必要としません。

ERC-2876互換の**ウォレットアプリケーション**は、このスタンダードで指定された8バイトのIDを使ってETHを**デポジットシステム**に送金することができ、**デポジットシステム**はその支払いを区別することができます。

すべての取引所(デポジットシステムとしても、出金システムのウォレットとしても)、マーチャント、およびすべてのウォレットアプリケーション/ライブラリがERC-2876を採用すれば、これらのシステムの総ネットワークガス使用量が大幅に減少する可能性があります。これは、2つの値トランザクションには42,000ガスが必要ですが、単純なETHフォワーディングコントラクトでは、実装によって30,000ガス前後で済むためです。

また、デポジットシステム管理者にとっても、すべてのデポジットを手動操作なしに直接コールドウォレットに転送できるというメリットがあります。

## 動機
中央集権型取引所やマーチャント(以下「アプリ」)は、デポジットを受け付けるためのアドレス形式が必要です。現在使用されているアドレス形式は、アカウント(外部またはコントラクト)を指しますが、これには問題があります。アプリは、各請求書/ユーザーに新しいアカウントを作成する必要があります。アカウントが外部の場合、アプリはデポジットアドレスをホットウォレットにする必要があるか、コールドウォレット運営者の作業負荷が増加します(各デポジットアカウントに1つの値トランザクションが発生するため)。アカウントがコントラクトの場合、アカウントを生成するには少なくとも60kガスがかかり、コストが高すぎます。

したがって、マーチャントや中央集権型取引所アプリは、以下のいずれかを選択せざるを得なくなります。

- 大きなセキュリティリスク(デポジットアカウントがホットウォレット)
- 大きな手作業コスト(コールドアカウント管理者が数千のコールドアカウントを掃除する時間がかかる)
- 大きなサービスコスト(コントラクトごとのデポジットアドレスモデルを展開する)

この提案のタイミングは、ネットワークガス価格の上昇の文脈の中にあります。このような時期には、新しくスペースに参入するサービスがますますホットウォレットにデポジットを強いられ、大きなセキュリティリスクが生じています。

この提案の動機は、多数のユーザーからデポジットを受け付けるシステムの展開とマネジメントのコストを下げること、そしてこの手法を標準化することで、世界中のサービスがこのインターフェースを使ってお互いに価値を送受信できるようにすることです。

## 仕様

### 定義
- この文書における「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されるものとします。
- `コントラクトインターフェース`は、このERCのコントラクトコンポーネントです。
- `デポジットアドレス形式`は、20バイトのアカウントアドレスと8バイトのIDをエンコードするために新たに作られた形式です。
- `コントラクト`は、このERCの`コントラクトインターフェース`を実装するコントラクトを指します。
- `8バイトの"id"`は、コントラクトインターフェースの入力パラメータとして使用される8バイトのIDです。
- `5バイトの"nonce"`は、"id"の最上位5バイトです。
- `3バイトの"チェックサム"`は、"id"の最下位3バイトです。
- `deposit(bytes8)`は、コントラクトインターフェースで定義されている関数シグネチャを指します。
- `親アプリケーション`は、`deposit(bytes8)`関数内で得られた情報を使用するアプリケーションを指します(例:取引所のバックエンドや非保管型のマーチャントアプリケーション)。
- `預金者`は、`deposit(bytes8)`コールを介して`コントラクト`に価値を送金する人を指します。
- `ウォレット`は、`預金者`の要求に応じて価値取引を送信するアプリケーションやライブラリを指します(例:MyEtherWallet、Ledger、blockchain.com、各種ライブラリ)。

### デポジットアドレス形式

8バイトの"id"データを追加するために、20バイトのアカウントアドレスとともにエンコードする必要があります。8バイトはアドレスの後ろに追加されます。

3バイトのチェックサムが含まれており、これは20バイトのアドレスと5バイトのnonceの concatenation (25バイト) のkeccak256ハッシュの先頭3バイトです。

デポジットアドレス形式は、以下のJavaScriptコードで生成できます:

```js
/**
 * 20バイトのアカウントアドレスと5バイトのnonceをデポジットアドレスに変換します。
 * 戻り値のフォーマットは以下の通りです。+ 演算子はバイトの連結を表します。
 * (baseAddress + nonce + keccak256(baseAddress + nonce)[:3])
 *
 * @param {String} baseAddress 与えられた16進アドレス (0xプレフィックス付き20バイト16進文字列)
 * @param {String} nonce 与えられた16進nonce (0xプレフィックス付き5バイト16進文字列)
 * @return {String}
 */
function generateAddress (baseAddress, nonce) {
  if (
    !baseAddress.match(/^0x[0-9a-fA-F]{40}$/) ||
    !nonce.match(/^0x[0-9a-fA-F]{10}$/)
  ) {
    throw new Error('Base Address and nonce must be 0x hex strings');
  }
  const ret =
    baseAddress.toLowerCase() + nonce.toLowerCase().replace(/^0x/, '');
  const myHash = web3.utils.keccak256(ret);
  return ret + myHash.slice(2, 8); // 0x16進文字列の先頭3バイト
};
```

チェックサムは、デポジットコントラクト内で以下のように検証できます:

```solidity
function checksumMatch(bytes8 id) internal view returns (bool) {
    bytes32 chkhash = keccak256(
        abi.encodePacked(address(this), bytes5(id))
    );
    bytes3 chkh = bytes3(chkhash);
    bytes3 chki = bytes3(bytes8(uint64(id) << 40));
    return chkh == chki;
}
```

### コントラクトインターフェース

このERCに準拠するコントラクト:

- `コントラクト`は、`msg.data`がnull(純粋な値トランザクション)の場合、トランザクションをリバートしなければなりません。
- `コントラクト`は、以下のようなデポジット関数を持たなければなりません:

```solidity
interface DepositEIP {
  function deposit(bytes8 id) external payable returns (bool);
}
```

- `deposit(bytes8)`は、コントラクトが値を保持する必要がある場合は`false`を返さなければなりません。ただし、(親アプリケーションの観点では)デポジット自体が成功していないことを預金者に知らせます。(これは部分払いに使用できます。例えば、請求額が5 ETHで3 ETHを送金した場合は`false`を返し、2 ETHを送金する2回目のトランザクションは`true`を返します。)
- `deposit(bytes8)`は、デポジットが何らかの理由で失敗し、コントラクトが送信された値を保持する必要がない場合はリバートしなければなりません。
- `deposit(bytes8)`は、値が保持され、親アプリケーション(取引所/マーチャント)によってデポジットが論理的に完了したと見なされる場合は`true`を返さなければなりません。
- `deposit(bytes8)`は、8バイトのIDに含まれるチェックサムを確認すべきです(「デポジットアドレス形式」の例を参照)。
- `親アプリケーション`は、デポジットIDが一回限りの請求書で金額が決まっている場合、受け取った金額が請求額を上回った場合、超過分を返金すべきです。ただし、`msg.sender`に直接送金するのではなく、親アプリケーション側で記録し、預金者に対して別の方法で連絡するべきです。

### ウォレットからコントラクトへのデポジット

- `ウォレット`は、20バイトのアドレス形式が受け付けられる場所で、`デポジットアドレス形式`を受け付けなければなりません。
- `ウォレット`は、3バイトのチェックサムを検証し、チェックサムが一致しない場合はエラーにしなければなりません。
- `ウォレット`は、宛先アドレスが`デポジットアドレス形式`で、`data`フィールドがnull以外に設定されている場合はエラーにしなければなりません。
- `ウォレット`は、基礎となるトランザクションの`to`フィールドをデポジットアドレス形式の最初の20バイトに設定し、`data`フィールドを`0x3ef8e69aNNNNNNNNNNNNNNNN000000000000000000000000000000000000000000000000`に設定しなければなりません。ここで`NNNNNNNNNNNNNNNN`はデポジットアドレス形式の最後の8バイトです(例えば、デポジットアドレス形式が`0x433e064c42e87325fb6ffa9575a34862e0052f26913fd924f056cd15`の場合、`to`フィールドは`0x433e064c42e87325fb6ffa9575a34862e0052f26`、`data`フィールドは`0x3ef8e69a913fd924f056cd15000000000000000000000000000000000000000000000000`)。

## 根拠
コントラクトインターフェースとアドレス形式の組み合わせには、議論で指摘された1つの注目すべき欠点があります。このERCは、ネイティブ通貨(ETH)のデポジットしか扱えず、ERC-20などのその他のプロトコルは扱えません。しかし、これは問題とは考えられません。会計上の理由とセキュリティ上の理由から、取引所/マーチャントアプリケーションでは、別通貨用に論理的にも鍵的にも分離されたウォレットを使うのが最良の実践だからです。したがって、ネイティブ通貨(ETH)にはこの方法を使い、ERC-20トークンなどには別の方法を使うのは許容されます。ERC-20に対して同様のことをする試みは、(転送メソッドに新しい入力引数としてid データを追加するなど)ERCの範囲を大きくしすぎてしまうため、管理が難しくなります。ただし、このアドレス形式が広く採用されれば、更新されたプロトコルにもbytes8 idを追加するのは簡単ですが(ネットワーク効果のため、採用は難しいかもしれません)。

idの8バイトサイズとチェックサムの3:nonceの5の比率は、以下の点を考慮して決められました:

- 24ビットのチェックサムは、EIP-55アドレスの平均15ビットのチェックサムよりも優れています。
- 40ビットのnonceは、10億を超えるnonceをサポートできます。
- idの64ビット長は、十分なチェックサムと多数のnonceをサポートできる長さに選択されました(256ビット未満にすることで、ガスコストの点でもハッシングが安くなります)。

## 下位互換性
デポジットアドレス形式で生成されたアドレスは、それをサポートしていないアプリケーションでは有効なアドレスとは見なされません。ユーザーが十分な技術力を持
っている場合は、自分でチェックサムを検証し、必要なデータフィールドを手動で作成して、データフィールドを手動で入力することで、サポートされていない問題を回避できます(ウォレットアプリがトランザクションに任意のデータ入力を許可している場合)。ユーザーが使えるようにGitHubでツールをホストし、デポジットアドレスから必要な20バイトのアドレスとmsg.dataフィールドを取得できるようにすることができます。

ただし、このフォーマットは単純で実装も簡単なので、この ERC の著者はまず web3.js で実装し、主要なウォレットアプリケーションの採用を推奨する予定です。

## テストケース
```
[
  {
    "address": "0x083d6b05729c58289eb2d6d7c1bb1228d1e3f795",
    "nonce": "0xbdd769c69b",
    "depositAddress": "0x083d6b05729c58289eb2d6d7c1bb1228d1e3f795bdd769c69b3b97b9"
  },
  {
    "address": "0x433e064c42e87325fb6ffa9575a34862e0052f26",
    "nonce": "0x913fd924f0",
    "depositAddress": "0x433e064c42e87325fb6ffa9575a34862e0052f26913fd924f056cd15"
  },
  {
    "address": "0xbbc6597a834ef72570bfe5bb07030877c130e4be",
    "nonce": "0x2c8f5b3348",
    "depositAddress": "0xbbc6597a834ef72570bfe5bb07030877c130e4be2c8f5b3348023045"
  },
  {
    "address": "0x17627b07889cd22e9fae4c6abebb9a9ad0a904ee",
    "nonce": "0xe619dbb618",
    "depositAddress": "0x17627b07889cd22e9fae4c6abebb9a9ad0a904eee619dbb618732ef0"
  },
  {
    "address": "0x492cdf7701d3ebeaab63b4c7c0e66947c3d20247",
    "nonce": "0x6808043984",
    "depositAddress": "0x492cdf7701d3ebeaab63b4c7c0e66947c3d202476808043984183dbe"
  }
]
```

## 実装
サンプル実装とアドレス生成のテスト(テスト内)は、こちらにあります:

https://github.com/junderw/deposit-contract-poc

## セキュリティ上の考慮事項
一般的に、コントラクトインターフェースを実装するコントラクトは、deposit(bytes8)関数で受け取った資金をコールドウォレットアカウントに転送すべきです。このアドレスは定数として hard-coded するか、solidity version `>=0.6.5`の `immutable` キーワードを利用するべきです。

親アプリケーションが停止した後にデポジットが送られるのを防ぐため、コントラクトは `selfdestruct(address)` を使うのではなく、deposit(bytes8)へのすべてのコールをリバートするキルスイッチを持つべきです(外部アカウントが値を受け取るため、自己破壊されたコントラクトは新しいデポジットの受け皿にはならず、事実上ブラックホールになってしまいます)。

## 著作権
著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。