---
original: f9a06583cc20a80001b89ad92ed90e19c79757b3f4a1dad90b1223bf95b1faa4
---

---
eip: 7524
title: ウォレットでのPLUMEシグネチャ
description: 一意の匿名性とzkボーティングを可能にする「ナリファイアー」を備えた、Ethereumキーペアの新しい署名方式。
author: Yush G (@Divide-By-0) <aayushg@mit.edu>、Kobi Gurkan (@kobigurk)、Richard Liu (@rrrliu)、Vivek Bhupatiraju (@vb7401)、Barry Whitehat (@barryWhiteHat)
discussions-to: https://ethereum-magicians.org/t/erc-7524-plume-signature-in-wallets/15902
status: Draft
type: Standards Track
category: ERC
created: 2023-09-24
---

## 概要

ZK-SNARKsは、匿名の所有権証明に基づく新しいアイデンティティアプリケーションの構想を可能にしてきました。匿名の一意性を必要とするシステムに移行するための主要な技術の1つは、検証可能な決定論的署名の開発です。EthereumはECDSAに基づいているため、現時点では署名が決定論的に生成されたことを検証する方法はありません。ZK-SNARKプルーフを作成するには秘密鍵が必要であり、一部のハードウェアウォレットでは秘密鍵を表示することさえできません。一般的に、SNARKの算術化をウォレットの安全なエンクレーブ内で実行することを標準化したくはなく、また、ユーザーに秘密鍵をエクスポートやコピー&ペーストさせることも望ましくありません。したがって、エンクレーブ外でSNARKできる新しいアルゴリズムを選択する必要があります。

匿名性を持つ一意のアカウントを実現する具体的な例として、署名のハッシュ値(ナリファイアー)を使用し、ZK-SNARKでそれが正しく生成されたことを証明することが考えられます。この証明は他者に公開されるものであり、ナリファイアーは特定の匿名アカウントへの公開コミットメントとして使用できます。このため、二重支出の禁止や、匿名アクションの一貫したアイデンティティの確立などが可能になります。本提案では、秘密鍵を必要とせずに検証できる、新しい検証可能な決定論的署名アルゴリズムを標準化することを目的としています。具体的には、$hash(message, public\ key) ^ {secret\ key}$という署名関数を採用します。

## 動機

- 既存のZKアプリケーションでは、証明者に一意性の制約がありません。つまり、同じウォレットが複数回自身のメンバーシップを証明することが意図されています。しかし、多くのアプリケーションでは、ユーザーごとに1回の最大アクションが必要です。特に、Sybil耐性を望むプロトコルなどです。Ethereumアカウントをオプトインのマッピングに割り当てる方法では、複雑さが増し、アトミック性が失われ、Ethereumアカウントの豊かなオンチェーン履歴を活用できません。
- このテクノロジーを必要とする具体的なアプリケーションには以下のようなものがあります:
    - 1人1票のzkボーティング
    - Stealthdropのような匿名のエアドロップの請求
    - フォーラムの匿名モデレーション - ユーザーが他の場所で同一性を証明できる
    - zkソルベンシーの証明 - 2つの取引所が同じアドレスを主張しないことを証明する必要がある
    
したがり、EthereumアカウントのECDSAキーペアに基づく決定論的な値は、ユーザーごとの1回のアクションを保証し、これらのアプリケーションをEthereumで実現するための必要不可欠な要素です。

## 仕様

ウォレット内のECDSAキーに対して以下のプロパティを備えた新しい署名標準を提案します:

1. 署名には決定論的な要素と非決定論的な要素が含まれます。決定論的な要素は*ナリファイアー*として使用できます。
2. 署名者は既存のsecp256k1キーペア(ハードウェアウォレットのEthereumアカウントなど)を使用できます。その結果、秘密鍵はエンクレーブ内に保持できます(Ledgerなどはエンクレーブ内での生成点乗算APIを提供しています)。

### パラメータ

このスキームはsecp256k1曲線を使用し、[Standards for Efficient Cryptography 2 (SEC 2) v2](../assets/eip-7524/sec2-v2.pdf)のページ9で定義されています。

曲線のパラメータを以下のように表します:

- $g$: 曲線の基点(ジェネレーター)。
- $p$: 曲線の位数。
- $F_p$: 位数が$p$の有限体。

楕円曲線スカラー乗算を表すために指数表記を使用します。

### 公開鍵エンコーディング関数

### SEC1

このスキームは[Standards for Efficient Cryptography 1 (SEC 1) v2](../assets/eip-7524/sec1-v2.pdf)で定義されたSEC1楕円曲線点エンコーディングスキームを使用します。ポイント圧縮が使用されます。secp256k1曲線点$pk$の圧縮エンコーディングをバイト列長33の$\mathsf{sec1}(pk)$と表します。

### ハッシュ関数

**SHA256**

このスキームは[IETF RFC 4634](https://www.rfc-editor.org/rfc/rfc4634)で定義されたSHA256ハッシュ関数を使用します。

このドキュメントでは、$n$個の値$a_1, ..., a_n$の連結のSHA256ダイジェストを$\mathsf{sha256}(a_1,.. a_n)$と表します。ダイジェストはsecp256k1スカラー領域の big-endian 値として解釈されます。

### ハッシュ-to-曲線

$n$個の値$a_1, ..., a_n$の連結に対する[IETF RFC 9380](https://www.rfc-editor.org/rfc/rfc9380) `secp256k1_XMD:SHA-256_SSWU_RO_` (付録J.8.1)のハッシュ-to-曲線アルゴリズムの結果である楕円曲線点を$\mathsf{htc}([a_1, ..., a_n])$と表します。

### 鍵生成

鍵ペアは$(sk, pk)$で定義されます:

- $sk$: ユーザーの秘密鍵で、$F_p$内の暗号学的に安全なランダムスカラーです。
- $pk$: ユーザーの公開鍵で、$g^{sk}$と定義され、secp256k1曲線上の点です。

### 署名生成

このスキームはChaum-Pedersen署名スキーム[^1]に基づいています。32バイトのメッセージ$m$とキーペア$(sk, pk)$を持つユーザーは以下のように署名を生成できます:

[^1]:
    ```csl-json
    {
      "DOI": "10.1007/3-540-48071-4_7",
      "URL": "https://link.springer.com/content/pdf/10.1007/3-540-48071-4_7.pdf",
      "publisher-place": "Berlin, Heidelberg",
      "author": [
        {
          "given": "David",
          "family": "Chaum"
        },
        {
          "given": "Torben Pryds",
          "family": "Pedersen"
        }
      ],
      "container-title": "Advances in Cryptology — CRYPTO' 92",
      "editor": [
        {
          "given": "Ernest F.",
          "family": "Brickell"
        }
      ],
      "type": "paper-conference",
      "id": "10.1007/3-540-48071-4_7",
      "citation-label": "10.1007/3-540-48071-4_7",
      "ISBN": "978-3-540-48071-6",
      "issued": {
        "date-parts": [
          [
            1993
          ]
        ]
      },
      "page": "89-105",
      "publisher": "Springer Berlin Heidelberg",
      "title": "Wallet Databases with Observers"
    }
    ```

1. $F_p$からランダムな$r$を選択する。
2. $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$を計算する。
3. $z = h ^ r$を計算する。
4. ナリファイアー$\mathsf{nul} = h^{sk}$を計算する。
5. $c = \mathsf{sha256}([g, pk, h, \mathsf{nul}, g^r, z]])$を計算する。
6. $s = r + sk \cdot c$を計算する。

署名は$(z, s, g^r, c, \mathsf{nul})$です。

$\mathsf{htc}$への入力の長さは常に65バイトです。

このスキームでは、$h$をメッセージと$pk$のハッシュとして計算します。これにより、スキームを決定論的にすることができます。

### 署名検証(非ZK)

> 📝 **注意:** このセクションは規範的ではありません。
>
> 非ZK署名検証は本提案の一部ではありませんが、ZK署名検証を直感的に理解するために関連しています。

署名者の公開鍵$pk$、メッセージ$m$、署名$(z, s, g^r, c, \mathsf{nul})$を知っている検証者は、以下の手順で署名の有効性を確認できます:

1. $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$を計算する。
2. $c' = \mathsf{sha256}([g, pk, h, \mathsf{nul}, g^r, z])$を計算する。
3. 以下のいずれかが偽の場合は拒否する:
a. $g^{s} \cdot pk^{-c} \stackrel{?}{=} g^r$
b. $h^s \cdot \mathsf{nul}^{-c} \stackrel{?}{=} z$
c. $c \stackrel{?}{=} c'$
4. 上記すべてが真の場合は受け入れる。

次にZK署名検証の仕様に移ります。

### バージョン1: 検証者最適化

署名者の$pk$を知ってはいけない検証者が、署名者が$sk$を知っていることを証明する必要がある場合、ゼロ知識証明が必要です。

以下の検証関数は、Groth16などの非対話型ゼロ知識証明システムの回路として記述できます。証明を作成するには、プルーバーは以下の入力を提供します:

**公開**: $\mathsf{nul}$、$c$
**秘密**: $pk$、$r$、$s$、$z$、$g^r$、$hash[m, g^sk]$(制約を節約するために含まれる)

回路は以下の計算を行います:

1. $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$を計算する。
2. $pk = g^{sk}$を計算する。
3. $c' = \mathsf{sha256}([g, pk, h, \mathsf{nul}, g^r, z]])$を計算する。
4. $g^{s} \cdot pk^{-c}$を計算する。
5. $g^r$を計算する。
6. $h^s \cdot \mathsf{nul}^{-c}$を計算する。

また、以下の制約を設定します:

- $g^{s} \cdot pk^{-c} = g^r$
- $h^s \cdot \mathsf{nul}^{-c} = z$
- $c = c'$

### バージョン2: プルーバー最適化

現在、ブラウザでのZKプルーフでは、SHA-256ハッシング演算が特に高コストです。PLUMEのコンテキストでは、$c$の計算がプルーフ時間の障壁となっています。そのため、Poseidonチームからの提案では、このハッシュ計算をサーキット外の検証者に移動することです。

これを行うために、$z$と$g^r$を公開シグナルにし、$c$の定義を$c = \text{sha256}([\text{nul}, g^r, z])$に更新します。更新されたプロトコルは以下のとおりです。

**公開:** $\mathsf{nul}$、$c$、$g^r$、$z$
**秘密:** $pk$、$r$、$s$、$hash[m, g^sk]$

回路は以下の計算を行います:

1. $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$を計算する。
2. $pk = g^{sk}$を計算する。
3. $g^{s} \cdot pk^{-c}$を計算する。
4. $g^r$を計算する。
5. $h
$s \cdot \mathsf{nul}^{-c}$を計算する。

回路は以下の制約を設定します:

- $g^{s} \cdot pk^{-c} = g^r$
- $h^s \cdot \mathsf{nul}^{-c} = z$

さらに、PLUMEの検証者は以下のチェックを実行します。

$c == \text{hash}(\text{nul}, g^r, h^r)$

EthereumのネイティブプリコンパイルであるSHA-256を使用するため、このオペレーションはスマートコントラクトの検証者にとっても効率的です。

### バージョン3:

より効率的なV3が将来登場する可能性があります。おそらく、hash_to_curveからの不可逆性の除去などが考えられます。

## 根拠

候補アルゴリズムに求める具体的なプロパティを定義し、その上で直感的なアルゴリズムを定義し、なぜそれらが実際には機能しないかを説明します。

- 非対話性
    - ZKIDシステムにおける非対話性の重要性は、当初から大きな匿名性集合を可能にし、対話フェーズがあるとSybil攻撃やスパムが可能になるのを防ぐことです。これにより、ZKエアドロップなどの新しいユースケースが可能になります。
    - 非対話性により、Merkleツリーへの参加登録などの対話を必要とせずに、適格ユーザー全体を匿名性集合に含めることができます。ZKプルーフでは、Merkleツリーのメンバーシップ、メッセージの署名、一意のナリファイアーを検証できます。対話型のナリファイアー(tornado.cashなど)では、新しいユーザーごとにアノニマティーセットのMerkleツリーを更新する必要があります。
- 一意性
    - 二重支出や二重請求を禁止するには、アカウントごとに一意であることを検証する必要があります。
    - 例: ECDSA署名は非決定論的であるため、署名だけでは不十分です。公開鍵のみで検証可能な新しい決定論的関数が必要です。ナリファイアーは非対話的であり、特定の匿名アカウントへの公開コミットメントとして使用できるため、一意性を保証できます。
- 決定論的
    - アカウントが1つの署名しか生成せず、常に同じ署名を生成するようにする必要があります。
- 秘密鍵なしで検証可能
    - 署名が非決定論的(ECDSAなど)の場合、署名だけでは検証できません。
    - 公開鍵のみで検証可能な新しい決定論的関数が必要です。
    - ユーザーに秘密鍵をコピー&ペーストさせたくなく、ハードウェアウォレットでも簡単にエンクレーブ計算できる関数を選ぶ必要があります。
    - ナリファイアーが非対話的であるため、アカウントのアイデンティティを明かすことなく、キーペアを一意に識別できます。

最終的な設計は可能な限り単純にし、BLS署名、Chaum-Pederson EQDL、Goh-JareckiのEDLペーパーに基づいていますが、secp256k1上で動作するようにしました。

## セキュリティ上の考慮事項

このアルゴリズムの暗号学的な証明は、PLUMEペーパー[^2]で正式に示されています。理論は公開されており、1回の内部監査を受けていますが、まだ最終的な検証や監査は行われていません。ただし、実証的にはこの仕様に準拠しています。

[^2]:
    ```csl-json
    {
        "DOI": "1721.1/147434",
        "author": [
        {
            "given": "Aayush",
            "family": "Gupta"
        },
        {
            "given": "Kobi",
            "family": "Gurkan"
        }
        ],
        "type": "book",
        "id": "Gupta_Gurkan_2022_PLUME",
        "citation-label": "Gupta_Gurkan_2022_PLUME",
        "issued": {
        "date-parts": [
            [
            2022,
            9
            ]
        ]
        },
        "keyword": "zero knowledge,zk proof,nullifier,ddh-vrf,vrf,pseudonymity,ethereum,bitcoin,ecdsa,secp256k1,plume,signature",
        "note": "Cryptology ePrint Archive, Paper 2022/1255",
        "title": "PLUME: An ECDSA Nullifier Scheme for Unique Pseudonymity within Zero Knowledge Proofs",
        "URL": "https://eprint.iacr.org/2022/1255"
    }
    ```

**対話性-量子秘密のトレードオフ**

将来的に量子コンピューターがECDSAキーペアのセキュリティを破る可能性がある場合、ほとんどのEthereumキーペアが破られますが、事前に量子耐性のあるキーペアに移行すれば、アクティブな資金は安全に保たれます。具体的には、新しい量子耐性のキーペア(または同様のアルゴリズムの高ビットキーペア)にコミットするメッセージに署名するだけで、正規のチェーンはそのようなキーペアを有効にするようにフォークできます。ZK-SNARKsは偽造可能になりますが、ZKプルーフの前方秘密性は依然として維持されます。最良の場合、チェーンはスムーズに継続できるはずです。

ただし、私たちの構造のような決定論的なナリファイアーに依存する場合、匿名性は即座に破られます。誰もが匿名性集合全体の秘密鍵を導出し、すべてのナリファイアーを計算して、一致するものを見つけることができるためです。これは、決定論的なプロトコルの匿名性の唯一の「ランダム性」の源である秘密鍵が明らかになるため、ECDSAベースの決定論的なナリファイアーアルゴリズムに共通する問題です。

データの post-quantum 秘密性を維持したい場合、少なくとも1つのプロパティを放棄する必要があります。おそらく最も簡単なのは非対話性でしょう。例えば、ZKエアドロップの場合、匿名性集合内の各アカウントが新しいセマフォrIDコミットメントにパブリックに署名します($hash[randomness\ |\ external\ nullifier\ |\ pk]$)。その後、クレームするときに外部ナリファイアーを明らかにし、それが匿名性集合内のセマフォrIDの1つから来たことをZKで証明します。これにより、アカウントがクレームする前にセマフォコミットメントに参加した人のみが匿名性集合になるため、大幅に縮小されます。その結果、ナリファイアーを事前にコミットするサインアップフェーズが必要になります。この対話性の要件により、ZKエアドロップやより洗練されたtornado cashの構造(ユースケースセクション)などのアプリケーションがはるかに難しくなります。ただし、ハッシュ(現時点では)が量子コンピューターでも依然として困難であることから、人々があなたを匿名化解除できるようになるのは数十年先になると考えられます。

量子アニーリングによる離散対数問題の解決に $2n^2$ キュービットが必要だという最近の概算は、 $n$ = 6ビットの素数以上では機能しなかったことから、これが現実になるまでにはまだ数十年かかると考えられます。また、RSAを解くのに $n^2$ キュービットが必要だという予測は、離散対数問題を解くのにさらに長い時間がかかることを示唆しています。

人々が対話性-量子秘密のトレードオフ上の適切な位置を選択し、この情報を参考にして自分に合ったアルゴリズムを選択することを願っています。DAO投票や若者の告白など、短期的な秘密性を重視する人々は、この文書のナリファイアー構造を優先するかもしれませんが、告発者や記者は代わりにセマフォ構造を検討したほうがよいかもしれません。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)により放棄されています。