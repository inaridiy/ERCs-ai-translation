---
original: 93b917f72074b651c84247ab201199e199acc357386fde3ea5bcab56e9b933e7
---

---
eip: 1077
title: スマートコントラクトコールのためのガスリレー
author: Alex Van de Sande <avsa@ethereum.org>, Ricardo Guilherme Schmidt (@3esmit)
discussions-to: https://ethereum-magicians.org/t/erc1077-and-1078-the-magic-of-executable-signed-messages-to-login-and-do-actions/351
status: 停滞
type: Standards Track
category: ERC
created: 2018-05-04
requires: 20, 191, 1271, 1344
---


## 簡単な要約

スマートコントラクトの上でのガス抽象化のための標準インターフェースです。

ユーザーが[EIP-20]トークンを使ってコールに使用されたガスを支払うことを可能にします。

## 概要

DAppの採用の主な障壁は、チェーン上のアクションを実行するために複数のトークンが必要なことです。ユーザーが実行の意思を示すメッセージに署名することを許可し、第三者のリレーヤーにそれらを実行させることで、この問題を回避できます。ETHはイーサリアムトランザクションに常に必要とされますが、スマートコントラクトは[EIP-191]署名を受け取り、トランザクションを実行するための報酬をETHで信頼できない当事者に転送することができます。

## 動機

共通のフォーマットを標準化し、ユーザーがトークンでトランザクションを支払えるようにすることで、アプリ開発者に大きな柔軟性を与え、ユーザーがブロックチェーンと対話する主要な方法になる可能性があります。

## 仕様

### メソッド

#### executeGasRelay

現在の `lastNonce()` を使って `_execData` を実行し、指定された `_gasToken` でガス代を `msg.sender` に支払います。

```solidity
function executeGasRelay(bytes calldata _execData, uint256 _gasPrice, uint256 _gasLimit, address _gasToken, address _gasRelayer, bytes calldata _signature) external;	
```

### executeGasRelayMsg

署名メッセージに使用される `executeGasRelay` メッセージを返します。

```solidity
function executeGasRelayMsg(uint256 _nonce, bytes memory _execData, uint256 _gasPrice, uint256 _gasLimit, address _gasToken, address _gasRelayer) public pure returns (bytes memory);
```

#### executeGasRelayERC191Msg

署名メッセージと実行の検証に使用される [EIP-191] の `executeGasRelayMsg` を返します。

```solidity
function executeGasRelayERC191Msg(uint256 _nonce, bytes memory _execData, uint256 _gasPrice, uint256 _gasLimit, address _gasToken, address _gasRelayer) public view returns (bytes memory);
```

#### lastNonce

ガスリレーメッセージの現在のノンスを返します。

```solidity
function lastNonce() public returns (uint nonce);
```

### 署名メッセージ

署名メッセージには以下のフィールドが必要です:

* ノンス: ノンス *または* タイムスタンプ;
* 実行データ: アカウントコントラクトによって実行されるバイトコード;
* ガス価格: ガス価格 (選択したトークンで支払われます);
* ガス制限: リレーされた実行に予約されたガス;
* ガストークン: ガスが支払われるトークン (イーサの場合は0);
* ガスリレーヤー: このコールのガス払い戻しの受益者 (0の場合は `block.coinbase`) 。

#### メッセージの署名

メッセージは [EIP-191] 標準に従って署名**しなければならず**、呼び出されるコントラクトも [EIP-1271] を実装し、署名メッセージを検証**しなければならない**。

メッセージは実行するアカウントコントラクトの所有者によって署名**しなければならない**。所有者がコントラクトの場合は、[EIP-1271] インターフェースを実装し、検証を転送しなければならない。

準拠するためには、トランザクションが "messageHash" に署名するよう要求**しなければならない**。これは複数のフィールドの連結です。

フィールドは以下の方法で構築**しなければならない**:

最初の2つのフィールドは [EIP-191] に準拠させるためのものです。トランザクションを `byte(0x19)` で始めることで、署名データが[有効なイーサリアムトランザクション](https://github.com/ethereum/wiki/wiki/RLP)であることを保証します。2番目の引数はバージョン管理バイトです。3番目は [EIP-191] のバージョン0に従ったバリデーターアドレス(アカウントコントラクトアドレス)です。残りの引数がガスリレーのアプリケーション固有のデータです: [EIP-1344]に従ったchainID、実行ノンス、実行データ、合意ガス価格、ガスリレーコールのガス制限、ガストークン、ガスリレーの報酬を受け取る権限を持つアドレス。

[EIP-191]メッセージは以下のように構築**しなければならない**:
```solidity
keccak256(
	abi.encodePacked(
        byte(0x19), //ERC-191 - the initial 0x19 byte
        byte(0x0), //ERC-191 - the version byte
        address(this), //ERC-191 - version data (validator address)
        chainID,
        bytes4(
            keccak256("executeGasRelay(uint256,bytes,uint256,uint256,address,address)")
        ),
        _nonce, 
        _execData,
        _gasPrice,
        _gasLimit,
        _gasToken,
        _gasRelayer
    )
)
```

## 根拠

ユーザーの痛点:

* ユーザーはイーサについて考えたくない
* ユーザーは秘密鍵やシードフレーズのバックアップについて考えたくない
* ユーザーはすでにシステム上にあるものを使ってトランザクションを支払いたい(Apple Pay、Xbox ポイントや、クレジットカードなど)
* ユーザーは毎回新しいトランザクションに署名したくない
* ユーザーはアプリ/拡張機能(デスクトップ上少なくとも)をダウンロードしたくない

アプリ開発者の痛点:
* 多くのアプリが独自のトークンを使用し、それらをメインの会計として使いたがる
* アプリは複数のプラットフォームで使えるようにしたいが、デバイス間で秘密鍵を共有したり、資金を移動するためのトランザクションコストを払いたくない
* トークン開発者はユーザーがトークンでお金を動かしたり手数料を払えるようにしたい
* システムが鉱夫のための手数料と報酬を提供する一方で、ウォレット開発者(やその他多くのトランザクションを開始するアプリ)にはビジネスモデルがない

署名メッセージ、特に資金を保持するアカウントコントラクトと、代わりに署名できる複数の使い捨てのイーサレスキーを組み合わせることで、これらの痛点の多くが解決できます。

### 複数の署名

同じパラメータを持つ複数の署名トランザクションを同時に `messageSignatures` フィールドで渡すことで、1つの関数で実行できます。その分野は署名を72文字の個別の署名に分割し、それぞれを評価します。これは、1つのアクションに複数の当事者の承認が必要な場合に使用されます。

複数の署名が必要な場合、すべての署名は *アカウントごとに順序付け* され、アカウントコントラクトは [EIP-1271] インターフェースで局所的に署名チェック(`JUMP`)を実装し、署名チェックを所有者コントラクトに転送(`STATIC_CALL`)する必要があります。

### ノンスを追跡する:

`executeGasRelay` 関数は `_nonce` パラメータを取りません。コントラクトは現在のノンスを知っており、順番にのみトランザクションを実行できるため、理由はありません。

ノンスは通常のイーサリアムトランザクションと同様に機能します: トランザクションは最後のノンス + 1と一致する場合にのみ実行できます。トランザクションが発生すると、`lastNonce` が現在のものに更新されます。これにより、トランザクションが順序外れで実行されたり、複数回実行されるのを防ぐことができます。

コントラクトはノンスなしのトランザクション(ノンス = 0)を受け入れる場合があります。その場合、コントラクトは再生を防ぐためにトランザクションのフルハッシュを保持する必要があります。これにより、ユーザーが将来実行したいが、その時点のノンスを知ることができない、または状態チャネルコントラクトでのみ実行される(または争いがある場合にのみ実行される)トランザクションなど、より柔軟性が高くなります。

### トランザクションの実行

署名の検証後、`_execBytes` の評価はアカウントコントラクトの実装次第です。ウォレットの役割は適切にアカウントコントラクトとそのガスリレー方式を使うことです。
一般的なパターンは、コントラクト自体からのみ呼び出せるインターフェースを公開することです。`_execData` はこの方法で完全に転送できます。例:

`address(this).call.gas(_gasLimit)(_execData);`

ここで `_execData` は、コントラクト自体のメソッドを呼び出すことができます。例:

- `call(address to, uint256 value, bytes data)`: あらゆるタイプのイーサリアムコールを実行できます。
- `create(uint256 value, bytes deployData)`: コントラクトの作成を可能にします。
- `create2(uint256 value, bytes32 salt, bytes deployData)`: 決定論的アドレスでコントラクトを作成できます。
- `approveAndCall(address token, address to, uint256 value, bytes data)`: ERC20トークンの安全な承認とコールを可能にします。
- `delegatecall(address codeBase, bytes data)`: 他のコントラクトに保存されたコードを実行できます。
- `changeOwner(address newOwner)`: 一部のアカウントコントラクトでは所有者の変更を許可します。
- `foo(bytes bar)`: アカウントコントラクトにカスタムメソッドがある場合があります。

アカウントコントラクトの標準化はこのERCの範囲外ですが、可能な実装の例として示しています。
`_execBytes` の評価をself callで行うのは必須ではなく、アカウントコントラクトのロジックに応じて、ローカルで評価することもできます。

### ガスの会計と払い戻し

実装コントラクトはガス消費を追跡する必要があります。1つの方法は、関数の最初に `gasLeft()` を呼び出し、目的のアクションの実行後に差を比較することです。

その後、コントラクトは `gasSpent * gasPrice` の値をトークン(または `tokenAddress` がnilの場合はイーサ)で `_gasRelayer` (メッセージをデプロイしたアカウント)に転送します。

`_gasRelayer` がゼロの場合、資金は **必ず** `block.coinbase` に行きます。

資金が不足している場合や、合計が `gasLimit` を超える場合は、トランザクションを **必ず** 元に戻す必要があります。

実行されたトランザクションが内部的に失敗した場合でも、ノンスは更新され、ガスを支払う必要があります。

コントラクトは、イーサや自分が選択したいくつかのトークンのみをサポートするように実装する必要はありません。

### 使用例

このスキームは、インタラクションや様々なビジネスモデルの実験に大きな可能性を開きます:

* アプリは、実際の資金を保持するユーザー専用のアイデンティティコントラクトを作成し、ログインする各デバイスに異なる秘密鍵を作成できます。他のアプリは同じアイデンティティを使用し、デバイスの管理用の許可付きの公開鍵の追加を要求するだけで、個別の鍵が失われても、イーサは失われません。
* アプリは独自のトークンを作成し、イーサリアムトランザクションのすべてをその内部通貨でのみ課金できます。通貨単位は、標準的なトランザクションが常に1トークン、非常に複雑なトランザクションが正確に2トークンなどのように、実際の取引量に似るように丸めることができます。アプリが取引の発行者であるため、Sybil検証を自分で行い、新規ユーザーに無料の通貨単位を提供できます。
* ゲーム会社がクレジットカードや特定のプラットフォームのマイクロトランザク
ションによる従来の月額サブスクリプションを持つゲームを作成します。秘密鍵はデバイスから離れることはなく、イーサを保持せず、公開アカウントのみがその会社に送信されます。その後、ゲームはガス価格0でデバイス上でトランザクションに署名し、それらを会社に送信します。会社は活性化したサブスクライバーをチェックし、すべてのトランザクションをバッチ処理し、自分でイーサを支払います。会社が倒産した場合、ゲーマー自身が同様のサブスクリプションシステムを設定するか、ガス価格を上げるだけです。最終的な結果は、**ユーザーがApple、Google、Xboxクレジットを使ってプレイできるイーサリアムベースのゲーム**です。

* ユーザーがイーサを保持する必要のないスタンダードトークンが作成されます。代わりに、トークンでトランザクションを支払うことができます。ユーザーがメッセージに署名し、それらをWhisperネットワークに送信するウォレットが作成されます。他のノードはそれらのトランザクションをダウンロードし、現在のガス価格をチェックし、トークンで十分な支払いをしているものを選択できます。**その結果、ユーザーがイーサを保持する必要がなく、トークン自体で手数料を支払えるトークンが得られます。**

* 従業員のアカウントのリストを持つDAOが作成されます。従業員はイーサを所有する必要がなく、代わりにメッセージに署名し、それらをWhisperに送信して分散型のリレーヤーリストに送信します。DAOコントラクトはその後、トランザクションが有効かどうかを確認し、デプロイヤーにイーサを送ります。従業員は会社のリソースを多く使わないインセンティブがあります。その結果、ユーザーがイーサを保持する必要がなく、**コントラクトが自分のガス使用量を支払うことになります。**

## 下位互換性

下位互換性の問題はありませんが、将来のアップグレードのために、`_execData` には任意のデータが含まれており、それをアカウントコントラクトが適切に処理する必要があるため、現在のインターフェースでガスリレーのあらゆる動作を行うことができます。

## テストケース

TBD

## 実装

このようなコントラクトの初期実装は、[Status.im account-contracts リポジトリ](https://github.com/status-im/account-contracts/blob/develop/contracts/account/AccountGasAbstract.sol)にあります。

Gnosis Safeバリアントの別のバージョンは https://github.com/status-im/safe-contracts にあります。

### 類似の実装

署名メッセージを実行可能な意図として使用するアイデアは以前から存在しており、多くの他のプロジェクトが同様のアプローチを取っているため、相互運用性を保証する優れた候補となっています:

* [EIP-877](https://github.com/ethereum/EIPs/pull/877) プロトコルの変更を伴う同様の試み
* [Status](https://github.com/status-im/ideas/issues/73)
* [Aragon](https://github.com/aragonlabs/pay-protocol) (この分野での取り組みを示す最良のリンクではない可能性があります)
* [事前承認アクションのためのトークン標準関数](https://github.com/ethereum/EIPs/issues/662)
* [トークン標準拡張865](https://github.com/ethereum/EIPs/issues/865)
* [Iuri Matias: トランザクションリレー](https://github.com/iurimatias/TransactionRelay)
* [uPort: メタトランザクション](https://github.com/uport-project/uport-identity#send-a-meta-tx)
* [uPort: 安全なアイデンティティ](https://github.com/uport-project/uport-identity/blob/develop/docs/txRelay.md)
* [Gnosis safe contracts](https://github.com/gnosis/safe-contracts)

Swarm cityは、[Gas Station Service](https://github.com/swarmcity/SCLabs-gasstation-service)と呼ばれるイーサレストランザクションのための同様の提案を使用していますが、アプローチが異なります。署名メッセージを使う代わりに、伝統的なイーサリアムトランザクションがイーサレスアカウントで署名され、トランザクションはすぐにイーサの正確な量を送信し、その後トランザクションを公開するサービスに送信されます。

## セキュリティ上の考慮事項

トランザクションのデプロイヤー(リレーヤー)は信頼できないコントラクトを呼び出すことができますが、標準を正しく実装し、ガスの払い戻しを受けることを保証するものはありません。悪い実装に騙されないように、リレーヤーは**トランザクションの結果を見積もる必要があり**、望ましい結果のあるトランザクションのみを含めて/署名する必要があります。

リレーヤーが相互作用するコントラクトの私的な評判を維持し、どのトークンとどのガス価格で取引を展開するかを追跡することも重要な利益です。

## 著作権

著作権およびその関連権利は [CC0](../LICENSE.md) で放棄されています。

## 参考文献

* [Universal Logins talk at UX Unconf, Toronto](https://www.youtube.com/watch?v=qF2lhJzngto)

[EIP-20]: ./eip-20.md
[EIP-191]: ./eip-191.md
[EIP-1271]: ./eip-1271.md
[EIP-1344]: ./eip-1344.md