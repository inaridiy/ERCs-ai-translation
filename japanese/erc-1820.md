---
original: d443362a7379d69d999c979e094481ee8e993c6081be715ece13fbe1ac3bed62
---

---
eip: 1820
title: 疑似内省レジストリコントラクト
author: Jordi Baylina <jordi@baylina.cat>, Jacques Dafflon <mail@0xjac.com>
discussions-to: https://github.com/ethereum/EIPs/pull/1820
status: Final
type: Standards Track
category: ERC
requires: 165, 214
created: 2019-03-04
---

> :information_source: **[ERC-1820]は[ERC-820]に取って代わりました。** :information_source:  
> [ERC-1820]は、Solidity 0.5のアップデートによって導入された[ERC-165]ロジックの非互換性を修正しています。  
> [公式アナウンス][erc1820-annoucement]と、[バグ][erc820-bug]と[修正][erc820-fix]に関するコメントをご覧ください。  
> この修正以外は、[ERC-1820]は[ERC-820]と機能的に同等です。
>
> :warning: [ERC-1820]は[ERC-820]の代わりに使用する必要があります。 :warning:

## 簡単な要約

このスタンダードは、任意のアドレス(コントラクトまたは通常のアカウント)が、どのインターフェースをサポートし、どのスマートコントラクトがその実装を担当しているかを登録できる、ユニバーサルなレジストリスマートコントラクトを定義しています。

このスタンダードは[ERC-165]との下位互換性を維持しています。

## 概要

このスタンダードは、スマートコントラクトと通常のアカウントが、直接または代理コントラクトを通じて実装する機能を公開するレジストリを定義しています。

誰でもこのレジストリに問い合わせて、特定のアドレスが特定のインターフェースを実装しているかどうか、およびその実装を担当するスマートコントラクトを確認することができます。

このレジストリは任意のチェーンにデプロイできますが、すべてのチェーンで同じアドレスを共有します。

最後の28バイトがゼロ(`0`)のインターフェースは[ERC-165]インターフェースと見なされ、このレジストリはそのコントラクトに呼び出しを転送して、そのインターフェースを実装しているかどうかを確認します。

このコントラクトは[ERC-165]キャッシュとしても機能し、ガス消費を削減します。

## 動機

Ethereumでは疑似内省を定義するためのさまざまなアプローチがありました。
最初の[ERC-165]は、通常のアカウントでは使用できないという制限がありました。
2番目の試みは[ERC-672]で、逆引き[ENS]を使用していました。逆引き[ENS]には2つの問題がありました。
1つ目は不必要に複雑であること、2つ目は[ENS]がマルチシグにより制御されている中央集権的なコントラクトであり、このマルチシグが理論的にはシステムを変更できるということです。

このスタンダードは[ERC-672]よりもはるかに単純で、*完全に*分散化されています。

このスタンダードは、すべてのチェーンで*一意の*アドレスを提供することで、異なるチェーンのレジストリアドレスを解決する問題も解決しています。

## 仕様

### [ERC-1820] レジストリスマートコントラクト

> これは[ERC1820レジストリスマートコントラクト]のコードの正確なコピーです。

``` solidity
/* ERC1820 Pseudo-introspection Registry Contract
 * This standard defines a universal registry smart contract where any address (contract or regular account) can
 * register which interface it supports and which smart contract is responsible for its implementation.
 *
 * Written in 2019 by Jordi Baylina and Jacques Dafflon
 *
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to
 * this software to the public domain worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see
 * <http://creativecommons.org/publicdomain/zero/1.0/>.
 *
 *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗
 *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗
 *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║
 *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║
 *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝
 *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝
 *
 *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗
 *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝
 *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝
 *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝
 *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║
 *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝
 *
 */
pragma solidity 0.5.3;
// IV is value needed to have a vanity address starting with '0x1820'.
// IV: 53759

/// @dev The interface a contract MUST implement if it is the implementer of
/// some (other) interface for any address other than itself.
interface ERC1820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}


/// @title ERC1820 Pseudo-introspection Registry Contract
/// @author Jordi Baylina and Jacques Dafflon
/// @notice This contract is the official implementation of the ERC1820 Registry.
/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820
contract ERC1820Registry {
    /// @notice ERC165 Invalid ID.
    bytes4 constant internal INVALID_ID = 0xffffffff;
    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).
    bytes4 constant internal ERC165ID = 0x01ffc9a7;
    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));

    /// @notice mapping from addresses and interface hashes to their implementers.
    mapping(address => mapping(bytes32 => address)) internal interfaces;
    /// @notice mapping from addresses to their manager.
    mapping(address => address) internal managers;
    /// @notice flag for each address and erc165 interface to indicate if it is cached.
    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;

    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.
    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.
    event ManagerChanged(address indexed addr, address indexed newManager);

    /// @notice Query if an address implements an interface and through which contract.
    /// @param _addr Address being queried for the implementer of an interface.
    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
    /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
    /// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'
    /// or '0' if '_addr' did not register an implementer for this interface.
    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
        address addr = _addr == address(0) ? msg.sender : _addr;
        if (isERC165Interface(_interfaceHash)) {
            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);
        }
        return interfaces[addr][_interfaceHash];
    }

    /// @notice Sets the contract which implements a specific interface for an address.
    /// Only the manager defined for that address can set it.
    /// (Each address is the manager for itself until it sets a new manager.)
    /// @param _addr Address for which to set the interface.
    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
    /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
    /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == address(0) ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, "Not the manager");

        require(!isERC165Interface(_interfaceHash), "Must not be an ERC165 hash");
        if (_implementer != address(0) && _implementer != msg.sender) {
            require(
                ERC1820ImplementerInterface(_implementer)
                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,
                "Does not implement the interface"
            );
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    /// @notice Sets '_newManager' as manager for '_addr'.
    /// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.
    /// @param _addr Address for which to set the new manager.
    /// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)
    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, "Not the manager");
        managers[_addr] = _newManager == _addr ? address(0) : _newManager;
        emit ManagerChanged(_addr, _newManager);
    }

    /// @notice Get the manager of an address.
    /// @param _addr Address for which to return the manager.
    /// @return Address of the manager for a given address.
    function getManager(address _addr) public view returns(address) {
        // By default the manager of an address is the same address
        if (managers[_addr] == address(0)) {
            return _addr;
        } else {
            return managers[_addr];
        }
    }

    /// @notice Compute the keccak256 hash of an interface given its name.
    /// @param _interfaceName Name of the interface.
    /// @return The keccak256 hash of an interface name.
    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {
        return keccak256(abi.encodePacked(_interfaceName));
    }

    /* --- ERC165 Related Functions --- */
    /* --- Developed in collaboration with William Entriken. --- */

    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.
    /// @param _contract Address of the contract for which to update the cache.
    /// @param _interfaceId ERC165 interface for which to update the cache.
    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(
            _contract, _interfaceId) ? _contract : address(0);
        erc165Cached[_contract][_interfaceId] = true;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not.
    //  If the result is not cached a direct lookup on the contract address is performed.
    //  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling
    //  'updateERC165Cache' with the contract address.
    /// @param _contract Address of the contract to check.
    /// @param _interfaceId ERC165 interface to check.
    /// @return True if '_contract' implements '_interfaceId', false otherwise.
    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
        if (!erc165Cached[_contract][_interfaceId]) {
            return implementsERC165InterfaceNoCache(_contract, _interfaceId);
        }
        return interfaces[_contract][_interfaceId] == _contract;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.
    /// @param _contract Address of the contract to check.
    /// @param
_interfaceId ERC165 interface to check.
/// @return True if '_contract' implements '_interfaceId', false otherwise.
function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
    uint256 success;
    uint256 result;

    (success, result) = noThrowCall(_contract, ERC165ID);
    if (success == 0 || result == 0) {
        return false;
    }

    (success, result) = noThrowCall(_contract, INVALID_ID);
    if (success == 0 || result != 0) {
        return false;
    }

    (success, result) = noThrowCall(_contract, _interfaceId);
    if (success == 1 && result == 1) {
        return true;
    }
    return false;
}

/// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.
/// @param _interfaceHash The hash to check.
/// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.
function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
    return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
}

/// @dev Make a call on a contract without throwing if the function does not exist.
function noThrowCall(address _contract, bytes4 _interfaceId)
    internal view returns (uint256 success, uint256 result)
{
    bytes4 erc165ID = ERC165ID;

    assembly {
        let x := mload(0x40)               // Find empty storage location using "free memory pointer"
        mstore(x, erc165ID)                // Place signature at beginning of empty storage
        mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature

        success := staticcall(
            30000,                         // 30k gas
            _contract,                     // To addr
            x,                             // Inputs are stored at location x
            0x24,                          // Inputs are 36 (4 + 32) bytes long
            x,                             // Store output over input (saves space)
            0x20                           // Outputs are 32 bytes long
        )

        result := mload(x)                 // Load the result
    }
}

```

### デプロイメントトランザクション

以下は、任意のチェーンにスマートコントラクトをデプロイするために使用しなければならない生のトランザクションです。

```
0xf90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a01820182018201820182018201820182018201820182018201820182018201820
```

トランザクションの最後の`1820`の文字列は、署名の`r`と`s`です。
この決定論的なパターン(人間が生成したもの)から、誰もがデプロイメントアカウントの秘密鍵を知らないことを推測できます。

### デプロイメント方法

このコントラクトは、[Nick]のメソッドとも呼ばれる、キーレスデプロイメント方式を使ってデプロイされます。これは、使い捨てアドレスに依存しています。
([Nick の記事]の詳細をご覧ください)。この方法は以下のように動作します:

1. 新しいランダムなアカウントからコントラクトをデプロイするトランザクションを生成します。
  - このトランザクションは[EIP-155]を使用してはいけません。
  - このトランザクションは、任意のチェーンにデプロイするために、比較的高いガス価格を持っている必要があります。この場合は100 Gweiです。

2. トランザクション署名の`v`、`r`、`sを以下の値に設定します:

   ```
   v: 27,
   r: 0x1820182018201820182018201820182018201820182018201820182018201820'
   s: 0x1820182018201820182018201820182018201820182018201820182018201820'
   ```

   これらの`r`と`s`の値は、`1820`の繰り返しパターンで構成されており、人間によって決定論的に生成された「ランダムな数字」です。

3. このトランザクションの送信者、つまり使い捨てデプロイメントアカウントを復元します。

    > したがって、このトランザクションを配信できるアカウントを取得できますが、そのアカウントの秘密鍵を誰も知らないことも保証されます。

4. この使い捨てデプロイメントアカウントに正確に0.08 etherを送金します。

5. デプロイメントトランザクションを配信します。

この操作は任意のチェーンで行うことができ、コントラクトアドレスが常に同じであり、誰もが別のコントラクトでそのアドレスを使用できないことを保証します。


### 使い捨てレジストリデプロイメントアカウント

```
0xa990077c3205cbDf861e17Fa532eeB069cE9fF96
```

このアカウントは、その署名から逆算して生成されています。
つまり、誰もがその秘密鍵を知りませんが、デプロイメントトランザクションの有効な署名者であることが分かります。

> レジストリをデプロイするには、まず0.08 etherをこのアカウントに送る必要があります。

### レジストリコントラクトアドレス

```
0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
```

このコントラクトは、デプロイされるすべてのチェーンで上記のアドレスを持ちます。

<details>
<summary><code>./contracts/ERC1820Registry.sol</code>の生のメタデータ</summary>

```json
{
        "compiler": {
          "version": "0.5.3+commit.10d17f24"
        },
        "language": "Solidity",
        "output": {
          "abi": [
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                },
                {
                  "name": "_implementer",
                  "type": "address"
                }
              ],
              "name": "setInterfaceImplementer",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                }
              ],
              "name": "getManager",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_newManager",
                  "type
": "address"
                }
              ],
              "name": "setManager",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_interfaceName",
                  "type": "string"
                }
              ],
              "name": "interfaceHash",
              "outputs": [
                {
                  "name": "",
                  "type": "bytes32"
                }
              ],
              "payable": false,
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "updateERC165Cache",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                }
              ],
              "name": "getInterfaceImplementer",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165InterfaceNoCache",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165Interface",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "interfaceHash",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "implementer",
                  "type": "address"
                }
              ],
              "name": "InterfaceImplementerSet",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "newManager",
                  "type": "address"
                }
              ],
              "name": "ManagerChanged",
              "type": "event"
            }
          ],
          "devdoc": {
            "author": "Jordi Baylina and Jacques Dafflon",
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "params": {
                  "_addr": "Address being queried for the implementer of an interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                },
                "return": "The address of the contract which implements the interface '_interfaceHash' for '_addr' or '0' if '_addr' did not register an implementer for this interface."
              },
              "getManager(address)": {
                "params": {
                  "_addr": "Address for which to return the manager."
                },
                "return": "Address of the manager for a given address."
              },
              "implementsERC165Interface(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "interfaceHash(string)": {
                "params": {
                  "_interfaceName": "Name of the interface."
                },
                "return": "The keccak256 hash of an interface name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "params": {
                  "_addr": "Address for which to set the interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_implementer": "Contract address implementing '_interfaceHash' for '_addr'.",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                }
              },
              "setManager(address,address)": {
                "params": {
                  "_addr": "Address for which to set the new manager.",
                  "_newManager": "Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)"
                }
              },
              "updateERC165Cache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract for which to update the cache.",
                  "_interfaceId": "ERC165 interface for which to update the cache."
                }
              }
            },
            "title": "ERC1820 Pseudo-introspection Registry Contract"
          },
          "userdoc": {
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "notice": "Query if an address implements an interface and through which contract."
              },
              "getManager(address)": {
                "notice": "Get the manager of an address."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "notice": "Checks whether a contract implements an ERC165 interface or not without using nor updating the cache."
              },
              "interfaceHash(string)": {
                "notice": "Compute the keccak256 hash of an interface given its name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "notice": "Sets the contract which implements a specific interface for an address. Only the manager defined for that address can set it. (Each address is the manager for itself until it sets a new manager.)"
              },
              "setManager(address,address)": {
                "notice": "Sets '_newManager' as manager for '_addr'. The new manager will be able to call 'setInterfaceImplementer' for '_addr'."
              },
              "updateERC165Cache(address,bytes4)": {
                "notice": "Updates the cache with whether the contract implements an ERC165 interface or not."
              }
            },
            "notice": "This contract is the official implementation of the ERC1820 Registry.For more details, see https://eips.ethereum.org/EIPS/eip-1820"
          }
        },
        "settings": {
          "compilationTarget": {
            "./contracts/ERC1820Registry.sol": "ERC1820Registry"
          },
          "evmVersion": "byzantium",
          "libraries": {},
          "optimizer": {
            "enabled": true,
            "runs": 200
          },
          "remappings": []
        },
        "sources": {
          "./contracts/ERC1820Registry.sol": {
            "content": "/* ERC1820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\n * register which interface it supports and which smart contract is responsible for its implementation.\n *\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\n * this software to the public domain worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n *\n *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */
pragma solidity 0.5.3;
// IV is value needed to have a vanity address starting with '0x1820'.
// IV: 53759

/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.
interface ERC1820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}


/// @title ERC1820 Pseudo-introspection Registry Contract
/// @author Jordi Baylina and Jacques Dafflon
/// @notice This contract is the official implementation of the ERC1820 Registry.
/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820
contract ERC1820Registry {
    /// @notice ERC165 Invalid ID.
    bytes4 constant internal INVALID_ID = 0xffffffff;
    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;
    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));

    /// @notice mapping from addresses and interface hashes to their implementers.
    mapping(address => mapping(bytes32 => address)) internal interfaces;
    /// @notice mapping from addresses to their manager.
    mapping(address => address) internal managers;
    /// @notice flag for each address and erc165 interface to indicate if it is cached.
    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;

    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.
    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.
    event ManagerChanged(address indexed addr, address indexed newManager);

    /// @notice Query if an address implements an interface and through which contract.
    /// @param _addr Address being queried for the implementer of an interface.\n/// (If '_addr' is the zero address then 'msg.sender' is assumed.)
    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
    /// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'\n/// or '0' if '_addr' did not register an implementer for this interface.
    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
        address addr = _addr == address(0) ? msg.sender : _addr;
        if (isERC165Interface(_interfaceHash)) {
            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);
        }
        return interfaces[addr][_interfaceHash];
    }

    /// @notice Sets the contract which implements a specific interface for an address.\n/// Only the manager defined for that address can set it.\n/// (Each address is the manager for itself until it sets a new manager.)
    /// @
param _addr Address for which to set the interface.\n/// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n/// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.\n/// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
    address addr = _addr == address(0) ? msg.sender : _addr;
    require(getManager(addr) == msg.sender, "Not the manager");

    require(!isERC165Interface(_interfaceHash), "Must not be an ERC165 hash");
    if (_implementer != address(0) && _implementer != msg.sender) {
        require(
            ERC1820ImplementerInterface(_implementer)
                .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,
            "Does not implement the interface"
        );
    }
    interfaces[addr][_interfaceHash] = _implementer;
    emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
}

/// @notice Sets '_newManager' as manager for '_addr'.\n/// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.\n/// @param _addr Address for which to set the new manager.\n/// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)\n
function setManager(address _addr, address _newManager) external {
    require(getManager(_addr) == msg.sender, "Not the manager");
    managers[_addr] = _newManager == _addr ? address(0) : _newManager;
    emit ManagerChanged(_addr, _newManager);
}

/// @notice Get the manager of an address.\n/// @param _addr Address for which to return the manager.\n/// @return Address of the manager for a given address.
function getManager(address _addr) public view returns(address) {
    // By default the manager of an address is the same address
    if (managers[_addr] == address(0)) {
        return _addr;
    } else {
        return managers[_addr];
    }
}

/// @notice Compute the keccak256 hash of an interface given its name.\n/// @param _interfaceName Name of the interface.\n/// @return The keccak256 hash of an interface name.
function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {
    return keccak256(abi.encodePacked(_interfaceName));
}

/* --- ERC165 Related Functions --- */
/* --- Developed in collaboration with William Entriken. --- */

/// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n/// @param _contract Address of the contract for which to update the cache.\n/// @param _interfaceId ERC165 interface for which to update the cache.
function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
    interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(
        _contract, _interfaceId) ? _contract : address(0);
    erc165Cached[_contract][_interfaceId] = true;
}

/// @notice Checks whether a contract implements an ERC165 interface or not.\n//  If the result is not cached a direct lookup on the contract address is performed.\n//  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n//  'updateERC165Cache' with the contract address.
/// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
    if (!erc165Cached[_contract][_interfaceId]) {
        return implementsERC165InterfaceNoCache(_contract, _interfaceId);
    }
    return interfaces[_contract][_interfaceId] == _contract;
}

/// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n/// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
    uint256 success;
    uint256 result;

    (success, result) = noThrowCall(_contract, ERC165ID);
    if (success == 0 || result == 0) {
        return false;
    }

    (success, result) = noThrowCall(_contract, INVALID_ID);
    if (success == 0 || result != 0) {
        return false;
    }

    (success, result) = noThrowCall(_contract, _interfaceId);
    if (success == 1 && result == 1) {
        return true;
    }
    return false;
}

/// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n/// @param _interfaceHash The hash to check.\n/// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.
function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
    return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
}

/// @dev Make a call on a contract without throwing if the function does not exist.
function noThrowCall(address _contract, bytes4 _interfaceId)
    internal view returns (uint256 success, uint256 result)
{
    bytes4 erc165ID = ERC165ID;

    assembly {
        let x := mload(0x40)               // Find empty storage location using "free memory pointer"
        mstore(x, erc165ID)                // Place signature at beginning of empty storage
        mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature

        success := staticcall(
            30000,                         // 30k gas
            _contract,                     // To addr
            x,                             // Inputs are stored at location x
            0x24,                          // Inputs are 36 (4 + 32) bytes long
            x,                             // Store output over input (saves space)
            0x20                           // Outputs are 32 bytes long
        )

        result := mload(x)                 // Load the result
    }
}

```

### デプロイメントトランザクション

以下は、任意のチェーンにスマートコントラクトをデプロイするために使用しなければならない生のトランザクションです。

```
0xf90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee365b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a01820182018201820182018201820182018201820182018201820182018201820
```

トランザクションの最後の`1820`の文字列は、署名の`r`と`s`です。
この決定論的なパターン(人間が生成したもの)から、誰もがデプロイメントアカウントの秘密鍵を知らないことを推測できます。

### デプロイメント方法

このコントラクトは、[Nick]のメソッドとも呼ばれる、キーレスデプロイメント方式を使ってデプロイされます。これは、使い捨てアドレスに依存しています。
([Nick の記事]の詳細をご覧ください)。この方法は以下のように動作します:

1. 新しいランダムなアカウントからコントラクトをデプロイするトランザクションを生成します。
  - このトランザクションは[EIP-155]を使用してはいけません。
  - このトランザクションは、任意のチェーンにデプロイするために、比較的高いガス価格を持っている必要があります。この場合は100 Gweiです。

2. トランザクション署名の`v`、`r`、`sを以下の値に設定します:

   ```
   v: 27,
   r: 0x1820182018201820182018201820182018201820182018201820182018201820'
   s: 0x1820182018201820182018201820182018201820182018201820182018201820'
   ```

   これらの`r`と`s`の値は、`1820`の繰り返しパターンで構成されており、人間によって決定論的に生成された「ランダムな数字」です。

3. このトランザクションの送信者、つまり使い捨てデプロイメントアカウントを復元します。

    > したがって、このトランザクションを配信できるアカウントを取得できますが、そのアカウントの秘密鍵を誰も知らないことも保証されます。

4. この使い捨てデプロイメントアカウントに正確に0.08 etherを送金します。

5. デプロイメントトランザクションを配信します。

この操作は任意のチェーンで行うことができ、コントラクトアドレスが常に同じであり、誰もが別のコントラクトでそのアドレスを使用できないことを保証します。


### 使い捨てレジストリデプロイメントアカウント

```
0xa990077c3205cbDf861e17Fa532eeB069cE9fF96
```

このアカウントは、その署名から逆算して生成されています。
つまり、誰もがその秘密鍵を知りませんが、デプロイメントトランザクションの有効な署名者であることが分かります。

> レジストリをデプロイするには、まず0.08 etherをこのアカウントに送る必要があります。

### レジストリコントラクトアドレス

```
0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
```

このコントラクトは、デプロイされるすべてのチェーンで上記のアドレスを持ちます。

<details>
<summary><code>./contracts/ERC1820Registry.sol</code>の生のメタデータ</summary>

```json
{
        "compiler": {
          "version": "0.5.3+commit.10d17f24"
        },
        "language": "Solidity",
        "output": {
          "abi": [
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                },
                {
                  "name": "_implementer",
                  "type": "address"
                }
              ],
              "name": "setInterfaceImplementer",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                }
              ],
              "name": "getManager",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_newManager",
                  "type": "address"
                }
              ],
              "name": "setManager",
              "outputs": [],
"payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_interfaceName",
                  "type": "string"
                }
              ],
              "name": "interfaceHash",
              "outputs": [
                {
                  "name": "",
                  "type": "bytes32"
                }
              ],
              "payable": false,
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "updateERC165Cache",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                }
              ],
              "name": "getInterfaceImplementer",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165InterfaceNoCache",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165Interface",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "interfaceHash",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "implementer",
                  "type": "address"
                }
              ],
              "name": "InterfaceImplementerSet",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "newManager",
                  "type": "address"
                }
              ],
              "name": "ManagerChanged",
              "type": "event"
            }
          ],
          "devdoc": {
            "author": "Jordi Baylina and Jacques Dafflon",
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "params": {
                  "_addr": "Address being queried for the implementer of an interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                },
                "return": "The address of the contract which implements the interface '_interfaceHash' for '_addr' or '0' if '_addr' did not register an implementer for this interface."
              },
              "getManager(address)": {
                "params": {
                  "_addr": "Address for which to return the manager."
                },
                "return": "Address of the manager for a given address."
              },
              "implementsERC165Interface(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "interfaceHash(string)": {
                "params": {
                  "_interfaceName": "Name of the interface."
                },
                "return": "The keccak256 hash of an interface name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "params": {
                  "_addr": "Address for which to set the interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_implementer": "Contract address implementing '_interfaceHash' for '_addr'.",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                }
              },
              "setManager(address,address)": {
                "params": {
                  "_addr": "Address for which to set the new manager.",
                  "_newManager": "Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)"
                }
              },
              "updateERC165Cache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract for which to update the cache.",
                  "_interfaceId": "ERC165 interface for which to update the cache."
                }
              }
            },
            "title": "ERC1820 Pseudo-introspection Registry Contract"
          },
          "userdoc": {
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "notice": "Query if an address implements an interface and through which contract."
              },
              "getManager(address)": {
                "notice": "Get the manager of an address."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "notice": "Checks whether a contract implements an ERC165 interface or not without using nor updating the cache."
              },
              "interfaceHash(string)": {
                "notice": "Compute the keccak256 hash of an interface given its name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "notice": "Sets the contract which implements a specific interface for an address. Only the manager defined for that address can set it. (Each address is the manager for itself until it sets a new manager.)"
              },
              "setManager(address,address)": {
                "notice": "Sets '_newManager' as manager for '_addr'. The new manager will be able to call 'setInterfaceImplementer' for '_addr'."
              },
              "updateERC165Cache(address,bytes4)": {
                "notice": "Updates the cache with whether the contract implements an ERC165 interface or not."
              }
            },
            "notice": "This contract is the official implementation of the ERC1820 Registry.For more details, see https://eips.ethereum.org/EIPS/eip-1820"
          }
        },
        "settings": {
          "compilationTarget": {
            "./contracts/ERC1820Registry.sol": "ERC1820Registry"
          },
          "evmVersion": "byzantium",
          "libraries": {},
          "optimizer": {
            "enabled": true,
            "runs": 200
          },
          "remappings": []
        },
        "sources": {
          "./contracts/ERC1820Registry.sol": {
            "content": "/* ERC1820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\n * register which interface it supports and which smart contract is responsible for its implementation.\n *\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\n * this software to the public domain worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n *\n *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */
pragma solidity 0.5.3;
// IV is value needed to have a vanity address starting with '0x1820'.
// IV: 53759

/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.
interface ERC1820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}


/// @title ERC1820 Pseudo-introspection Registry Contract
/// @author Jordi Baylina and Jacques Dafflon
/// @notice This contract is the official implementation of the ERC1820 Registry.
/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820
contract ERC1820Registry {
    /// @notice ERC165 Invalid ID.
    bytes4 constant internal INVALID_ID = 0xffffffff;
    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;
    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));

    /// @notice mapping from addresses and interface hashes to their implementers.
    mapping(address => mapping(bytes32 => address)) internal interfaces;
    /// @notice mapping from addresses to their manager.
    mapping(address => address) internal managers;
    /// @notice flag for each address and erc165 interface to indicate if it is cached.
    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;

    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.
    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.
    event ManagerChanged(address indexed addr, address indexed newManager);

    /// @notice Query if an address implements an interface and through which contract.\n/// @param _addr Address being queried for the implementer of an interface.\n/// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n/// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.\n/// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'\n/// or '0' if '_addr' did not register an implementer for this interface.
    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
        address addr = _addr == address(0) ? msg.sender : _addr;
        if (isERC165Interface(_interfaceHash)) {
            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);
        }
        return interfaces[addr][_interfaceHash];
    }

    /// @notice Sets the contract which implements a specific interface for an address.\n/// Only the manager defined for that address can set it.\n/// (Each address is the manager for itself until it sets a new manager.)\n/// @param _addr Address for which to set the interface.\n/// (If '_addr' is the zero address then 'msg.sender'
is assumed.)\n/// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.\n/// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
    address addr = _addr == address(0) ? msg.sender : _addr;
    require(getManager(addr) == msg.sender, "Not the manager");

    require(!isERC165Interface(_interfaceHash), "Must not be an ERC165 hash");
    if (_implementer != address(0) && _implementer != msg.sender) {
        require(
            ERC1820ImplementerInterface(_implementer)
                .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,
            "Does not implement the interface"
        );
    }
    interfaces[addr][_interfaceHash] = _implementer;
    emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
}

/// @notice Sets '_newManager' as manager for '_addr'.\n/// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.\n/// @param _addr Address for which to set the new manager.\n/// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)\n
function setManager(address _addr, address _newManager) external {
    require(getManager(_addr) == msg.sender, "Not the manager");
    managers[_addr] = _newManager == _addr ? address(0) : _newManager;
    emit ManagerChanged(_addr, _newManager);
}

/// @notice Get the manager of an address.\n/// @param _addr Address for which to return the manager.\n/// @return Address of the manager for a given address.
function getManager(address _addr) public view returns(address) {
    // By default the manager of an address is the same address
    if (managers[_addr] == address(0)) {
        return _addr;
    } else {
        return managers[_addr];
    }
}

/// @notice Compute the keccak256 hash of an interface given its name.\n/// @param _interfaceName Name of the interface.\n/// @return The keccak256 hash of an interface name.
function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {
    return keccak256(abi.encodePacked(_interfaceName));
}

/* --- ERC165 Related Functions --- */
/* --- Developed in collaboration with William Entriken. --- */

/// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n/// @param _contract Address of the contract for which to update the cache.\n/// @param _interfaceId ERC165 interface for which to update the cache.
function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
    interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(
        _contract, _interfaceId) ? _contract : address(0);
    erc165Cached[_contract][_interfaceId] = true;
}

/// @notice Checks whether a contract implements an ERC165 interface or not.\n//  If the result is not cached a direct lookup on the contract address is performed.\n//  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n//  'updateERC165Cache' with the contract address.
/// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
    if (!erc165Cached[_contract][_interfaceId]) {
        return implementsERC165InterfaceNoCache(_contract, _interfaceId);
    }
    return interfaces[_contract][_interfaceId] == _contract;
}

/// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n/// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
    uint256 success;
    uint256 result;

    (success, result) = noThrowCall(_contract, ERC165ID);
    if (success == 0 || result == 0) {
        return false;
    }

    (success, result) = noThrowCall(_contract, INVALID_ID);
    if (success == 0 || result != 0) {
        return false;
    }

    (success, result) = noThrowCall(_contract, _interfaceId);
    if (success == 1 && result == 1) {
        return true;
    }
    return false;
}

/// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n/// @param _interfaceHash The hash to check.\n/// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.
function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
    return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
}

/// @dev Make a call on a contract without throwing if the function does not exist.
function noThrowCall(address _contract, bytes4 _interfaceId)
    internal view returns (uint256 success, uint256 result)
{
    bytes4 erc165ID = ERC165ID;

    assembly {
        let x := mload(0x40)               // Find empty storage location using "free memory pointer"
        mstore(x, erc165ID)                // Place signature at beginning of empty storage
        mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature

        success := staticcall(
            30000,                         // 30k gas
            _contract,                     // To addr
            x,                             // Inputs are stored at location x
            0x24,                          // Inputs are 36 (4 + 32) bytes long
            x,                             // Store output over input (saves space)
            0x20                           // Outputs are 32 bytes long
        )

        result := mload(x)                 // Load the result
    }
}

```

### デプロイメントトランザクション

以下は、任意のチェーンにスマートコントラクトをデプロイするために使用しなければならない生のトランザクションです。

```
0xf90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc365b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a01820182018201820182018201820182018201820182018201820182018201820
```

トランザクションの最後の`1820`の文字列は、署名の`r`と`s`です。
この決定論的なパターン(人間が生成したもの)から、誰もがデプロイメントアカウントの秘密鍵を知らないことを推測できます。

### デプロイメント方法

このコントラクトは、[Nick]のメソッドとも呼ばれる、キーレスデプロイメント方式を使ってデプロイされます。これは、使い捨てアドレスに依存しています。
([Nick の記事]の詳細をご覧ください)。この方法は以下のように動作します:

1. 新しいランダムなアカウントからコントラクトをデプロイするトランザクションを生成します。
  - このトランザクションは[EIP-155]を使用してはいけません。
  - このトランザクションは、任意のチェーンにデプロイするために、比較的高いガス価格を持っている必要があります。この場合は100 Gweiです。

2. トランザクション署名の`v`、`r`、`sを以下の値に設定します:

   ```
   v: 27,
   r: 0x1820182018201820182018201820182018201820182018201820182018201820'
   s: 0x1820182018201820182018201820182018201820182018201820182018201820'
   ```

   これらの`r`と`s`の値は、`1820`の繰り返しパターンで構成されており、人間によって決定論的に生成された「ランダムな数字」です。

3. このトランザクションの送信者、つまり使い捨てデプロイメントアカウントを復元します。

    > したがって、このトランザクションを配信できるアカウントを取得できますが、そのアカウントの秘密鍵を誰も知らないことも保証されます。

4. この使い捨てデプロイメントアカウントに正確に0.08 etherを送金します。

5. デプロイメントトランザクションを配信します。

この操作は任意のチェーンで行うことができ、コントラクトアドレスが常に同じであり、誰もが別のコントラクトでそのアドレスを使用できないことを保証します。


### 使い捨てレジストリデプロイメントアカウント

```
0xa990077c3205cbDf861e17Fa532eeB069cE9fF96
```

このアカウントは、その署名から逆算して生成されています。
つまり、誰もがその秘密鍵を知りませんが、デプロイメントトランザクションの有効な署名者であることが分かります。

> レジストリをデプロイするには、まず0.08 etherをこのアカウントに送る必要があります。

### レジストリコントラクトアドレス

```
0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
```

このコントラクトは、デプロイされるすべてのチェーンで上記のアドレスを持ちます。

<details>
<summary><code>./contracts/ERC1820Registry.sol</code>の生のメタデータ</summary>

```json
{
        "compiler": {
          "version": "0.5.3+commit.10d17f24"
        },
        "language": "Solidity",
        "output": {
          "abi": [
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                },
                {
                  "name": "_implementer",
                  "type": "address"
                }
              ],
              "name": "setInterfaceImplementer",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                }
              ],
              "name": "getManager",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_newManager",
                  "type": "address"
                }
              ],
              "name": "setManager",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_interfaceName",
                  "type": "string"
                }
              ],
              "name": "interfaceHash",
              "outputs": [
                {
                  "name": "",
                  "type": "bytes32"
                }
              ],
              "payable": false,
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name":
"_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "updateERC165Cache",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                }
              ],
              "name": "getInterfaceImplementer",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165InterfaceNoCache",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165Interface",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "interfaceHash",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "implementer",
                  "type": "address"
                }
              ],
              "name": "InterfaceImplementerSet",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "newManager",
                  "type": "address"
                }
              ],
              "name": "ManagerChanged",
              "type": "event"
            }
          ],
          "devdoc": {
            "author": "Jordi Baylina and Jacques Dafflon",
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "params": {
                  "_addr": "Address being queried for the implementer of an interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                },
                "return": "The address of the contract which implements the interface '_interfaceHash' for '_addr' or '0' if '_addr' did not register an implementer for this interface."
              },
              "getManager(address)": {
                "params": {
                  "_addr": "Address for which to return the manager."
                },
                "return": "Address of the manager for a given address."
              },
              "implementsERC165Interface(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "interfaceHash(string)": {
                "params": {
                  "_interfaceName": "Name of the interface."
                },
                "return": "The keccak256 hash of an interface name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "params": {
                  "_addr": "Address for which to set the interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_implementer": "Contract address implementing '_interfaceHash' for '_addr'.",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                }
              },
              "setManager(address,address)": {
                "params": {
                  "_addr": "Address for which to set the new manager.",
                  "_newManager": "Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)"
                }
              },
              "updateERC165Cache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract for which to update the cache.",
                  "_interfaceId": "ERC165 interface for which to update the cache."
                }
              }
            },
            "title": "ERC1820 Pseudo-introspection Registry Contract"
          },
          "userdoc": {
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "notice": "Query if an address implements an interface and through which contract."
              },
              "getManager(address)": {
                "notice": "Get the manager of an address."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "notice": "Checks whether a contract implements an ERC165 interface or not without using nor updating the cache."
              },
              "interfaceHash(string)": {
                "notice": "Compute the keccak256 hash of an interface given its name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "notice": "Sets the contract which implements a specific interface for an address. Only the manager defined for that address can set it. (Each address is the manager for itself until it sets a new manager.)"
              },
              "setManager(address,address)": {
                "notice": "Sets '_newManager' as manager for '_addr'. The new manager will be able to call 'setInterfaceImplementer' for '_addr'."
              },
              "updateERC165Cache(address,bytes4)": {
                "notice": "Updates the cache with whether the contract implements an ERC165 interface or not."
              }
            },
            "notice": "This contract is the official implementation of the ERC1820 Registry.For more details, see https://eips.ethereum.org/EIPS/eip-1820"
          }
        },
        "settings": {
          "compilationTarget": {
            "./contracts/ERC1820Registry.sol": "ERC1820Registry"
          },
          "evmVersion": "byzantium",
          "libraries": {},
          "optimizer": {
            "enabled": true,
            "runs": 200
          },
          "remappings": []
        },
        "sources": {
          "./contracts/ERC1820Registry.sol": {
            "content": "/* ERC1820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\n * register which interface it supports and which smart contract is responsible for its implementation.\n *\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\n * this software to the public domain worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n *\n *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */
pragma solidity 0.5.3;
// IV is value needed to have a vanity address starting with '0x1820'.
// IV: 53759

/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.
interface ERC1820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}


/// @title ERC1820 Pseudo-introspection Registry Contract
/// @author Jordi Baylina and Jacques Dafflon
/// @notice This contract is the official implementation of the ERC1820 Registry.
/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820
contract ERC1820Registry {
    /// @notice ERC165 Invalid ID.
    bytes4 constant internal INVALID_ID = 0xffffffff;
    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;
    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));

    /// @notice mapping from addresses and interface hashes to their implementers.
    mapping(address => mapping(bytes32 => address)) internal interfaces;
    /// @notice mapping from addresses to their manager.
    mapping(address => address) internal managers;
    /// @notice flag for each address and erc165 interface to indicate if it is cached.
    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;

    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.
    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.
    event ManagerChanged(address indexed addr, address indexed newManager);

    /// @notice Query if an address implements an interface and through which contract.\n/// @param _addr Address being queried for the implementer of an interface.\n/// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n/// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.\n/// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'\n/// or '0' if '_addr' did not register an implementer for this interface.
    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
        address addr = _addr == address(0) ? msg.sender : _addr;
        if (isERC165Interface(_interfaceHash)) {
            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);
        }
        return interfaces[addr][_interfaceHash];
    }

    /// @notice Sets the contract which implements a specific interface for an address.\n/// Only the manager defined for that address can set it.\n/// (Each address is the manager for itself until it sets a new manager.)\n/// @param _addr Address for which to set the interface.\n/// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n/// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.\n/// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == address(0) ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, "Not the manager");

        require(!isERC165Interface(_interfaceHash
), "Must not be an ERC165 hash");
        if (_implementer != address(0) && _implementer != msg.sender) {
            require(
                ERC1820ImplementerInterface(_implementer)
                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,
                "Does not implement the interface"
            );
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    /// @notice Sets '_newManager' as manager for '_addr'.\n/// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.\n/// @param _addr Address for which to set the new manager.\n/// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)\n
    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, "Not the manager");
        managers[_addr] = _newManager == _addr ? address(0) : _newManager;
        emit ManagerChanged(_addr, _newManager);
    }

    /// @notice Get the manager of an address.\n/// @param _addr Address for which to return the manager.\n/// @return Address of the manager for a given address.
    function getManager(address _addr) public view returns(address) {
        // By default the manager of an address is the same address
        if (managers[_addr] == address(0)) {
            return _addr;
        } else {
            return managers[_addr];
        }
    }

    /// @notice Compute the keccak256 hash of an interface given its name.\n/// @param _interfaceName Name of the interface.\n/// @return The keccak256 hash of an interface name.
    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {
        return keccak256(abi.encodePacked(_interfaceName));
    }

    /* --- ERC165 Related Functions --- */
    /* --- Developed in collaboration with William Entriken. --- */

    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n/// @param _contract Address of the contract for which to update the cache.\n/// @param _interfaceId ERC165 interface for which to update the cache.
    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(
            _contract, _interfaceId) ? _contract : address(0);
        erc165Cached[_contract][_interfaceId] = true;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not.\n//  If the result is not cached a direct lookup on the contract address is performed.\n//  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n//  'updateERC165Cache' with the contract address.
    /// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
        if (!erc165Cached[_contract][_interfaceId]) {
            return implementsERC165InterfaceNoCache(_contract, _interfaceId);
        }
        return interfaces[_contract][_interfaceId] == _contract;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n/// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;

        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }

    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n/// @param _interfaceHash The hash to check.\n/// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.
    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
    }

    /// @dev Make a call on a contract without throwing if the function does not exist.
    function noThrowCall(address _contract, bytes4 _interfaceId)
        internal view returns (uint256 success, uint256 result)
    {
        bytes4 erc165ID = ERC165ID;

        assembly {
            let x := mload(0x40)               // Find empty storage location using "free memory pointer"
            mstore(x, erc165ID)                // Place signature at beginning of empty storage
            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature

            success := staticcall(
                30000,                         // 30k gas
                _contract,                     // To addr
                x,                             // Inputs are stored at location x
                0x24,                          // Inputs are 36 (4 + 32) bytes long
                x,                             // Store output over input (saves space)
                0x20                           // Outputs are 32 bytes long
            )

            result := mload(x)                 // Load the result
        }
    }

```

### デプロイメントトランザクション

以下は、任意のチェーンにスマートコントラクトをデプロイするために使用しなければならない生のトランザクションです。

```
0xf90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6365b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a01820182018201820182018201820182018201820182018201820182018201820
```

トランザクションの最後の`1820`の文字列は、署名の`r`と`s`です。
この決定論的なパターン(人間が生成したもの)から、誰もがデプロイメントアカウントの秘密鍵を知らないことを推測できます。

### デプロイメント方法

このコントラクトは、[Nick]のメソッドとも呼ばれる、キーレスデプロイメント方式を使ってデプロイされます。これは、使い捨てアドレスに依存しています。
([Nick の記事]の詳細をご覧ください)。この方法は以下のように動作します:

1. 新しいランダムなアカウントからコントラクトをデプロイするトランザクションを生成します。
  - このトランザクションは[EIP-155]を使用してはいけません。
  - このトランザクションは、任意のチェーンにデプロイするために、比較的高いガス価格を持っている必要があります。この場合は100 Gweiです。

2. トランザクション署名の`v`、`r`、`sを以下の値に設定します:

   ```
   v: 27,
   r: 0x1820182018201820182018201820182018201820182018201820182018201820'
   s: 0x1820182018201820182018201820182018201820182018201820182018201820'
   ```

   これらの`r`と`s`の値は、`1820`の繰り返しパターンで構成されており、人間によって決定論的に生成された「ランダムな数字」です。

3. このトランザクションの送信者、つまり使い捨てデプロイメントアカウントを復元します。

    > したがって、このトランザクションを配信できるアカウントを取得できますが、そのアカウントの秘密鍵を誰も知らないことも保証されます。

4. この使い捨てデプロイメントアカウントに正確に0.08 etherを送金します。

5. デプロイメントトランザクションを配信します。

この操作は任意のチェーンで行うことができ、コントラクトアドレスが常に同じであり、誰もが別のコントラクトでそのアドレスを使用できないことを保証します。


### 使い捨てレジストリデプロイメントアカウント

```
0xa990077c3205cbDf861e17Fa532eeB069cE9fF96
```

このアカウントは、その署名から逆算して生成されています。
つまり、誰もがその秘密鍵を知りませんが、デプロイメントトランザクションの有効な署名者であることが分かります。

> レジストリをデプロイするには、まず0.08 etherをこのアカウントに送る必要があります。

### レジストリコントラクトアドレス

```
0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
```

このコントラクトは、デプロイされるすべてのチェーンで上記のアドレスを持ちます。

<details>
<summary><code>./contracts/ERC1820Registry.sol</code>の生のメタデータ</summary>

```json
{
        "compiler": {
          "version": "0.5.3+commit.10d17f24"
        },
        "language": "Solidity",
        "output": {
          "abi": [
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                },
                {
                  "name": "_implementer",
                  "type": "address"
                }
              ],
              "name": "setInterfaceImplementer",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                }
              ],
              "name": "getManager",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_newManager",
                  "type": "address"
                }
              ],
              "name": "setManager",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_interfaceName",
                  "type": "string"
                }
              ],
              "name": "interfaceHash",
              "outputs": [
                {
                  "name": "",
                  "type": "bytes32"
                }
              ],
              "payable": false,
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "updateERC165Cache",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                }
              ],
              "name": "getInterfaceImplementer",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type":
"function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165InterfaceNoCache",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165Interface",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "interfaceHash",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "implementer",
                  "type": "address"
                }
              ],
              "name": "InterfaceImplementerSet",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "newManager",
                  "type": "address"
                }
              ],
              "name": "ManagerChanged",
              "type": "event"
            }
          ],
          "devdoc": {
            "author": "Jordi Baylina and Jacques Dafflon",
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "params": {
                  "_addr": "Address being queried for the implementer of an interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                },
                "return": "The address of the contract which implements the interface '_interfaceHash' for '_addr' or '0' if '_addr' did not register an implementer for this interface."
              },
              "getManager(address)": {
                "params": {
                  "_addr": "Address for which to return the manager."
                },
                "return": "Address of the manager for a given address."
              },
              "implementsERC165Interface(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "interfaceHash(string)": {
                "params": {
                  "_interfaceName": "Name of the interface."
                },
                "return": "The keccak256 hash of an interface name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "params": {
                  "_addr": "Address for which to set the interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_implementer": "Contract address implementing '_interfaceHash' for '_addr'.",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                }
              },
              "setManager(address,address)": {
                "params": {
                  "_addr": "Address for which to set the new manager.",
                  "_newManager": "Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)"
                }
              },
              "updateERC165Cache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract for which to update the cache.",
                  "_interfaceId": "ERC165 interface for which to update the cache."
                }
              }
            },
            "title": "ERC1820 Pseudo-introspection Registry Contract"
          },
          "userdoc": {
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "notice": "Query if an address implements an interface and through which contract."
              },
              "getManager(address)": {
                "notice": "Get the manager of an address."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "notice": "Checks whether a contract implements an ERC165 interface or not without using nor updating the cache."
              },
              "interfaceHash(string)": {
                "notice": "Compute the keccak256 hash of an interface given its name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "notice": "Sets the contract which implements a specific interface for an address. Only the manager defined for that address can set it. (Each address is the manager for itself until it sets a new manager.)"
              },
              "setManager(address,address)": {
                "notice": "Sets '_newManager' as manager for '_addr'. The new manager will be able to call 'setInterfaceImplementer' for '_addr'."
              },
              "updateERC165Cache(address,bytes4)": {
                "notice": "Updates the cache with whether the contract implements an ERC165 interface or not."
              }
            },
            "notice": "This contract is the official implementation of the ERC1820 Registry.For more details, see https://eips.ethereum.org/EIPS/eip-1820"
          }
        },
        "settings": {
          "compilationTarget": {
            "./contracts/ERC1820Registry.sol": "ERC1820Registry"
          },
          "evmVersion": "byzantium",
          "libraries": {},
          "optimizer": {
            "enabled": true,
            "runs": 200
          },
          "remappings": []
        },
        "sources": {
          "./contracts/ERC1820Registry.sol": {
            "content": "/* ERC1820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\n * register which interface it supports and which smart contract is responsible for its implementation.\n *\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\n * this software to the public domain worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n *\n *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */
pragma solidity 0.5.3;
// IV is value needed to have a vanity address starting with '0x1820'.
// IV: 53759

/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.
interface ERC1820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}


/// @title ERC1820 Pseudo-introspection Registry Contract
/// @author Jordi Baylina and Jacques Dafflon
/// @notice This contract is the official implementation of the ERC1820 Registry.
/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820
contract ERC1820Registry {
    /// @notice ERC165 Invalid ID.
    bytes4 constant internal INVALID_ID = 0xffffffff;
    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;
    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));

    /// @notice mapping from addresses and interface hashes to their implementers.
    mapping(address => mapping(bytes32 => address)) internal interfaces;
    /// @notice mapping from addresses to their manager.
    mapping(address => address) internal managers;
    /// @notice flag for each address and erc165 interface to indicate if it is cached.
    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;

    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.
    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.
    event ManagerChanged(address indexed addr, address indexed newManager);

    /// @notice Query if an address implements an interface and through which contract.\n/// @param _addr Address being queried for the implementer of an interface.\n/// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n/// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.\n/// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'\n/// or '0' if '_addr' did not register an implementer for this interface.
    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
        address addr = _addr == address(0) ? msg.sender : _addr;
        if (isERC165Interface(_interfaceHash)) {
            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);
        }
        return interfaces[addr][_interfaceHash];
    }

    /// @notice Sets the contract which implements a specific interface for an address.\n/// Only the manager defined for that address can set it.\n/// (Each address is the manager for itself until it sets a new manager.)\n/// @param _addr Address for which to set the interface.\n/// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n/// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n/// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.\n/// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == address(0) ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, "Not the manager");

        require(!isERC165Interface(_interfaceHash), "Must not be an ERC165 hash");
        if (_implementer != address(0) && _implementer != msg.sender) {
            require(
                ERC1820ImplementerInterface(_implementer)
                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,
                "Does not implement the interface"
            );
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    /// @notice Sets '_newManager' as manager for '_addr'.\n/// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.\n/// @param _addr Address for which to set the new manager.\n/// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)\n
    function setManager(address _addr
, address _newManager) external {
        require(getManager(_addr) == msg.sender, "Not the manager");
        managers[_addr] = _newManager == _addr ? address(0) : _newManager;
        emit ManagerChanged(_addr, _newManager);
    }

    /// @notice Get the manager of an address.\n/// @param _addr Address for which to return the manager.\n/// @return Address of the manager for a given address.
    function getManager(address _addr) public view returns(address) {
        // By default the manager of an address is the same address
        if (managers[_addr] == address(0)) {
            return _addr;
        } else {
            return managers[_addr];
        }
    }

    /// @notice Compute the keccak256 hash of an interface given its name.\n/// @param _interfaceName Name of the interface.\n/// @return The keccak256 hash of an interface name.
    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {
        return keccak256(abi.encodePacked(_interfaceName));
    }

    /* --- ERC165 Related Functions --- */
    /* --- Developed in collaboration with William Entriken. --- */

    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n/// @param _contract Address of the contract for which to update the cache.\n/// @param _interfaceId ERC165 interface for which to update the cache.
    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(
            _contract, _interfaceId) ? _contract : address(0);
        erc165Cached[_contract][_interfaceId] = true;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not.\n//  If the result is not cached a direct lookup on the contract address is performed.\n//  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n//  'updateERC165Cache' with the contract address.
    /// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
        if (!erc165Cached[_contract][_interfaceId]) {
            return implementsERC165InterfaceNoCache(_contract, _interfaceId);
        }
        return interfaces[_contract][_interfaceId] == _contract;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n/// @param _contract Address of the contract to check.\n/// @param _interfaceId ERC165 interface to check.\n/// @return True if '_contract' implements '_interfaceId', false otherwise.
    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;

        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }

    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n/// @param _interfaceHash The hash to check.\n/// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.
    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
    }

    /// @dev Make a call on a contract without throwing if the function does not exist.
    function noThrowCall(address _contract, bytes4 _interfaceId)
        internal view returns (uint256 success, uint256 result)
    {
        bytes4 erc165ID = ERC165ID;

        assembly {
            let x := mload(0x40)               // Find empty storage location using "free memory pointer"
            mstore(x, erc165ID)                // Place signature at beginning of empty storage
            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature

            success := staticcall(
                30000,                         // 30k gas
                _contract,                     // To addr
                x,                             // Inputs are stored at location x
                0x24,                          // Inputs are 36 (4 + 32) bytes long
                x,                             // Store output over input (saves space)
                0x20                           // Outputs are 32 bytes long
            )

            result := mload(x)                 // Load the result
        }
    }

```

### デプロイメントトランザクション

以下は、任意のチェーンにスマートコントラクトをデプロイするために使用しなければならない生のトランザクションです。

```
0xf90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6365b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a01820182018201820182018201820182018201820182018201820182018201820
```

トランザクションの最後の`1820`の文字列は、署名の`r`と`s`です。
この決定論的なパターン(人間が生成したもの)から、誰もがデプロイメントアカウントの秘密鍵を知らないことを推測できます。

### デプロイメント方法

このコントラクトは、[Nick]のメソッドとも呼ばれる、キーレスデプロイメント方式を使ってデプロイされます。これは、使い捨てアドレスに依存しています。
([Nick の記事]の詳細をご覧ください)。この方法は以下のように動作します:

1. 新しいランダムなアカウントからコントラクトをデプロイするトランザクションを生成します。
  - このトランザクションは[EIP-155]を使用してはいけません。
  - このトランザクションは、任意のチェーンにデプロイするために、比較的高いガス価格を持っている必要があります。この場合は100 Gweiです。

2. トランザクション署名の`v`、`r`、`sを以下の値に設定します:

   ```
   v: 27,
   r: 0x1820182018201820182018201820182018201820182018201820182018201820'
   s: 0x1820182018201820182018201820182018201820182018201820182018201820'
   ```

   これらの`r`と`s`の値は、`1820`の繰り返しパターンで構成されており、人間によって決定論的に生成された「ランダムな数字」です。

3. このトランザクションの送信者、つまり使い捨てデプロイメントアカウントを復元します。

    > したがって、このトランザクションを配信できるアカウントを取得できますが、そのアカウントの秘密鍵を誰も知らないことも保証されます。

4. この使い捨てデプロイメントアカウントに正確に0.08 etherを送金します。

5. デプロイメントトランザクションを配信します。

この操作は任意のチェーンで行うことができ、コントラクトアドレスが常に同じであり、誰もが別のコントラクトでそのアドレスを使用できないことを保証します。


### 使い捨てレジストリデプロイメントアカウント

```
0xa990077c3205cbDf861e17Fa532eeB069cE9fF96
```

このアカウントは、その署名から逆算して生成されています。
つまり、誰もがその秘密鍵を知りませんが、デプロイメントトランザクションの有効な署名者であることが分かります。

> レジストリをデプロイするには、まず0.08 etherをこのアカウントに送る必要があります。

### レジストリコントラクトアドレス

```
0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
```

このコントラクトは、デプロイされるすべてのチェーンで上記のアドレスを持ちます。

<details>
<summary><code>./contracts/ERC1820Registry.sol</code>の生のメタデータ</summary>

```json
{
        "compiler": {
          "version": "0.5.3+commit.10d17f24"
        },
        "language": "Solidity",
        "output": {
          "abi": [
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                },
                {
                  "name": "_implementer",
                  "type": "address"
                }
              ],
              "name": "setInterfaceImplementer",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                }
              ],
              "name": "getManager",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_newManager",
                  "type": "address"
                }
              ],
              "name": "setManager",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_interfaceName",
                  "type": "string"
                }
              ],
              "name": "interfaceHash",
              "outputs": [
                {
                  "name": "",
                  "type": "bytes32"
                }
              ],
              "payable": false,
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "updateERC165Cache",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                }
              ],
              "name": "getInterfaceImplementer",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165InterfaceNoCache",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165