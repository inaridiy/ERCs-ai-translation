---
original: c27169c0a17aa628eda92a2904b746970b7e467ad7c2ff3d0e106d0ed6b04cc5
---

---
eip: 6384
title: 人間可読のオフラインシグネチャ
description: EIP-712の型付きおよび構造化データの人間可読な説明を取得する方法。
author: Tal Be'ery <tal@zengo.com>, RoiV (@DeVaz1)
discussions-to: https://ethereum-magicians.org/t/eip-6384-readable-eip-712-signatures/12752
status: 停滞
type: Standards Track
category: ERC
created: 2023-01-08
requires: 712
---

## 概要

このEIPは、[EIP-712](./eip-712.md)バッファを受け取り、人間可読なテキストの説明を返す `evalEIP712Buffer` 関数を導入します。

## 動機

オフチェーントランザクション内で使用されることを意図したWeb3オフチェーンシグネチャの使用例が注目を集め、OpenSeaなどの主要なプロトコルや[EIP-2612](./eip-2612.md)などの標準で使用されるようになっています。これは主に手数料のかからない体験を提供するためです。
攻撃者は、ユーザーが人間には読めないオフチェーンメッセージに盲目的に署名するという事実を悪用して、積極的かつ成功裏にそのようなオフチェーンシグネチャを悪用することが知られています。
[EIP-712](./eip-712.md)は当初そのタイトルで"人間が読めること"を目標の1つとしていましたが、最終的にはその約束を果たすことはできませんでした。EIP-712メッセージは一般ユーザーには理解できません。

1つの例として、被害者が悪意のあるフィッシングWebサイトを閲覧します。そこでは、ユーザーにOpenSeaプラットフォームでNFTトークンを事実上無料で売却するメッセージに署名するよう要求されます。

一部の人気ウォレット実装のユーザーインターフェイスは、そのようなトランザクションに署名することの実際の意味を伝えていません。

この提案では、EIP-712メッセージの関連するスマートコントラクトを活用することで、EIP-712メッセージの真の人間可読性を実現する安全で拡張性のある方法を提供します。
その結果、この EIP が実装されると、ウォレットは現在の状態から次のようにユーザー体験を大幅に改善できます:

![](../assets/eip-6384/media/MiceyMask-non-compliant.png)

より明確なユーザー体験に:

![](../assets/eip-6384/media/ZenGo-EIP-compliant-warning.png)

提案されたソリューションは、ウォレットが `verifyingContract` に問い合わせることで、可読性の問題を解決します。EIP-712メッセージの説明を可能な限り正確に保つインセンティブは、説明の責任がコントラクトに委ねられることで整合しています。なぜなら、コントラクトは:

- メッセージの意味を正確に知っている(おそらくこのメッセージを受信したときにオンチェーンで処理するコードを再利用できる)
- 詐欺を防ぐために最良の説明を提供するよう自然に動機付けられている
- 信頼する必要のある第三者を含まない
- オンチェーンの実行とフィーを必要としない "view" モードの追加機能により、手数料のかからないカスタマー体験を維持する
- Web3の合成性を維持する

## 仕様

この文書の中の "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"、"OPTIONAL" というキーワードは、RFC 2119に記載されているように解釈されるものとします。

EIP-712は既に `verifyingContract` パラメータを使ってオフチェーンの署名をコントラクトに正式に結び付けています。我々は、そのようなコントラクトに、この特定のオフチェーンバッファの意味を人間が読める形で説明する "view" 関数を追加することを提案します。

```solidity
/**
 * @dev オフチェーンメッセージの期待される結果を返します。
*/

     function evalEIP712Buffer(bytes32 domainHash, string memory primaryType, bytes memory typedDataBuffer)
     external
     view
     returns (string[] memory) {
   ...

}
```

**準拠するすべてのコントラクトはこの関数を実装しなければなりません。**

この関数を使って、ウォレットは提案されたオフチェーンの署名をコントラクトに送信し、その結果をユーザーに表示することができ、オフチェーンメッセージに対するオンチェーンシミュレーション相当の体験を楽しむことができます。

この関数には既知の名前とシグネチャがあるため、EIP-712の構造に更新する必要はありません。

### 関数の入力

関数の入力:

- `domainHash` は EIP-712の `domainSeparator`、ハッシュ化された `eip712Domain` 構造体です。
- `primaryType` は EIP-712の `primaryType` です。
- `typedDataBuffer` は EIP-712全体のメッセージの一部であるABIエンコードされたメッセージです。

### 関数の出力

関数の出力は文字列の配列です。ウォレットはこれらを最終ユーザーに表示する必要があります。ウォレットは返された文字列に追加のデータ(例えばコントラクトアドレスを名前に解決する)を付加することができます。

文字列はフォーマットされるべきではなく(HTMLコードを含むべきではない)、ウォレットはこの文字列を信頼できない入力として扱い、レンダリングを適切に処理する必要があります。

### オンチェーンで使用されることを意図していないEIP-712メッセージのサポート

EIP-712ドメイン区切り文字に `verifyingContract` が含まれていない場合、ウォレットはこのEIPを使って人間可読な説明を取得してはいけません。この場合、ウォレットは元のEIP-712の表示に戻る必要があります。

## 根拠

- `typeDataBuffer` パラメータをABIエンコードで実装したのは、データをコントラクトに渡す一般的な方法であるためです。代替案は `typedData` 構造体を渡すことでしたが、これはメッセージデータを指定する必要があるため一般的ではありません。
- 文字列の配列を返すことにしたのは、メッセージが複数の部分で構成される可能性があるためです。例えば、同じ `typedDataBuffer` 内で複数の資産の転送がある場合、コントラクトは各転送を別の文字列で説明することが推奨されます。これにより、ウォレットは各転送を個別に表示できます。

### 代替案

#### サードパーティーサービス:

現時点で、ユーザーにとって最良の選択肢は、提案されたメッセージを入力として受け取り、その意図された意味を説明するいくつかの第三者ソリューションに頼ることです。このアプローチには以下の問題があります:

- 拡張性がない: 第三者プロバイダーはそのような独自のメッセージをすべて学習する必要がある
- 必ずしも正確ではない: 説明は元のメッセージ作成者の解釈に基づいている
- 運用、セキュリティ、プライバシーに影響を与える可能性のある第三者への不要な依存関係が生じる

#### ドメイン名のバインディング

別の方法として、ウォレットはドメイン名をシグネチャにバインドすることができます。つまり、EIP-712で定義された `name` がEIP-712ドメインに含まれている Web2 ドメインからのEIP-712メッセージのみを受け入れるのです。ただし、このアプローチには以下の欠点があります:

- Web3の合成性を損なう。つまり、他のdappsがそのようなメッセージと対話できなくなる
- 指定されたWeb2ドメインから来る悪いメッセージを保護できない(例えばWeb2ドメインがハッキングされた場合)
- 一部の現在のコネクタ(例えばWalletConnect)では、ウォレットがWeb2ドメインの信頼性を確認できない

## 下位互換性

非対応のコントラクトの場合、ウォレットは現在表示しているものをデフォルトで表示します。
非対応のウォレットはこの関数を呼び出さず、現在表示しているものをデフォルトで表示します。

## 参考実装

参考実装は[こちら](../assets/eip-6384/implementation/src/MyToken/MyToken.sol)にあります。
このおもちゃの例では、EIP-712サポートの "transferWithSig" 機能を実装する [EIP-20](./eip-20.md) コントラクトを示しています(これは Permit の非標準的なバリエーションですが、このEIPの目的は非標準のEIP-712バッファに可読性を与えることです)。
この EIP の実用性を実際の使用例に示すため、OpenSeaの SeaPort EIP-712 の実際のヘルパー関数も[こちら](../assets/eip-6384/implementation/src/SeaPort/SeaPort712ParserHelper.sol)に実装されています。

## セキュリティ上の考慮事項

### 脅威モデル:

攻撃は、EIP-712フォーマットのメッセージのパラメータを悪意のあるWeb2インターフェイス("dapp")が提供することで可能になります。そのため、メッセージは攻撃者によって制御されており、信頼できません。一方、コントラクトは正当な当事者によって制御されており、信頼できます。

攻撃者の意図は、後にそのEIP-712メッセージを攻撃者が作成したトランザクションで使用することです。その後のオンチェーントランザクションが被害者によって送信された場合、通常のトランザクションシミュレーションで十分でした。

悪意のあるコントラクトの場合は関係ありません。そのような悪意のあるコントラクトは、EIP-712フォーマットのメッセージの存在に関係なく、攻撃を容易に行うことができます。

ただし、悪意のあるコントラクトはこの機能を悪用して、ウォレットのレンダリングの脆弱性を悪用するために、悪意を持って作成された文字列を送信しようとする可能性があります。したがって、ウォレットはこの文字列を信頼できない入力として扱い、適切にレンダリングする必要があります。

### 提案されたソリューションの分析

説明は関連するコントラクトによって制御されており、正当な当事者によって制御されています。攻撃者は関連するコントラクトアドレスを指定する必要があるため、この方法で偽の説明を作成することはできません。
メッセージに署名する際の説明がメッセージの一部であった場合、それは攻撃者の管理下にあり、セキュリティ上の目的には無関係でした。

コントラクトに追加された機能は "view" モディファイアを持っているため、オンチェーンの状態を変更したり、既存の機能を害したりすることはできません。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。