---
original: 17aaadbb02cbad06a0835dcc3d509340195c874b12bf304af00b959f25efb0da
---

---
eip: 7513
title: スマートNFT - 意図中心のコンポーネント
description: このプロポーザルは、スマートコントラクトの実行ロジックを組み合わせた新しいタイプのNFTを定義し、NFTに実行可能な機能を付与するものです。
author: MJ Tseng (@TsengMJ) <tsngmj@gmail.com>, Clay (@Clay2018) <clay.uw@outlook.com>, Jeffery.c <jeffery.c@a3sprotocol.xyz>, Johnny.c <johnny.c@a3sprotocol.xyz>
discussions-to: https://ethereum-magicians.org/t/nft-bound-modularized-contract/15696
status: Draft
type: Standards Track
category: ERC
created: 2023-09-06
requires: 165, 1155
---

## 概要

スマートNFTは、スマートコントラクトとNFTの融合です。スマートコントラクトのロジックを持つNFTは、オンチェーンでの対話を可能にします。NFTからスマートNFTへの移行は、一般的な固定電話からスマートフォンへの移行に似ており、NFTのより広範囲で知的な可能性を開きます。

## 動機

Ethereumの導入によりスマートコントラクトが革新され、分散型アプリケーション(dApp)のflourishing生態系が整備されました。また、[ERC-721](./eip-721.md)を通じて、所有権の検証のためのnon-fungible tokens (NFTs)の概念が導入されました。

しかし、スマートコントラクトはほとんどのユーザーにとって大きな障壁を提示しており、NFTは主に芸術、ゲーミング、および現実世界の資産の範囲内での反復的な探索に限定されてきました。

スマートコントラクトの広範な採用と、NFTの機能的な応用は、依然として大きな課題に直面しています。この矛盾から以下のような事実が浮かび上がります:

1. 知性と使いやすさへの強い欲求により、ユーザーはセキュリティを犠牲にする(BOTsに秘密鍵を共有する)ことになっている
2. 個々の開発者にとって、機能をマーケット対応の製品に変換するプロセスは、十分なリソースの不足により阻害されている
3. "コードが法律である"という哲学の中で、スマートコントラクト/コードの所有権を安全に移転するためのオンチェーンインフラストラクチャが不足している

### セキュリティを備えた使いやすさ

IA-NFTはスマートコントラクトの鍵の役割を果たします。秘密鍵がないため、秘密鍵の漏洩リスクはありません。

### ネイティブなオンチェーンアセットとしてのIA-NFT

長年にわたり、NFTは絵画、アート作品、ゲームアイテム、現実世界の資産の所有権を表すものでした。これらのバックアップ資産は実際にはクリプトネイティブではありません。IA-NFTは、コードやスマートコントラクトの所有権を検証します。

### 意図抽象化のための相互作用抽象化

オンチェーンの相互作用は、多くの機能モジュールIA-NFTsに抽象化できるため、相互作用プロセスをより効果的にすることができます。ユーザーは、さまざまなdAppsを操作する方法ではなく、自身の意図に集中することができます。

## 仕様

この文書の中の "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"NOT RECOMMENDED"、"MAY"、"OPTIONAL" というキーワードは、RFC 2119およびRFC 8174に記載されているように解釈されるものとします。

### 概要

以下のセクションでは、3つの主要なオブジェクト:スマートNFT、スマートマネージャー、インテントプロキシの仕様インターフェースを定義し、これらのオブジェクトと3つの主要な役割(開発者、検証者、ユーザー)との相互作用関係を確立します。

![](../assets/eip-7513/workflow.png)

### スマートNFTインターフェース

スマートマネージャーに登録リクエストを送信する前に、開発者はスマートNFTで以下の2つのコアインターフェースを実装する必要があります。

- `execute`: この関数は、特定のスマートNFTに必要なパラメータをカプセル化した "bytes" 型の単一のパラメータを含む必要があります。また、実装中に `validatePermission` を呼び出して、この呼び出しが正当であるかどうかを判断する必要があります。

- `validatePermission`: この関数は、スマートマネージャーに問い合わせて、スマートNFTが正常に検証されており、呼び出し元によって呼び出し可能かどうかを判断するために使用されます。

```solidity
interface ISmartNFT {
  function execute(bytes memory data) external payable returns (bool);

  function validatePermission() external view returns (bool);
}
```

### スマートマネージャーインターフェース

スマートマネージャーのインターフェースでは、スマートNFTの5つの可能な状態を定義しています:

- **UNREGISTERED**: スマートマネージャーに登録されていないスマートNFTを指します。
- **DEREGISTERED**: 以前は登録されていましたが、スマートマネージャーから削除または登録解除されたスマートNFTを示します。
- **UNVERIFIED**: スマートマネージャーに登録されているものの、まだ検証プロセスを経ていないスマートNFTを示します。
- **VERIFIED**: スマートマネージャーに登録され、検証プロセスに合格したことを示し、安全に使用できることを意味します。
- **DENIED**: 登録されたものの、検証プロセスに失敗し、セキュリティリスクがあるため使用すべきではないことを示します。

スマートマネージャーは、以下の3つのコアインターフェースで実装される必要があります。

- `register`: 開発者はこのインターフェースを使ってスマートNFTの登録リクエストを開始し、スマートNFTの作成コードを提供することができます。リクエストが成功すると、スマートNFTは _UNVERIFIED_ とマークされます。

- `auditTo`: 信頼できる検証者のみがこのインターフェースを使用して、スマートNFTの状態を _Verified_ または _Denied_ に変更できるようにする必要があります。

- `isAccessible`: このインターフェースは、ユーザーが特定のスマートNFTを使用できるかどうかを確認するために使用されます。この判断には、対応するtokenIdのNFTの所有権と、スマートNFTが正常に検証されたかどうかの両方を考慮する必要があります。

- `verificationStatusOf`: この関数は、指定されたスマートNFTの現在の検証ステージを返す必要があります。

さらに、スマートマネージャーの実装は、[ERC-1155](./eip-1155.md)を継承する必要があります。

```solidity
interface ISmartManager {
  enum VerificationStatus {
      UNREGISTERED,
      DEREGISTERED,
      UNVERIFIED,
      VERIFIED,
      DENIED
  }

  function register(
      bytes calldata creationCode,
      uint256 totalSupply
  ) external returns (uint256 tokenId, address implAddr);

  function auditTo(uint256 tokenId, bool isValid) external returns (bool);

  function isAccessible(
      address caller,
      uint256 tokenId
  ) external view returns (bool);

  function verificationStatusOf(
      uint256 tokenId
  ) external view returns (VerificationStatus);
}
```

### インテントプロキシインターフェース

インテントプロキシインターフェースでは、Action構造体を定義しています:

| 名称         | 型      | 定義                                                              |
| ------------ | ------- | ----------------------------------------------------------------------- |
| tokenId      | uint256 | 呼び出し対象のスマートNFTのnftid                                   |
| executeParam | bytes   | 対象のスマートNFTのexecuteでエンコードされたパラメータ             |

インテントプロキシには `executeIntent` が実装されている必要があります。

- executeIntent: ユーザーは、この関数を呼び出し、希望するアクションの配列を提供することで、指定されたスマートNFTを一括して使用することができます。

```solidity
interface IIntentProxy {
  struct Action {
      uint256 tokenId;
      bytes executeParam;
  }

  function executeIntent(
      Action[] calldata actions
  ) external payable returns (bool);
}
```

## 根拠

### なぜERC-1155を使用するのか

技術的な実装の側面では、スマートNFTの再利用性を高めるために、[ERC-1155](./eip-1155.md)をメインのコントラクトとして使用することを選択しました。この選択の理由は、[ERC-721](./eip-721.md)と[ERC-1155](./eip-1155.md)の両方がNFTを指すトークンIDの概念に基づいているためです。主な違いは、[ERC-1155](./eip-1155.md)が "shares" の概念を導入し、1つ以上のシェアを持つことでそのスマートNFTの機能を使用する権利が得られるということです。これは、同じモデルの複数のスマートフォンを所有しても、追加の機能が得られないのと同様の概念です。

新しいNFT標準を定義するのではなく、[ERC-1155](./eip-1155.md)を直接使用する別の理由は、スマートNFTのトランザクション動作を既存のマーケットに seamlessly 統合できることです。このアプローチは、開発者とユーザーの両方にとって有益で、スマートNFTの現在のエコシステムへの採用を簡素化します。

### 検証者

このプロトコルでは、検証者が重要な役割を果たし、スマートNFTのコードを監査し、検証する責任があります。しかし、分散型の検証者は非常に困難な問題に直面しており、その主な懸念の1つは、彼らの役割に必要な専門的な専門知識が一般の人々には容易にアクセスできないことです。

まず、検証者の責任を明確にしましょう。それには、スマートコントラクトコードのセキュリティ、機能性、コンプライアンスを評価することが含まれます。この作業には、プログラミングスキル、ブロックチェーン技術の知識、およびコントラクトの専門知識が必要です。検証者は、コード内の脆弱性がないことを確認する必要があります。

次に、分散型の検証者は、権限と信頼性に関する課題に直面します。集中型のモデルでは、特定の監査組織や専門家を信頼して、この作業を行うことができます。しかし、分散型の環境では、検証者の専門知識と誠実さを判断することが困難になります。これにより、不適切な監査が行われる可能性があり、全体的な安定性と信頼性を損なう可能性さえあります。

最後に、分散型の検証者を実現するには、調整と管理の問題にも取り組む必要があります。集中型のモデルでは、検証者の管理と監督の責任は比較的簡単です。しかし、分散型の環境では、さまざまな検証者の作業を調整し、異なるコントラクトやコード全体で一貫性のある監査を確保することが大きな課題となります。

### 著作権侵害の問題

コードの盗用は常に懸念の的ですが、しばしばそのような議論は不要に思えます。ここでは2つの重要なポイントを提示します。第1に、あまりにも単純なコードには価値がないため、盗用についての議論は無意味です。第2に、コードが十分に複雑または創造的な場合は、オープンソースライセンス(OSI)を通じて法的保護を得ることができます。

1つ目のポイントは、非常に単純なコードについては、盗用がほとんど意味をなさないということです。例えば、非常に基本的な "Hello World" プログラムを考えてみましょう。そのようなコードはあまりにも単純で、ほとんどの人が独立して作成できます。そのようなコードの盗用について議論するのは時間とリソースの無駄です。なぜなら、十分な革新性や価値がなく、法的保護を必要としないからです。

2つ目のポイントは、コードが十分に複雑または創造的な場合、オープンソースライセンス(OSI)によってソフトウェア開発者の知的財産権が保護されるということです。オープンソースライセンスは、開発者がコードを共有し、使用条件を指定する方法です。例えば、GNU General Public License (GPL)やMassachusetts Institute of Technology (MIT)ライセンスは、一般的なオープンソース
ライセンスで、オリジナルのコード作成者が知的財産権を保持しつつ、他者がコードを使用および変更することを可能にしています。このアプローチは、複雑で価値のあるコードを保護しながら、イノベーションと共有を促進します。

## 下位互換性

このプロポーザルは、既存の[ERC-1155](./eip-1155.md)プロトコルとの最大限の互換性を確保することを目的としています。[ERC-165](./eip-165.md)検出およびスマートNFTサポートを含む、[ERC-1155](./eip-1155.md)に存在するすべての機能が保持されています。これには、現在のNFTトレーディングプラットフォームとの互換性も含まれます。

すべてのスマートNFTについて、このプロポーザルは `execute` 関数の提供のみを義務付けています。これは、既存のプロキシコントラクトがこのインターフェースのみに集中すれば、スマートNFTの統合がより簡単かつスムーズになることを意味しています。

## リファレンス実装

`https://github.com/TsengMJ/EIP-7513_Example` を参照してください

## セキュリティ上の考慮事項

### 悪意のある検証者

人間が介入するすべての活動には、本質的に悪意のある行動のリスクが存在します。このプロトコルでは、スマートNFTの検証フェーズで、外部の検証者が保証を提供します。しかし、この構造には、悪意のある検証者が意図的に悪意のあるスマートNFTを承認する可能性があるという懸念が存在します。このリスクを軽減するには、より厳格な検証メカニズムの実装、検証者のフィルタリング、罰則措置、あるいはより厳格なコンセンサス基準の導入が必要です。

### 予期せぬ検証エラー

悪意のある検証者の問題に加えて、スマートNFTの実装が複雑すぎたり、Solidityコンパイラの脆弱性があったりするため、検証フェーズでの検出漏れの可能性もあります。この問題は、コントラクト監査を支援するためのツールの追加的な使用や、auditToインターフェースの複数の検証者監査の実装によって、発生可能性を低減することでしか対処できません。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。