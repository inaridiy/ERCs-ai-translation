---
original: c28442906fb950f3c35a659373da7f176a53070ecc6a171ec42e4f33714e55e8
---

---
eip: 4886
title: プロキシ所有権レジスター
description: Ethereum アドレス間の所有権の信頼できる証明を可能にするプロキシ所有権レジスター。委任された資産配信機能を含む
author: Omnus Sunmo (@omnus)
discussions-to: https://ethereum-magicians.org/t/eip-4886-a-proxy-ownership-and-asset-delivery-register/8559
status: 停滞
type: Standards Track
category: ERC
created: 2022-09-03
---

## 概要

ユーザーが別のウォレットアドレスを代理として指名し、新しい資産の配信先アドレスを設定できるプロキシプロトコル。スマートコントラクトやアプリケーションがプロキシアドレスを使用して、指名者アドレスの保有情報を参照できます。これにはいくつかの実用的な用途があります。ユーザーは価値のある資産を安全な冷蔵ウォレットに保管し、低価値のプロキシアドレスを使ってスマートコントラクトと対話できます。指名者の資産は、すべての契約上の操作がプロキシアドレスで行われるため保護されます。これにより、最近見られたユーザーの資産が悪意のある契約の操作によって引き出される事例が排除されます。さらに、レジスターには配信先アドレスが保持されているため、新しい資産を直接冷蔵ウォレットアドレスに配信できます。

## 動機

Ethereum を十分に活用するには、ユーザーが既存の資産の所有権を証明する必要があることが多くあります。例えば:
 * Discord コミュニティでは、ユーザーがウォレットでメッセージに署名して、そのコミュニティのトークンやNFTを保有していることを証明する必要があります。
 * ホワイトリストイベント (最近のエアドロップやNFTミントなど) では、ユーザーが適格性を証明するために指定のアドレスを使って対話する必要があります。
 * DAOやその他のプロトコルでの投票では、ユーザーが関連する資産を保有するアドレスで署名する必要があります。

 他にも多くの例がありますが、共通のテーマは、ユーザーがプラットフォームの恩恵を得るためにはその資産を保有するアドレスを使う必要があるということです。これは、悪意のある開発者が貴重な資産を盗もうとする攻撃の的になります。例えば、新しいプロジェクトが既存のNFT資産の保有者に無料のNFTを提供する場合、既存の保有者は資格を決定した資産を持つウォレットからミントする必要があります。これにより、その種類の資産を持つすべてのユーザーに対して、悪意のある開発者が多数の攻撃ベクトルを持つことになります。

 おそらくさらに深刻なのは、エコシステム全体にわたるユーザー信頼への影響です。ユーザーはアプリやスマートコントラクトとの対話を恐れるようになり、資産を冷蔵ウォレットに保管することを避けるかもしれません。例えば、ユーザーがNFTをボールトに預けてDiscordチャンネルにアクセスできなくなるか、別のウォレットにNFTを保持するか、あるいはDiscordに「ボールト」を接続するかを決める際に問題が生じます。

 Ethereumは信頼できる証明を提供することに優れています。ユーザーが資産を売却または転送する意図がある場合を除いて、その資産を保有するウォレットを使って対話する必要はありません。ユーザーが所有権を証明したい場合 (リソースにアクセスする、エアドロップを受け取る、NFTをミントする、DAOで投票する)、オンチェーンに保存された信頼できる証明を通じて行うべきです。

 さらに、ユーザーは新しい資産の配信先を決められるようにすべきで、それらがユーザーが対話に使ったウォレットに配信されるのではなく、冷蔵ウォレット「ボールト」に直接配信されるべきです。

 このEIPの目的は、このセキュリティ上の懸念を回避し、Ethereumの機能をより多く活用する自信を持つ人を増やすことです。私たちのビジョンは、ユーザーが長期的に保持したい資産用の新しいハードウェアウォレットを設定し、そのウォレットとの1回の契約上の対話 (プロキシを指名する) を行うというEthereumです。そのユーザーは常にその住所の資産の所有権を証明でき、新しい資産の配信先としても指定できます。

## 仕様

この文書の中の "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"、"OPTIONAL" というキーワードは、RFC 2119に記載されているように解釈されるものとします。

### 定義

 * 配信先アドレス: 現在のプロキシレコードに対して資産が配信されるアドレス。つまり、プロキシアドレスが指名者アドレスを表すために作成したNFTは、配信先アドレスに配信されるべきです。
 * 指名: 指名者がプロキシアドレスを指名した状態。プロキシがその指名を受け入れた場合にのみ有効になります。
 * 指名者アドレス: プロキシ関係を提案するアドレス。このアドレスは別のアドレスをプロキシとして指名し、そのプロキシがオンチェーンで自身を表すことになります。
 * プロキシアドレス: 指名者を代表するアドレス。
 * プロキシレコード: 指名者、プロキシ、配信先を含む有効なプロキシ関係。
 * レジスター: 指名と プロキシレコードの詳細を保持する主要なEPSコントラクト。

### EPS仕様

レジスターには2つの主要な部分があります - 指名と プロキシレコード:

    Contract / Dapp                        Register

    指名者: 0x1234..             指名者: 0x1234..
    プロキシ: 0x5678..     --------->  プロキシ: 0x4567..
                                    配信先: 0x9876..

プロキシレコードを作成する最初のステップは、あるアドレスが別のアドレスをプロキシとして指名することです。これにより、指名者(指名を行うアドレス)とプロポーズされたプロキシアドレスのマッピングが作成されます。

この時点ではまだプロキシレコードではなく、プロキシアドレスがその指名を受け入れる必要があります。指名が受け入れられるまでは保留中と見なされます。プロキシアドレスが指名を受け入れると、プロキシレコードがレジスターに追加されます。

指名を受け入れる際、プロキシアドレスはそのプロキシレコードの配信先アドレスを設定します。プロキシアドレスはその配信先アドレスを必要に応じて更新し続けます。指名者とプロキシの両方がプロキシレコードと指名を削除できます。プロキシは削除されない限り永続的に存在し続けます。

レジスターは、すべての指名とレコードの詳細を保持する単一のスマートコントラクトです。各レコードに保持される情報は以下の通りです:
 * 指名:
    * 指名者のアドレス
    * 提案されたプロキシのアドレス

* プロキシレコード:
    * 指名者のアドレス
    * プロキシのアドレス
    * プロキシ配信用の配信先アドレス

任意のアドレスがプロキシまたは指名者として機能できます。プロキシとして機能するためには、まず指名が行われている必要があります。

既に指名者またはプロキシとして機能しているアドレスに対して指名を行うことはできません。つまり、そのアドレスは既に有効なプロキシ関係にあります。

指名とプロキシレコードの情報は、マッピングとして保持されます。指名の場合はアドレス => アドレスのマッピングで、指名者からプロキシアドレスへのマッピングです。プロキシレコードの場合はアドレス => 構造体のマッピングで、プロキシアドレスから指名者と配信先アドレスを含む構造体へのマッピングです。

アドレスと、その指名者および配信先アドレスの間のマッピングは以下のように簡単に行えます:

    Contract / Dapp                        Register

      |                                       |
      |------------- 0x4567..---------------> |
      |                                       |
      | <-------指名者: 0x1234..---------- |
      |         配信先: 0x9876..            |
      |                                       |

このプロトコルは完全に下位互換性があります。アクティブなマッピングがないアドレスが渡された場合、受け取ったアドレスが指名者と配信先アドレスの両方として返されるため、アドレスが自身を代表して機能するのと同様の動作が保証されます。

    Contract / Dapp                        Register

      |                                       |
      |------------- 0x0222..---------------> |
      |                                       |
      | <-------指名者: 0x0222..---------- |
      |         配信先: 0x0222..            |
      |                                       |

EPSレジスターに指名者のアドレスが渡された場合、それはリバートします。これは非常に重要です。プロキシの目的は、プロキシアドレスが指名者に代わって動作することです。したがって、プロキシアドレスは指名者の保有物に関連する恩恵(例えばDiscordのロールに基づく、または保有が必要なNFTのミント)を得ることができます。しかし、指名者が有効なプロキシ関係の下で自身も対話し、これらの恩恵を得ることは絶対に許されません。そうなると、同じ保有物を2つのアドレスが表すことになります。指名者はいつでもプロキシレコードを削除し、自身で対話することができ、その場合プロキシアドレスはプロキシ関係に関連するすべての恩恵を即座に失います。

### Solidity インターフェース定義

**指名が存在するかどうか**

    function nominationExists(address _nominator) external view returns (bool);

指定のアドレスに対して指名が存在する場合にtrueを返します。

**呼び出し元の指名が存在するかどうか**

    function nominationExistsForCaller() external view returns (bool);

msg.senderに対して指名が存在する場合にtrueを返します。

**プロキシレコードが存在するかどうか**

    function proxyRecordExists(address _proxy) external view returns (bool);

渡されたプロキシアドレスに対してプロキシレコードが存在する場合にtrueを返します。

**呼び出し元のプロキシレコードが存在するかどうか**

    function proxyRecordExistsForCaller() external view returns (bool);

msg.senderに対してプロキシレコードが存在する場合にtrueを返します。

**指名者レコードが存在するかどうか**

    function nominatorRecordExists(address _nominator) external view returns (bool);

渡された指名者アドレスに対してプロキシレコードが存在する場合にtrueを返します。

**呼び出し元の指名者レコードが存在するかどうか**

    function nominatorRecordExistsForCaller() external view returns (bool);

msg.senderに対してプロキシレコードが存在する場合にtrueを返します。

**プロキシレコードの取得**

    function getProxyRecord(address _proxy) external view returns (address nominator, address proxy, address delivery);

渡されたプロキシアドレスに対する指名者、プロキシ、配信先アドレスを返します。

**呼び出し元のプロキシレコードの取得**

    function getProxyRecordForCaller() external view returns (address nominator, address proxy, address delivery);

msg.senderをプロキシアドレスとして、指名者、プロキシ、配信先アドレスを返します。

**指名者レコードの取得**

    function getNominatorRecord(address _nominator) external view returns (address nominator, address proxy, address delivery);

渡された指名者アドレスに対する指名者、プロキシ、配信先アドレスを返します。

**呼び出し元の指名者レコードの取得**

    function getNominatorRecordForCaller() external view returns (address nominator, address proxy, address delivery);

msg.senderを指名者アドレスとして、指名者、プロキシ、配信先アドレスを返します。

**アドレスがアクティブかどうか**

    function addressIsActive(address _receivedAddress) external view returns (bool);

渡され
たアドレスが有効なプロキシレコードの指名者またはプロキシアドレスである場合にtrueを返します。

**呼び出し元のアドレスがアクティブかどうか**

    function addressIsActiveForCaller() external view returns (bool);

msg.senderが有効なプロキシレコードの指名者またはプロキシアドレスである場合にtrueを返します。

**指名の取得**

function getNomination(address _nominator) external view returns (address proxy);

指名者が渡された場合、その指名に対応するプロキシアドレスを返します。

**呼び出し元の指名の取得**

function getNominationForCaller() external view returns (address proxy);

msg.senderが指名者である場合、その指名に対応するプロキシアドレスを返します。

**アドレスの取得**

    function getAddresses(address _receivedAddress) external view returns (address nominator, address delivery, bool isProxied);

渡されたアドレスに対する指名者、プロキシ、配信先アドレス、およびisProxiedフラグを返します。渡されたアドレスがプロキシアドレスでない場合、指名者、プロキシ、配信先アドレスはすべてaddress(0)を返し、isProxiedはfalseになります。渡されたアドレスがプロキシアドレスである場合、関連するアドレスを返し、isProxiedはtrueになります。

**呼び出し元のアドレスの取得**

    function getAddressesForCaller() external view returns (address nominator, address delivery, bool isProxied);

msg.senderに対する指名者、プロキシ、配信先アドレス、およびisProxiedフラグを返します。msg.senderがプロキシアドレスでない場合、指名者、プロキシ、配信先アドレスはすべてaddress(0)を返し、isProxiedはfalseになります。msg.senderがプロキシアドレスである場合、関連するアドレスを返し、isProxiedはtrueになります。

**ロールの取得**

    function getRole(address _roleAddress) external view returns (string memory currentRole);

渡されたアドレスのロールを表す文字列値を返します。可能なロールは以下の通りです:

None - そのアドレスはレジスターにレコードや指名として登録されていません。

Nominator - Pending - そのアドレスは、まだプロキシアドレスに受け入れられていない指名の指名者です。

Nominator - Active - そのアドレスは、受け入れられたプロキシレコードの指名者です。

Proxy - Active - そのアドレスは、有効なプロキシレコードのプロキシです。

**呼び出し元のロールの取得**

    function getRoleForCaller() external view returns (string memory currentRole);

msg.senderのロールを表す文字列値を返します。可能なロールは以下の通りです:

None - msg.senderはレジスターにレコードや指名として登録されていません。

Nominator - Pending - msg.senderは、まだプロキシアドレスに受け入れられていない指名の指名者です。

Nominator - Active - msg.senderは、受け入れられたプロキシレコードの指名者です。

Proxy - Active - msg.senderは、有効なプロキシレコードのプロキシです。

**指名の作成**

    function makeNomination(address _proxy, uint256 _provider) external payable;

プロキシアドレスを渡して、msg.senderの指名を作成できます。

Providerは必須の引数です。Providerの IDを持っていない場合は、デフォルトのEPSプロバイダーとして0を渡すことができます。EPSプロバイダープログラムの詳細については、をご覧ください。

**指名の受け入れ**

    function acceptNomination(address _nominator, address _delivery, uint256 _provider) external;

指名者とdelivery addressを渡して、msg.senderがその指名を受け入れることができます。指名を受け入れるには、msg.senderがプロキシとして指名されている必要があります。この関数に渡された指名者アドレスと、指名に記録されている指名者アドレスが一致する必要があります。

Providerは必須の引数です。Providerの IDを持っていない場合は、デフォルトのEPSプロバイダーとして0を渡すことができます。EPSプロバイダープログラムの詳細については、をご覧ください。

**配信先アドレスの更新**

    function updateDeliveryAddress(address _delivery, uint256 _provider) external;

新しい配信先アドレスを渡すことができ、msg.senderがプロキシレコードのプロキシである場合に更新できます。

Providerは必須の引数です。Providerの IDを持っていない場合は、デフォルトのEPSプロバイダーとして0を渡すことができます。EPSプロバイダープログラムの詳細については、をご覧ください。

**指名者によるレコードの削除**

    function deleteRecordByNominator(uint256 _provider) external;

msg.senderが指名者である場合に、レコードと指名を削除できます。

レコードと指名の両方が存在する場合、両方が削除されます。レコードが存在しない場合(つまり、指名がプロキシアドレスに受け入れられていない)、指名のみが削除されます。

Providerは必須の引数です。Providerの IDを持っていない場合は、デフォルトのEPSプロバイダーとして0を渡すことができます。EPSプロバイダープログラムの詳細については、をご覧ください。

**プロキシによるレコードの削除**

    function deleteRecordByProxy(uint256 _provider) external;

msg.senderがプロキシである場合に、レコードと指名を削除できます。

## 根拠

このEIPの根拠は、既存および将来のすべてのEthereum資産に対して、資産を保管しているアドレスとは異なる「実質的所有者」(プロキシ)を持つ方法を提供することでした。レジスターを使ってこれを実現することで、既存のトークンに変更を加える必要がありません。レジスターには、指名者とプロキシの両方が署名した信頼できる証明が保存され、資産の所有権の真の表現として依存できます。

## 下位互換性

このEIPは完全に下位互換性があります。

## テストケース

このプロポーザルの完全なSDLCが完了しており、mainnet、ropsten、rinkeby上の0xfa3D2d059E9c0d348dB185B32581ded8E8243924で稼働しています。コントラクトのソースコードは検証済みで、etherscanで入手可能です。完全なユニットテストスイートは `../assets/eip-4886/` にあり、ソースコードと実装例も含まれています。

## リファレンス実装

`../assets/eip-4886/contracts` をご覧ください

## セキュリティ上の考慮事項

EIPの主な目的は、ユーザーの資産をより安全に保護し、冷蔵ウォレットの使用を促進することで、ユーザーのセキュリティを向上させることです。

潜在的な悪影響はなく、プロキシレコードは指名者とプロキシの両方が署名した証明が確認された場合にのみ有効になります。

ユーザビリティの観点から、主なリスクは資産の配信先アドレスを誤って指定することですが、この正確性の責任はネットワーク上の現在と変わりません。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。