---
original: cd50e7ba2e9474da3cf28f1306fff7a9291c4d06d644ca41f6dc8fe1ff388ee4
---

---
eip: 1921
title: dTypeの機能拡張
author: Loredana Cirstea (@loredanacirstea), Christian Tzurcanu (@ctzurcanu)
discussions-to: https://github.com/ethereum/EIPs/issues/1921
status: 停滞
type: Standards Track
category: ERC
created: 2019-04-06
requires: 1900
---

## 簡単な要約
[EIP-1900](./eip-1900.md)で説明されている分散型タイプシステム(dType)の文脈において、dTypeレジストリに関数(preferably `pure`と`view`)の登録をサポートすることを提案します。

## 概要

このプロポーザルは、[EIP-1900](./eip-1900.md)で説明されている分散型タイプシステムの概念を拡張するEIPシリーズの一部です。
現在のEIPは、dTypeレジストリにスマートコントラクト関数を個別に登録するために必要なデータ定義とインターフェースを指定しています。

## 動機

EVMをシングルトンオペレーティングシステムに進化させるためには、自動化された方法で実行したい契約関数を登録、検索、呼び出す方法が必要です。
これには、EVMの内部で関数を実行するために必要なすべてのデータにアクセスできることが含まれます。

上記の動機に加えて、このプロポーザルにはさらに近い将来の利点もあります。グローバルに利用可能な非保管型の関数レジストリがあれば、ブロックチェーンデータ分析(ブロックエクスプローラーなど)、スマートコントラクトIDE、スマートコントラクトのセキュリティ分析などのツールの開発が民主化されます。

新しいスマートコントラクト関数の登録は、[EIP-1900](./eip-1900.md)で言及されているのと同じコンセンサスメカニズムを通じて行うことができ、冗長または不適切な記録でチェーンの状態を過度に負荷することを回避できます。

## 仕様

この仕様は`pure`と`view`関数を対象としています。

各関数について、以下を保存できます:
* `name` - 型`string`、EIP-1900で定義された一意の関数名。必須
* `types` - 入力の型データとラベル。EIP-1900で定義されています。必須
* `outputs` - 出力の型データとラベル。必須
* `contractAddress` - 型`address`、関数が存在するスマートコントラクトのアドレス。EIP-1900で定義されています。インターフェースの場合は省略可能
* `source` - 型`bytes32`、関数のソースコードを含む外部ファイルへの参照。EIP-1900で定義されています。省略可能

したがって、このプロポーザルはEIP-1900の型登録定義に`outputs`を追加しています。

dTypeレジストリの関数登録オブジェクトの例は次のとおりです:

```
{
    "name": "setStaked",
    "types": [
        {"name": "TypeA", "label": "typeA", "relation":0, "dimensions":[]}
    ],
    "typeChoice": 4,
    "contractAddress": <関数が定義されているスマートコントラクトのアドレス>,
    "source": <ソースファイルを参照するbytes32ハッシュ>,
    "outputs": [
        {"name": "TypeB", "label": "typeB", "relation":0, "dimensions":[]}
    ]
}
```

上記のオブジェクトは`<dTypeレジストリ>.insert({...})`に渡されます。

dTypeレジストリに対して`setOutputs`関数が提案されています:

```
function setOutputs(
    bytes32 identifier,
    dTypes[] memory outputs
)
    public
```

- `identifier` - 型`bytes32`、EIP-1900で定義された型の識別子
- `outputs` - 型`dTypes`、EIP-1900で定義されています

### 実装の提案

dTypeレジストリの実装では、`outputs`を`mapping`に保存できます:

```
mapping(bytes32 => dTypes[]) public outputs;
```

## 根拠

`pure`または`view`関数を個別のエンティティとして扱うことを提案したのは、以下のような理由からです:
* 即座に利用可能な関数のグローバルコンテキストを持つことができる
* 関数型プログラミングパターンを使ってデザインを拡張できる(コントラクトカプセル化ロジックを使うよりも成功する可能性が高い)
* 関数と使用する型を双方向に接続できるため、自動化が容易になる
* すでにデプロイされたコントラクトから関数を選択できる(他のコントラクト機能がコミュニティのコンセンサスを通過しない場合)
* 範囲を限定した改善が可能 - 完全なコントラクトを再デプロイする代わりに、レジストリに追加したい新しい関数バージョンのみを再デプロイできる
* 個々の関数の細かい監査を可能にする(共通の利益のために)
* 状態への副作用なしに本番チェーンで直接テストできる

各関数の最小限のABI情報をオンチェーンに保存することで、以下のことが可能になります:
* オンチェーンの自動化(例: 関数のチェーンと合成)を可能にする
* 関数シグネチャ形式が変更された場合(例: `bytes4`から`bytes32`へ)の下位互換性を維持する: dTypeに複数のシグネチャ計算関数を登録できます。例:

```
function getSignatureBytes4(bytes32 identifier)
    view
    public
    returns (bytes4 signature)

function getSignatureBytes32(bytes32 identifier)
    view
    public
    returns (bytes32 signature)
```

- `identifier` - EIP-1900で定義された型の識別子
- `signature` - 関数のシグネチャ

この設計に対する懸念点は以下のようなものが考えられます:
* 同じコントラクトの一部である各関数の`contractAddress`を保存することによる冗長性

状態/ストレージコストは、すでに登録されて簡単に見つかるタイプと関数を再利用することで、チェーン全体で相殺されると考えています。仕様と実装がより最終化に近づいたら、他の状態/ストレージコストの計算を追加します。

入力と出力のタイプは、すでに登録されているタイプに基づいています。これにより、各関数に必要なABI情報の量が減り、同じI/Oタイプを使う関数を開発者が集約して見つけられるようになります。これは相互運用性とスマートコントラクトの合成に強力なツールになる可能性があります。

## 下位互換性

このプロポーザルは既存のEthereum標準や実装に影響を与えません。既存のコントラクトデプロイメントの関数を登録することはフルサポートされます。

## テストケース

追加予定。

## 実装

作業中の実装例は https://github.com/pipeos-one/dType にあります。
仕様に合意が得られたら、適切な実装をこのプロポーザルに追加します。

## 著作権
[CC0](../LICENSE.md)によりコピーライトおよび関連権利が放棄されています。