---
original: 095a0ea04d5c431dd13310034bb31d2a699488bc69bffad8e3fa6dd97026ee44
---

---
eip: 4910
title: ロイヤルティ付きNFT
description: ERC-721の拡張機能で、オンチェーンのNFTロイヤルティを正しく定義、処理、支払うことができます。
author: Andreas Freund (@Therecanbeonlyone1969)
discussions-to: https://ethereum-magicians.org/t/royalty-bearing-nfts/8453
status: 最終
type: Standards Track
category: ERC
created: 2022-03-14
requires: 165, 721
---

## 概要

このプロポーザルは、[ERC-721](./eip-721.md)標準を拡張したスマートコントラクトアーキテクチャを通じて、NFTとロイヤルティを直接結び付けることを目的としており、中央当局が法的に権利を持つ者への支払いを操作または回避することを防ぐことを目的としています。

このプロポーザルは、OpenZeppelinのスマートコントラクトツールボックスアーキテクチャに基づいており、ロイヤルティアカウント管理(CRUD)、ロイヤルティ残高と支払い管理、シンプルな取引機能(リスト/デリスト/購入)、取引の追跡機能を含むように拡張されています。ロイヤルティ管理機能により、「親」NFTと「子」NFTを論理的に接続し、再帰的にNFT「子」がさらに子を持つことができる階層的なロイヤルティ構造(以下「ロイヤルティツリー」と呼ぶ)を確立することができます。

## 動機

ロイヤルティの管理は、複雑な契約、不透明な管理、多くの不正行為が特徴の古くからの問題です。

特に、1つ以上の資産が元の資産から派生している場合、例えば元の絵画からの版画、または1つの曲が別の曲の制作に使用されている場合、あるいは一連の関連会社を通じて配信権と補償が管理されている場合などでは、この問題はより顕著です。

下の例では、オリジナルを作成したアーティストは、その版画のあらゆる売買から収益を得る資格があります。

![Fig1](../assets/eip-4910/eip-4910-print-families.png)

上記の「系譜」概念を使って示される階層的ロイヤルティの基本的な概念は、以下の図に示されています。

![Fig2](../assets/eip-4910/eip-4910-royalties.png)

階層的ロイヤルティの複雑な相続問題を解決するために、このプロポーザルでは、深さNの階層ツリーの再帰的な問題を、各層の N 個の個別の問題に分解しています。これにより、ツリーの最下層から根元まで最も効率的に移動することができます。

これにより、創造者や元の作品から派生した作品の配布者は、創造プロセスからのパッシブな収入を得る機会を得ることができ、NFTの価値を高めることができます。NFTには本質的な価値だけでなく、付随するキャッシュフローも付いているためです。

## 仕様

この文書の中の「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されるものとします。

### 概要

このプロポーザルは、ERC-721標準の拡張として、以下の新しい概念を導入しています:

* **ロイヤルティアカウント(RA)**
    * ロイヤルティアカウントは、`tokenId`を通じてそれぞれのNFTに付属しており、個人のアカウントや他のRAなどのサブアカウントで構成されています。ロイヤルティアカウントは、アカウント識別子によって識別されます。
* **アカウントタイプ**
    * これは、RAサブアカウントが個人(ユーザー)のものか、別のRAのものかを指定します。RAサブアカウントが別のRAの場合、割り当てられた残高を、そのRAを構成するサブアカウントに再配分する必要があります。
* **ロイヤルティ分割**
    * NFTの売却に基づいて、各サブアカウントが受け取る割合
* **ロイヤルティ残高**
    * RAに関連付けられたロイヤルティ残高
* **サブアカウントロイヤルティ残高**
    * 各RAサブアカウントに関連付けられたロイヤルティ残高。個人アカウントのみが支払い可能な残高を持つことができることに注意してください。つまり、RAサブアカウントが別のRAの場合、その最終的なサブアカウント残高はゼロでなければならず、すべてのRA残高は個人アカウントに割り当てられる必要があります。
* **トークンタイプ**
    * トークンタイプは、ETHまたはサポートされているユーティリティトークンのシンボル(例: `DAI`)として指定されます。
* **アセットID**
    * これは、RAが属する`tokenId`です。
* **親**
    * これは、RAが属する`tokenId`の直接の親`tokenId`を示します。

以下に、この文書で定義される要件をカバーする、データ構造と機能の非規範的な概要を示します。

#### データ構造

NFTとRAを関連付けるための相互接続されたデータ構造を作成するために、いくつかのグローバルデータ構造が必要です:

* ロイヤルティアカウントとそれに関連付けられたロイヤルティサブアカウントを確立するためのもの。
* `tokenId`をロイヤルティアカウント識別子に接続するためのもの。
* 親子NFT関係を示す構造。
* サポートされているトークンタイプとその最終的に検証された残高(取引とロイヤルティ支払いの目的)のリスト。
* `executePayment`関数で支払われ、`safeTransferFrom`で検証される登録された支払いのリスト。これで十分です。なぜなら、一度受け取られ`safeTransferFrom`関数で配布された支払いは、リストから削除されるためです。
* 売却されるNFTのリスト

#### ロイヤルティアカウント機能

ロイヤルティアカウントのRUD(Read-Update-Delete)関数の定義とインターフェース。ロイヤルティアカウントは、ミンティング関数で作成されるため、ロイヤルティアカウントを別途作成する関数は必要ありません。

#### ロイヤルティ付きNFTのミンティング

NFTがミントされると、NFTと所有者、そして祖先がいる場合はその祖先のRAに関連付けられたRAを作成する必要があります。そのために、仕様は新たに定義された`mint`関数の中で`_safemint`関数を利用し、入力変数に対するさまざまなビジネスルールを適用しています。

#### 売却のためのNFTのリストアップと削除

認可されたユーザーアドレスは、NFTの取引所仲介外の直接購入のためにNFTをリストアップすることができます。

#### 買い手から売り手への支払い

ロイヤルティの回避を避けるために、買い手は常に売り手ではなく、NFTコントラクトに直接支払います。売り手は、ロイヤルティ分配を通じて支払われ、後に支払いを要求することができます。

支払いプロセスは、支払いがETHかERC-20トークンかによって異なります:

* ERC-20トークン
    1. 買い手は、選択した支払いトークン(ERC-20コントラクトアドレス)の購入価格、`payment`について、NFTコントラクトを`approve`しなければなりません。
    2. ERC-20支払いトークンの場合、買い手はその後NFTコントラクトの`executePayment`を呼び出す必要があります - ERC-20は直接関与しません。
* 非ERC-20支払いの場合、買い手はプロトコルトークン(ETH)をNFTコントラクトに送る必要があり、`msg.data`に購入したNFTの`uint256[]tokenId`をエンコードする必要があります。

#### 必要な取引データを含む修正されたNFT転送関数でロイヤルティを配分

NFTを転送するには、ロイヤルティが適切に配分された後に、いくつかの要件を満たす必要があります。また、一度に複数のトークンを転送する機能も考慮されています。

このプロポーザルでは以下を定義しています:

* 入力パラメータの検証
* 支払いパラメータの検証
* ロイヤルティの配分
* 支払い後のロイヤルティアカウントの所有権更新
* NFTの所有権の移転
* 成功した転送後の`registeredPayment`エントリーの削除

最後に、ロイヤルティの配分方法は、相互接続されたロイヤルティアカウントの階層構造を層に分解し、1層ずつ処理することです。ここでは、トークンと先祖の関係が利用されて、ロイヤルティアカウントチェーンを根元まで遡ることができます。

#### NFTオーナー(`from`アドレス)へのロイヤルティ支払い - `safeTransferFrom`関数

これがプロポーザルの最後の部分です。

ペイアウト関数には2つのバージョンがあります - `public`関数と`internal`関数。

public関数のインターフェースは以下の通りです:

```
function royaltyPayOut (uint256 tokenId, address RAsubaccount, address payable payoutAccount, uint256 amount) public virtual nonReentrant returns (bool)
```

ここでは、`tokenId`、RA サブアカウントアドレス `_RAsubaccount`(オーナー)、支払う金額 `_amount` のみが必要です。なお、この関数には資金が支払われるため、`nonReentrant`修飾子による保護がなされています。

最終的に支払いを行うには、以下の手順を踏む必要があります:

* `RAaccount`と`subaccountPos`に基づいてRAサブアカウントを見つけ、残高を抽出する
* サブアカウントから`tokenType`を抽出する
* トークンタイプに基づいて、利用可能な残高を超えない範囲で支払いを行う

### データ構造

#### ロイヤルティアカウントとロイヤルティサブアカウント

NFTとRAを関連付ける検索最適化された相互接続データ構造を作成するには、ERC-721のグローバルデータ構造に以下の追加が必要です。

注意: ロイヤルティアカウントは、メタアカウントに関連付けられたロイヤルティサブアカウントの集合体として定義されます。このメタアカウントは、NFTに固有のアセット識別子、親識別子などの一般的なアカウント識別子で構成されます。

<a name="r1">**[R1]**</a> *1つ以上のロイヤルティサブアカウントが、ロイヤルティアカウントにリンクされている必要があります。*

<a name="r2">**[R2]**</a> *ロイヤルティアカウントの識別子 `raAccountId` は一意でなければなりません。*

<a name="r3">**[R3]**</a> *NFTの `tokenId` は、`raAccountID` にリンクされている必要があり、`raAccountId` を `tokenId` に接続する必要があります。*

#### 子NFT

親子NFT関係を管理し、NFT(ファミリー)ツリーの各レベルでの制約(許可される子の数など)を管理するための要件は以下の通りです。

<a name="r4">**[R4]**</a> *直接の親子関係にリンクが存在する必要があります。*

#### NFT支払いトークン

ロイヤルティを取得するために、NFTコントラクトはNFT取引に関与する必要があります。そのため、NFTコントラクトはNFT支払いを認識する必要があり、それには取引に使用できるトークンを認識する必要があります。

<a name="r5">**[R5]**</a> *サポートされるトークンタイプのリストが存在する必要があります。*

NFTコントラクトがロイヤルティの配分と支払いおよび販売を管理しているため、許可されたトークンタイプの最新の残高を追跡する必要があります。

<a name="r6">**[R6]**</a> *許可されたトークンタイプの最終的に検証された残高が、それぞれのトークンコントラクトにリンクされている必要があります。*

#### NFTリストと支払い

コントラクトが直接販売プロセスに関与しているため、1つ以上のNFTを販売するための機能が必要です。


<a name="r7">**[R7]**</a> *販売リストが存在する必要があります。*

<a name="r8">**[R8]**</a> *販売リストには一意の識別子がある必要があります。*

リストの他に、コントラクトは販売も管理する必要があります。これには、即時実行用または後の支払い(オークションなど)用の支払いを登録する機能が必要です。

<a name="r9">**[R9]**</a> *登録された支払いのリストが存在する必要があります。*

<a name="r10">**[R10]**</a> *登録された支払いには一意の識別子がある必要があります。*

#### コントラクトコンストラクタとグローバル変数およびその更新関数

この標準は現在のERC-721コンストラクタを拡張し、NFTの作成者の特別な役割と、コントラクトが販売とロイヤルティの管理に直接関与するようになったことを認識するためのいくつかのグローバル変数を追加しています。

<a name="r11">**[R11]**</a> *最小限のコントラクトコンストラクタには以下の入力要素が含まれている必要があります。*

```
///
/// @dev コントラクトコンストラクタの定義
///
/// @param name ERC-721と同様
/// @param symbol ERC-721と同様
/// @param baseTokenURI ERC-721と同様
/// @param allowedTokenTypes 支払いに許可されたトークンの配列

constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        address[] memory allowedTokenTypes
    ) ERC721(name, symbol) {...}
```

### ロイヤルティアカウント管理

以下は、ロイヤルティアカウントのRUD(Read-Update-Delete)関数の定義とインターフェースです。ロイヤルティアカウントはNFTのミンティング関数で作成されるため、ロイヤルティアカウントを別途作成する関数は必要ありません。

#### ロイヤルティアカウントの取得

`tokenId`からロイヤルティアカウントとそのサブアカウントを取得できるため、1つの取得関数のみが必要です。

<a name="r12">**[R12]**</a> *`getRoyaltyAccount`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev 指定されたtokenIdのロイヤルティアカウントを取得する関数
/// @param tokenId NFTを識別するID
/// @param RoyaltyAccount ロイヤルティアカウント情報を含むデータ構造
/// @param RASubAccount[] ロイヤルティアカウントに関連付けられたロイヤルティサブアカウントの情報を含む配列

function getRoyaltyAccount (uint256 tokenId) public view virtual returns (address,
            RoyaltyAccount memory,
            RASubAccount[] memory);
```

<a name="r13">**[R13]**</a> *`getRoyaltyAccount`関数では以下のビジネスルールを強制する必要があります:*

* *`tokenId`が存在し、焼却されていないこと*

#### ロイヤルティアカウントの更新

ロイヤルティアカウントを更新するには、呼び出し元が`tokenId`とロイヤルティアカウント自体の両方を持っている必要があります。これはロイヤルティアカウントのゲッター関数から取得できます。

<a name="r14">**[R14]**</a> *`updateRoyaltyAccount`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev ロイヤルティアカウントとそのサブアカウントを更新する関数
/// @param tokenId ロイヤルティアカウントが更新されるNFTのID
/// @param RoyaltyAccount 更新された値を持つロイヤルティアカウントとそのサブアカウント

function updateRoyaltyAccount (uint256 _tokenId, `RoyaltyAccount memory _raAccount) public virtual returns (bool)
```

ロイヤルティアカウントの更新機能は単純ですが、微妙な面もあります。複雑な変更管理ルール(マルチシグネチャルールなど)を避けるため、ロイヤルティアカウントの変更は単純に保たれています。

<a name="r15">**[R15]**</a> *更新関数のビジネスルールは以下の通りです:*

1. *NFTのアセット識別子は変更できません。*
2. *NFTの先祖は更新できません。*
3. *NFTの支払いに使用されるトークンタイプは更新できません。*
4. *ロイヤルティサブアカウントのロイヤルティ残高は変更できません。*
5. *NFT親から子に継承されるロイヤルティ分割は変更できません。*
6. *新しいロイヤルティ分割値は、存在する場合の境界値よりも大きい、小さい、または等しい必要があります。*
7. *既存のロイヤルティサブアカウントの数と追加されるロイヤルティサブアカウントの数の合計は、存在する場合の境界値以下でなければなりません。*
8. *すべての既存および新規ロイヤルティサブアカウントのロイヤルティ分割の合計は、常に1または等価の数値でなければなりません。*
9. `msg.sender`は、変更されるロイヤルティアカウントのロイヤルティサブアカウントのアカウント識別子と等しく、そのロイヤルティサブアカウントが親NFTに属していないことが識別されている必要があります。
    
    9.1 *サブアカウントの所有者のアカウント識別子は削除されてはいけません*
    
    9.2 *ロイヤルティ分割は減少させることのみができ、既存サブアカウントのロイヤルティ分割を増加させるか、ルール10に従って1つ以上の新しいロイヤルティサブアカウントを追加する必要があります。*
    
    9.3 *ロイヤルティ残高は変更できません*
    
    9.4 *アカウント識別子はNULLであってはいけません*

10. *`msg.sender`が親NFTのものではないサブアカウントの所有者のアカウント識別子と等しい場合、追加のロイヤルティサブアカウントを追加することができます*
    
    10.1 *`msg.sender`のロイヤルティサブアカウントの分割が減少した場合*
    
    * 新しいロイヤルティサブアカウントの残高はゼロでなければならない
    
    * 新しいロイヤルティ分割データの合計は、`msg.sender`のロイヤルティサブアカウントの分割が変更される前の値と等しくなければならない
    
    10.2 *新しいアカウント識別子はNULLであってはいけません*

11. *ロイヤルティアカウントの更新が正しい場合は`true`を、そうでない場合は`false`を返す。*

#### ロイヤルティアカウントの削除

ロイヤルティアカウントを削除する必要がある場合もありますが、ガスの観点から非常にコストがかかる機能であり、以下に列挙された条件が確実に満たされている場合にのみ使用すべきです。

<a name="r16">**[R16]**</a> *`deleteRoyaltyAccount`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev ロイヤルティアカウントを削除する関数
/// @param tokenId 削除対象のロイヤルティアカウントが関連付けられたNFTのID

function deleteRoyaltyAccount (uint256 _tokenId) public virtual returns (bool)
```

<a name="r17">**[R17]**</a> *この関数のビジネスルールは以下の通りです:*

* *`_tokenId`は焼却されている必要があり、つまり所有者が`address(0)`である必要があります。*
* *`_tokenId`に系譜的に関連する、先祖または子孫としての全ての`tokenId`も焼却されている必要があります。*
* *ロイヤルティサブアカウントのすべての残高がゼロである必要があります。*

### NFTのミンティング

ERC-721のミンティング機能に加えて、NFTの最大子供数などの制約をサポートするトークン固有のデータ構造を確立するとともに、ミンティング時にロイヤルティアカウントとロイヤルティサブアカウントを作成し、NFTと所有者、そして先祖がいる場合はその先祖のロイヤルティアカウントに関連付ける必要があります。

<a name="r18">**[R18]**</a> *新しいNFTがミントされる際、ロイヤルティアカウントと1つ以上のロイヤルティサブアカウントが作成され、NFTとNFTの所有者、そして先祖がいる場合はその先祖のロイヤルティアカウントに関連付けられる必要があります。*

そのために、仕様はERC-721の`_safemint`関数を新たに定義された`mint`関数で利用し、関数の入力変数に対するさまざまなビジネスルールを適用しています。

<a name="d1">**[D1]**</a> *`mint`関数は、一度に複数のNFTをミントする機能を持つべきです。*

<a name="r19">**[R19]**</a> *新しいNFTの`owner`は、NFTコントラクト自身でなければなりません。*

<a name="r20">**[R20]**</a *非コントラクトオーナーのNFTは、`isApproved`に設定される必要があり、これにより非コントラクトオーナーがオーナーと同様に操作できるようになります。*


上記の2つの要件は奇妙に見えますが、NFTコントラクトが支払いと受取人に関連付けられたロイヤルティの追跡のためのエスクローとして機能するため、有効な`tokenId`に関連付けられる必要があります。

<a name="r21">**[R21]**</a> *入力の簡潔さのため、およびトークンのメタデータがトークンごとに異なる可能性があるため、以下の最小限のデータ構造が必要です:*

```
/// @param parent トークンの親tokenId。0の場合は親がいない。
/// @param canBeParent トークンがchildrenを持てるかどうかを示す。
/// @param maxChildren 1つのNFTが持てる子供の最大数。
/// @param royaltySplitForItsChildren 子供に支払う必要のあるロイヤルティ割合。
/// @param uri NFTの一意のトークンURI
```

<a name="r22">**[R22]**</a> *`mint`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev ロイヤルティに必要な関連メタデータを持つ1つ以上の新しいNFTと、`to`アドレスに関連付けられたロイヤルティアカウントとそのメタデータを作成する関数。ミントされたtokenId(s)は自動的に割り当てられ(IERC-721-Transferイベントで利用可能)ます。
/// @param to NFTがミントされるアドレス
/// @param nfttoken ミントされるNFTのメタデータ用の構造体の配列
/// @param tokenType 許可されたNFT支払いトークンの種類

function mint(address to, NFTToken[] memory nfttoken, address tokenType) public virtual
```

<a name="r23">**[R23]**</a> *`mint`関数の入力データに対する以下のビジネスルールが満たされる必要があります:*

* *ミントされるトークンの数は0ではない必要があります。*
* *`msg.sender`は`MINTER_ROLE`または最初のNFTの`CREATOR_Role`を持っている必要があります。*
* *`to`アドレスはゼロアドレスではない必要があります。*
* *`to`アドレスはコントラクトではない必要があり、ホワイトリストに登録されている場合を除きます。* 
* *`tokenType`は、コントラクトでサポートされているトークンタイプである必要があります。*
* *`royaltySplitForItsChildren`は100%以下、または手数料などの制約を差し引いた等価の数値である必要があります。*
* *新しいNFTが子供を持てない場合、`royaltySplitForItsChildren`はゼロである必要があります。*
* *新しいNFTに親がいる場合、親NFTの`tokenId`が存在する必要があります。*
* *親のアンセストリーレベルが、指定されている場合の最大許可NFT世代数未満である必要があります。*
* *ミントされるNFTの許可された子供の数が、指定されている場合の最大許可子供数未満である必要があります。*

### 直接販売のためのNFTのリストアップとデリスト

販売プロセスでは、2つのタイプの取引を最小限区別する必要があります。

* 取引所仲介の販売
* 直接販売

最初のタイプの取引では、取引所コントラクトがNFTコントラクトと直接支払いと転送のトランザクションを引き起こすため、スマートコントラクトが販売リストを認識する必要はありません。しかし、後者の取引タイプでは不可欠であり、直接販売はスマートコントラクトによってすべての手順で仲介される必要があります。

<a name="r24">**[R24]**</a> *直接販売の場合、NFTのリスト登録とデリストは、NFTスマートコントラクトを介して実行される必要があります。*

取引所仲介の販売については、支払いの項で説明します。

直接販売では、認可されたユーザーアドレスがNFTを販売リストに登録できます。以下のビジネスルールを参照してください。

<a name="r25">**[R25]**</a> *`listNFT`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev 1つ以上のNFTを直接販売のためにリストアップする関数
/// @param tokenIds リストアップされるtokenIdの配列
/// @param price 所有者が設定した価格
/// @param tokenType 許可された支払いトークンの種類

function listNFT (uint256[] calldata tokenIds, uint256 price, address tokenType) public virtual returns (bool)
```

戻り値のブール値は、関数の実行が成功した場合は`true`、失敗した場合は`false`です。

<a name="r26">**[R26]**</a> *`listNFT`関数のビジネスルールは以下の通りです:*

* 提案されたリストに対して、1つ以上のNFTについて`listedNFT`マッピングにすでにリストが存在してはいけません。
* `seller`は、提案されたリストのすべてのNFTについて`getApproved(tokenId[i])`と等しくなければなりません。
* `tokenType`はスマートコントラクトでサポートされている必要があります。
* `price`は0より大きい必要があります。

<a name="r27">**[R27]**</a> *[**[R26]**](#r26)の条件が満たされた場合、NFT販売リストが更新される必要があります。*

認可されたユーザーアドレスは、NFTの直接販売リストを削除することもできます。

<a name="r28">**[R28]**</a> *`removeNFTListing`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev 1つ以上のNFTの直接販売リストを削除する関数
/// @param listingId 削除対象のNFTリストのID

function removeNFTListing (uint256 listingId) public virtual returns (bool)
```

戻り値のブール値は、関数の実行が成功した場合は`true`、失敗した場合は`false`です。

<a name="r29">**[R29]**</a> *`removeNFTListing`関数のビジネスルールは以下の通りです:*

* *登録された支払いエントリーがNULLである必要がある*
* *`msg.sender = getApproved(tokenId)`である必要がある*

<a name="r30">**[R30]**</a> *[**[R29]**](#r29)の条件が満たされた場合、NFT販売リストが削除される必要があります。*

### NFT販売の支払い

前述のように、買い手は常に売り手ではなく、NFTコントラクトに直接支払います。売り手は、ロイヤルティ分配を通じて支払われ、後に支払いを要求することができます。

<a name="r31">**[R31]**</a> *支払いプロセスは1つまたは2つのステップを必要とします:*

1. *ERC-20トークンの場合*
    * *買い手は、選択した支払いトークン(ERC-20コントラクトアドレス)の購入価格、`payment`について、NFTコントラクトを`approve`する必要があります。*
    * *買い手は、その後NFTコントラクトの`executePayment`関数を呼び出す必要があります。*
2. *プロトコルトークンの場合*
    * *買い手は、`msg.data`がNULLではない支払いフォールバック関数をコールする必要があります。*

<a name="r32">**[R32]**</a> *ERC-20トークンタイプの場合、必要な`executePayment`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev NFTの直接販売または取引所仲介販売の支払いを行う関数
/// @param receiver 支払いの受取人アドレス
/// @param seller NFTの売り手アドレス
/// @param tokenIds 購入されるNFTのtokenId
/// @param payment 支払い金額
/// @param tokenType 支払いトークンの種類
/// @param trxnType 支払いトランザクションの種類 - 最小限直接販売または取引所仲介

function executePayment (address receiver, address seller, uint 256[] tokenIds, uint256 payment, string tokenType, int256 trxnType) public virtual nonReentrant returns (bool)
```

戻り値のブール値は、関数の実行が成功した場合は`true`、失敗した場合は`false`です。

<a name="r33">**[R33]**</a> *`trxnType`に関係なく、入力データに対するビジネスルールは以下の通りです:*

* *`tokenIds`配列内のすべての購入NFTが存在し、焼却されていないこと。*
* *`tokenType`はサポートされているトークンである必要があります。*
* *`trxnType`は0(直接販売)または1(取引所仲介販売)、またはその他のサポートされているタイプに設定される必要があります。*
* *`receiver`はNULLでもよいが、ゼロアドレスであってはいけません。*
* *`seller`は対応するリストのアドレスである必要があります。*
* *`msg.sender`はコントラクトであってはいけません。ただし、NFTコントラクトにホワイトリストされている場合を除きます。*

以下では、最小限必要な2つのトランザクションタイプの違いについてのみ説明します。

<a name="r34">**[R34]**</a> *`trxnType = 0`の場合、以下のルールに基づいてリストに対して支払いデータを検証する必要があります:*

* *NFTがリストされている必要がある*
* *`payment`はリスト価格以上である必要がある。*
* *リストされたNFTが支払いデータのNFTと一致する必要がある。*
* *リストされたNFTが`seller`によって管理されている必要がある。*

<a name="r35">**[R35]**</a> *[**[R33]**](#r33)、および`trxnType = 0`の[**[R34]**](#r34)のすべてのチェックに合格した場合、`executePayment`関数は`recipient = address(this)`および`amount = payment`でERC-20コントラクト(`tokenType`)の`transfer`関数を呼び出す必要があります。*

買い手の`approve`トランザクションで設定された利用可能な許可から、NFTコントラクトが自身に支払うことに注意してください。

<a name="r36">**[R36]**</a> *`trxnType = 1`の場合、支払いが成功した場合、`registeredPayment`マッピングを更新し、別の`safeTransferFrom`呼び出しで検証できるようにする必要があり、成功した場合は`true`を、失敗した場合は`false`を返す必要があります。*

<a name="r37">**[R37]**</a> *`trxnType = 0`の場合、メッセージデータを持つ`_safeTransferFrom`関数の内部バージョンを呼び出して、NFTを買い手に転送する必要があり、成功した場合は、買い手に`MINTER_ROLE`を与える必要があります(買い手がすでにその役割を持っている場合を除く)。*

注意: `_safeTransferFrom`関数は`safeTransferFrom`と同じ構造ですが、入力データの検証をスキップします。

<a name="r38">**[R38]**</a> *`trxnType = 0`の場合、NFT転送が成功したら、NFTのリストを削除する必要があります。*

<a name="r39">**[R39]**</a> *プロトコルトークンを支払いトークンとして使用する場合、`trxnType`に関係なく、買い手はプロトコルトークンをエスクローとしてNFTコントラクトに送る必要があり、`msg.data`には支払われたNFTの配列`uint256[] tokenIds`をエンコードする必要があります。*

<a name="r40">**[R40]**</a> *プロトコルトークンをNFTコントラクトで受け取るために、payable fallback関数(`fallback() external payable`)を実装する必要があります。*

支払いに使用されたNFTの情報を渡す必要があるため、単純な`receive()`フォールバック関数は`msg.data`を送信できないため許可されません。

<a name="r41">**[R41]**</a> *フォールバック関数の`msg.data`には最小限以下のデータが含まれている必要があります:
`address memory seller, uint256[] memory _tokenId, address memory receiver, int256 memory trxnType`*

<a name="r42">**[R42]**</a *`trxnType`が'0'、'1'、またはその他のサポートされているタイプのいずれでもない場合、フォールバック関数は`revert`する必要があります。*


<a name="r43">**[R43]**</a> *`trxnType`が'0'または'1'に等しい場合、フォールバック関数は[**[R33]**](#r33)から[**[R38]**](#r38)の要件を満たす必要があり、そうでない場合はフォールバック関数は`revert`する必要があります。*

<a name="r44">**[R44]**</a> *取引の失敗(直接販売の場合、`trxnType = 0`)、または買い手が購入を変更した場合(取引所仲介販売の場合、`trxnType = 1`)、提出された支払いを`reversePayment`関数を使ってリバースできる必要があります。関数のインターフェースは以下の通りです:*

```
/// @dev 販売が完了する前に支払いを逆転させる機能の定義
/// @param paymentId 支払いが行われた一意の識別子
/// @param tokenType 支払いに使用されたトークンの種類
function reversePayment(uint256 paymentId, string memory tokenType) public virtual returns (bool)
```

戻り値のブール値は、関数の実行が成功した場合は`true`、失敗した場合は`false`です。

注意: Open Zeppelinライブラリの`nonReentrant`などの再入力保護が強く推奨されます。なぜなら、資金が支払われるためです。

<a name="r45">**[R45]**</a> *`reversePayment`関数のビジネスルールは以下の通りです:*

* *`paymentId`と`tokenType`に対して登録された支払いが存在する必要がある。*
* *`msg.sender`は登録された支払いの買い手アドレスである必要がある。*
* *支払い金額は0より大きい必要がある。*
* *支払いが正常に逆転された場合、登録された支払いは削除される必要があり、そうでない場合は関数は失敗する必要がある。*

### 修正されたNFT転送関数

このドキュメントは、以下のように与えられたERC-721インターフェースフォーマットに従う`safeTransferFrom`関数を採用しています:

```
function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external virtual override
```

注意: NFTを転送するには、ロイヤルティが適切に分配された後に、いくつかの要件を満たす必要があります。また、一度に複数のトークンを転送する機能も考慮されています。ただし、標準インターフェースでは1つのトークンしか転送できません。ERC-721標準に準拠するために、このドキュメントでは`tokenId`を最初のNFTの転送にのみ使用します。その他の転送関連データは`_data`でエンコードされます。

高レベルの要件は以下の通りです:

* `_data`でエンコードされた取引の支払いパラメータを検証する必要がある。
* 売り手と売却されたNFTトークンが存在し、売り手がそのトークンの所有者である必要がある。
* `msg.sender`は売り手アドレスまたは承認されたアドレスである必要がある。
* NFTスマートコントラクトが受け取った取引の支払いが、すべてのロイヤルティサブアカウントの所有者に正しく分配される。
* NFTトークンは、関連するすべてのロイヤルティサブアカウントとその所有者に適切に付与された後に転送される。

また、ロイヤルティ回避攻撃を避けるために、NFT転送関数は1つしかないことに注意してください。

<a name="r46">**[R46]**</a> *したがって、`data`なしの`transferFrom`と`safeTransferFrom`は無効にされる必要があります。*

これは、たとえば`revert`ステートメントを使用した`override`関数によって実現できます。

<a name="r47">**[R47]**</a> *関数の入力パラメータに対する要件は以下の通りです:*

* *`from`はアドレス`0`であってはいけません。*
* *`from`は`tokenId`と`_data`に含まれる他のトークンの所有者または`approved`である必要があります。*
* *`from`はスマートコントラクトではない必要があり、ホワイトリストに登録されている場合を除きます。*
* *`tokenId`と`_data`に含まれる他のトークンに、ロイヤルティアカウントが関連付けられている必要があります。*
* *`_data`はNULLであってはいけません。*
* *`msg.sender`は`from`と等しいか、`approved`アドレス、またはホワイトリストされたコントラクトである必要があります。*

注意: このドキュメントの文脈では、コントラクトの作成中(つまりコンストラクタの実行中)のみが可能な攻撃ベクトルであり、転送シナリオで慎重に扱う必要があります。

`_data`オブジェクトについて。

<a name="r48">**[R48]**</a> *`_data`オブジェクトには最小限以下の支払いパラメータが含まれている必要があります:*

* *売り手アドレスとしての`address`。*
* *買い手アドレスとしての`address`。*
* *受取人アドレスとしての`address`。*
* *トークン識別子としての`uint256[]`。*
* *支払いに使用されるトークンの種類。*
* *NFTコントラクトに支払われた金額としての`uint256`。*
* *登録された支払いの識別子。*
* *基盤となるブロックチェーンのID、`block.chainid`。*

<a name="r49">**[R49]**</a> *`_data`の支払いデータに対して以下のビジネスルールが満たされる必要があります:*

* *`seller == from`。*
* *`tokenId[0] == tokenId`。*
* *各トークンに`_tokenId`に関連付けられたロイヤルティアカウントがある。*
* *`chainid == block.chainid`。*
* *`buyer`は、`paymentId`の登録された支払いの買い手アドレスと等しい。*
* *`receiver == to`。*
* *トークンの受取人が売り手ではない。*
* *トークンの受取人がコントラクトではない、またはホワイトリストされたコントラクトである。*
* *支払いのすべてのNFTについて、`tokenId[i] = registeredPayment[paymentId].boughtTokens[i]`。*
* *`tokenType`はコントラクトでサポートされている。*
* *`allowedToken[tokenType]`はNULLではない。*
* *`tokenType = registeredPayment[paymentId].tokenType`。*
* *`payment > lastBalanceAllowedToken[allowedToken[listingId]]`。*
* *`payment = registeredPayment[paymentId].payment`。*

### 転送関数でのロイヤルティの分配

ロイヤルティの分配方法は、相互接続されたロイヤルティアカウントの階層構造を層に分解し、1層ずつ処理することです。ここでは、NFTと先祖の関係が利用されて、ロイヤルティアカウントチェーンを根元まで遡ることができます。

注意: 分配関数は、支払いがすべてのトークンに対して行われることを前提としています。つまり、分配関数の`payment`は、支払いに含まれるすべてのNFTで等しく分割されます。

<a name="r5">**[R50]**</a> *`distributePayment`関数のインターフェースは以下の定義に従う必要があります:

```
/// @dev 支払いをロイヤルティアカウントのチェーンに分配する関数
/// @param tokenId 販売に含まれ、関連するロイヤルティアカウントを検索するのに使用されるtokenId
/// @param payment 分配されるべきロイヤルティとしての支払い(部分)

function distributePayment (uint256 tokenId, uint265 payment) internal virtual returns (bool)
```

戻り値のブール値は、関数の実行が成功した場合は`true`、失敗した場合は`false`です。

前述のように、内部の`distributePayment`関数は、修正された`safeTransferFrom`関数内で呼び出されます。

注意: 2つの`uint256`の数値を掛ける必要があります - 支払い金額とパーセンテージ(10000 = 100%)。そして、100%を表す整数で割ることで、支払い金額にロイヤルティ分割パーセンテージを正しく適用できます。実装では、バッファーの過不足を防ぐために数値の処理に細心の注意を払う必要があります。

<a name="r51">**[R51]**</a> *`distributePayment`関数の処理ロジックは以下の通りである必要があります:*

* *渡された`tokenId`を使ってロイヤルティアカウント(`RA`)とそれに関連付けられたロイヤルティサブアカウントをロードする。*
* *RAの各ロイヤルティサブアカウントに対して以下のルールを適用する:*
    * *ロイヤルティサブアカウントの`isIndividual`が`true`の場合*
        * *そのロイヤルティサブアカウントのロイヤルティパーセンテージを`payment`に適用し、計算された金額(例: `royaltyAmountTemp`)をそのロイヤルティサブアカウントの`royaltybalance`に加える。*
        * *ロイヤルティサブアカウントの`accountId`への支払いの通知としてイベントを発行する。アセットID、アカウントID、トークンタイプ、ロイヤルティ残高を含む。*
        * *RAに`royaltyamountTemp`の金額を`balance`に追加する*
    * *ロイヤルティサブアカウントの`isIndividual`が`false`の場合*
        * *そのロイヤルティサブアカウントのロイヤルティパーセンテージを`payment`に適用し、一時的な新しい変数(例: `RApaymenttemp`)に保存するが、ロイヤルティサブアカウントの`royaltybalance`は0のままにする。*
    * *次に`ancestor`を使って、ロイヤルティアカウントマッピングを介して接続された`ancestor`のRAを取得する。*
    * *新しいRAをロードする*
        * *ロイヤルティサブアカウントの`isIndividual`が`true`の場合、次のRAのロイヤルティサブアカウントを渡し、`isIndividual = true`のルールを適用する。*
        * *ロイヤルティサブアカウントの`isIndividual`が`false`の場合、次のRAのロイヤルティサブアカウントを渡し、`isIndividual = false`のルールを適用する。*
    * *`ancestor`を持たず、すべてのロイヤルティサブアカウントの`isIndividual`が`true`であるRAに到達するまで、`isIndividual`が`true`と`false`の手順を繰り返す。そして、その`RA`のすべてのロイヤルティサブアカウントに対して`isIndividual = true`のルールを適用する。*

### 承認アドレス(`from`)へのロイヤルティ支払いによるサブアカウント所有権の更新

所有権の移転を簡素化するために、まず承認されたアドレス(非コントラクトNFTオーナー)、`from`にロイヤルティの自分の分担を支払います。そして、新しい所有者、`to`でロイヤルティサブアカウントを更新します。これは、転送される各トークンについて繰り返されます。

<a name="r52">**[R52]**</a> *ビジネスルールは以下の通りです:*

* *内部版の`royaltyPayOut`関数は、`from`アドレスが所有するロイヤルティサブアカウントの全ロイヤルティ残高を`from`アドレスに支払う必要がある。*
* *ペイアウト関数が正常に完了し、`royaltybalance = 0`になった後にのみ、ロイヤルティサブアカウントを新しい所有者で更新する必要がある。*

プロセスの最後のステップは、購入のNFTを`to`アドレスに転送することです。

<a name="r53">**[R53]**</a> *すべてのNFT(バッチ内)について、所有権の移転を完了するために、`to`アドレスは`approved`(ERC-721関数)されている必要があります:*

```
_approve(to, tokenId[i]);
```

NFTの技術的な所有者はNFTコントラクトのままです。

### 成功した転送後の支払いエントリーの削除

実際の所有権、承認されたアドレスが更新された後にのみ、支払い登録エントリーを削除できます。


<a name="r54">**[R54]**</a> *`approve`関係が`to`アドレスに正常に更新された後、登録された支払いを削除する必要があります。*

### `safeTransferFrom`関数でのNFTオーナー(`from`アドレス)へのロイヤルティ支払い

ペイアウト関数には2つのバージョンがあります - `public`関数と`internal`関数 - 購入時のペイアウトか、ロイヤルティサブアカウントの所有者による要求かによって異なります。

<a name="r55">**[R55]**</a> *public `royaltyPayOut`関数のインターフェースは以下の定義に従う必要があります:*

```
/// @dev ロイヤルティ支払いを行う関数
/// @param tokenId NFTトークンの識別子
/// @param RAsubaccount ペイアウトが行われるべきロイヤルティサブアカウントのアドレス
/// @param receiver ペイアウトを受け取るアドレス
/// @param amount ペイアウトされる金額

function royaltyPayOut (uint256 tokenId, address RAsubaccount, address payable payoutAccount, uint256 amount) public virtual nonReentrant returns (bool)
```

戻り値のブール値は、関数の実行が成功した場合は`true`、失敗した場合は`false`です。

注意: この関数には、資金が支払われるため、Open Zeppelinライブラリの`nonReentrant`修飾子による再入力保護がなされています。

<a name="r56">**[R56]**</a> *`royaltyPayOut`関数の入力パラメータは以下の要件を満たす必要があります:*

* *`msg.sender == RAsubaccount`。*
* *`tokenId`が存在し、焼却されていないこと。*
* *`tokenId`がロイヤルティアカウントに関連付けられていること。*
* *`RAsubaccount`が`tokenId`のロイヤルティアカウントのロイヤルティサブアカウントの有効な`accountId`であること。*
* *ロイヤルティサブアカウント`RAsubaccount`の`isIndividual == true`であること。*
* *`amount <= RAsubaccount`のロイヤルティ残高。*

<a name="r57">**[R57]**</a> *内部の`_royaltyPayOut`関数のインターフェースは以下の定義に従う必要があります:*

```
function _royaltyPayOut (uint256 tokenId, address RAsubaccount, address payable payoutAccount, uint256 amount) public virtual returns (bool)
```

<a name="r58">**[R58]**</a> *内部の`_royaltyPayOut`関数は以下のアクションを実行する必要があります:

* *`payoutaccount`に支払いを送る。*
* *支払いが成功した場合、ロイヤルティサブアカウント`RAsubaccount`の`royaltybalance`を更新する。*

<a name="r59">**[R59]**</a> *ロイヤルティ支払いを受取人に送金するには以下の手順を踏む必要があります:*

* *ロイヤルティサブアカウントを見つける。*
* *ロイヤルティサブアカウントから`tokenType`を抽出する。*
* *トークンタイプに基づいて、以下のいずれかに`payoutAccount`に送金する:*
    * *'ETH' / 関連プロトコルトークン*
    * *その他のトークン(トークンタイプに基づく)*
* *ペイアウトトランザクションが成功した場合のみ、ロイヤルティサブアカウント`RAsubaccount`の`royaltybalance`から`amount`を差し引き、関数の戻り値として`true`を返す。そうでない場合は`false`を返す。*

## 根拠

NFTのロイヤルティは本質的に、配布ライセンスの問題です。買い手は、複製、改変などが可能な資産/コンテンツの権利を取得します。したがって、包括的な仕様では、動機の項で詳述されているように、1つ以上の資産が元の資産から派生している階層的なロイヤルティに対処する必要があります。

この複雑な相続問題を解決するために、このプロポーザルの設計では、まず深さNの階層ツリーの再帰的な問題を、さらに N 個の個別の問題に分解しています。そして、さらにツリー構造を1層ずつの問題に分解しています。この設計により、ツリーの最下層から根元まで最も効率的に移動できます。これは、`distributePayment`関数と、ツリー構造を可能にするNFTデータ構造(例: `ancestry`、`royaltyAccount`、`RAsubaccount`)の設計によって実現されています。

ロイヤルティの支払いの際の膨大なガス代を避けるため(ブロックガスリミットを超える可能性がある大規模なロイヤルティツリーの場合)、受取人のロイヤルティ残高を維持するロイヤルティ会計システムを作成する必要がありました。これは、`royaltyAccount`、`RAsubaccount`データ構造と関連するCRUD操作、および個別かつ要求に応じてのみ行われるロイヤルティ支払い(`royaltyPayout`関数の設計)によって実現されています。

さらに、ロイヤルティを計算して支払うためには、NFTの買い付けと売却、および資金の交換について、スマートコントラクトが認識している必要があります。これらの買い付けと売却は、NFTコントラクトを通じて直接行うことも、最も一般的な現在の方法である取引所仲介で行うこともできます - これは集中化の要因となります! 購入プロセスに対するこの2つのモードを考慮した設計が選択されています。

購入プロセスの開始時にNFTコントラクトを認識させるには、認可されたユーザーアドレスがNFTを直接販売のためにリストアップできるようにする一方で、取引所仲介の購入の場合は、NFTコントラクトに支払いを登録する必要があります。

ロイヤルティの回避を避けるため、買い手はいつも直接NFTコントラクトに支払い、売り手には支払いません。その代わり、売り手はNFTコントラクトのロイヤルティ分配機能を通じて支払われ、後に支払いを要求することができます。その結果、そして重要な設計上の選択として、ERC-721に準拠するためには、NFTコントラクトがNFTの所有者であり、実際の所有者は`approved`アドレスである必要があります。

この仕様の設計では、支払いプロセスがETHかERC-20トークンかによって異なることも考慮する必要がありました:

* ERC-20トークン
    1. 買い手は、選択した支払いトークン(ERC-20コントラクトアドレス)の購入価格、`payment`について、NFTコントラクトを`approve`する必要があります。
    2. ERC-20支払いトークンの場合、買い手はその後NFTコントラクトの`executePayment`を呼び出す必要があります - ERC-20は直接関与しません。
* 非ERC-20支払いの場合、買い手はプロトコルトークン(ETH)をNFTコントラクトに送る必要があり、`msg.data`にリストと支払い情報をエンコードする必要があります。

さらに、`executePayment`関数は、直接販売(NFTコントラクトを通じて)と取引所仲介販売の両方を処理する必要があり、それには直接販売か取引所仲介販売かを示すインジケーターが必要でした。

`executePayment`関数はまた、NFT転送と購入のクリーンアップ - リストの削除、登録された支払いの削除、ロイヤルティの分配、売り手への支払い、最後に買い手への転送 - も処理する必要があります。

ERC-721の設計に準拠しつつロイヤルティの回避を避けるために、ロイヤルティ管理プロセスを管理するための追加情報を提出できる唯一の転送関数を除き、すべての転送関数を無効にする必要がありました。安全性を確保するために、NFTが適切にロイヤルティを分配した後に転送されるよう、入力パラメータが複数の要件を満たす必要があります。設計では、直接販売と取引所仲介販売で転送を少し異なる方法で扱う必要があることも考慮されています。

最後に、NFTを`mint`および`burn`できるようにする必要があり、同時にツリー用のすべてのデータ構造を設定する必要がありました。

設計では、NFTがミントされる際に、そのNFTと所有者、そして先祖がいる場合はその先祖のロイヤルティアカウントに関連付けられたロイヤルティアカウントを作成する必要があります。そのために、仕様はERC-721の`_safemint`関数を新たに定義された`mint`関数で利用し、入力変数に対するさまざまなビジネスルールを適用しています。

ロイヤルティアカウントを持つNFTは焼却できます。ただし、ロイヤルティアカウントとその子孫(存在する場合)のすべてのロイヤルティが支払われるようにするために、いくつかの条件を満たす必要があります。さらに、子孫が存在する場合、それらが先祖よりも先に焼却されている必要があります。これらのルールが適切に強制されない場合、階層的なロイヤルティ構造の一部が壊れ、資金の損失や未払いロイヤルティなどの問題が発生する可能性があります。

## 下位互換性

このEIPはERC-721標準に下位互換性があり、新しいインターフェースと機能を導入しつつ、ERC-721標準の中核となるインターフェースと機能を維持しています。

## テストケース

完全なテストスイートは、リファレンス実装の一部です。

## リファレンス実装

標準のリファレンス実装であるTreetrunkは、treetrunk-nft-reference-implementationのpublic treetrunkioGitHubリポジトリにあります。

## セキュリティ上の考慮事項

このEIPはERC-721標準にロイヤルティの収集、分配、支払いを導入するため、攻撃ベクトルの数が増加します。最も重要な攻撃ベクトルのカテゴリとその緩和策について以下に説明します:

* **支払いとペイアウト**:
    * 再入力攻撃は、すべての支払い関数での再入力保護によって緩和されます。Open Zeppelinのリファレンス実装を参照してください。
    * 不正なアカウントからのペイアウト。緩和策: ロイヤルティサブアカウントには、少なくとも`msg.sender`がロイヤルティサブアカウントの所有者であることが必要です。
    * `executePayment`関数が失敗した場合、支払いがNFTコントラクトに引っかかる可能性があります。緩和策: 取引所仲介販売の場合、`executePayment`関数が失敗した場合、買い手は常に`reversePayment`で支払いを逆転させることができます。直接販売の場合、`reversePayment`は`executePayment`関数内で直接トリガーされます。
* **ロイヤルティの回避**:
    * オフチェーンの秘密鍵の交換
        * オフチェーンで秘密鍵と金銭を交換することは、どのようなシナリオでも防ぐことはできません。
    * NFTの所有者としてのスマートコントラクトウォレット
        * 複数のアドレスによって制御されるスマートコントラクトウォレットがNFTを所有し、ウォレット内で資産を移転することで、オフチェーンでの金銭の交換ができます。緩和策: 特別なシナリオ(コレクションなど)を除いて、スマートコントラクトがNFTを所有することを禁止する。
    * ロイヤルティ分配の拒否
        * NFTファミリーの特定の世代のNFTを購入した攻撃者が、多数の低いロイヤルティ分割パーセンテージを持つ不要なロイヤルティサブアカウントを追加し、それらの購入したNFTのさらに多くのプリントをミントし、それを繰り返して`maxGeneration`制限に達するまで行うことで、ガス切れやランタイムエラーを引き起こすことができます。NFT取引の下位階層では、ロイヤルティ分配関数の再帰的性質のため、多くのコードサイクルが必要になります。緩和策: ロイヤルティサブアカウントの数とロイヤルティ分割パーセンテージの制限を設ける。
        * 上記と同じアプローチ
上記と同じアプローチを使って、`addListNFT`関数をターゲットにすることで、多数の低価格でNFTをリストアップし、別のアカウントから購入することで、`executePayment`関数でガス切れやランタイムエラーを引き起こすことができます。緩和策: リストに含めることができるNFTの数を制限する。
        * NFTファミリーの作成者が、ロイヤルティ分配関数の再帰的性質のためにガス切れやランタイムエラーが発生する可能性のある、世代の数を多すぎると設定する可能性があります。緩和策: 作成者による`maxNumberGeneration`の制限。
    * 一般的な考慮事項: NFTファミリーの作成者は、NFTファミリーのビジネスモデルを慎重に検討し、最大世代数、ロイヤルティサブアカウント、プリントごとの印刷数、リストあたりのNFT数、許可される最大および最小ロイヤルティ分割パーセンテージなどのパラメータを適切に設定する必要があります。
* **フィッシング攻撃**
    * NFTフィッシング攻撃は、しばしば`approve`および`setApprovalForAll`関数をターゲットにし、NFTの所有者に、攻撃者のアカウントを1つまたはすべてのNFTの承認アカウントとして追加するトランザクションに署名させます。緩和策: このコントラクトはこれらのフィッシング攻撃に対して脆弱ではありません。なぜなら、すべてのNFT転送は販売であり、NFTコントラクト自体がすべてのNFTの所有者だからです。これは、購入後の転送が`_approve`関数で新しい所有者を設定することで実現されることを意味します。一般の`approve`関数を呼び出すと、`msg.sender`が不正なトランザクションのNFTの所有者ではないため、関数呼び出しがエラーになります。
    * 被害者にNFTを非常に低い価格でリストアップさせ、攻撃者がすぐに支払いを登録して実行するというNFTフィッシング攻撃をターゲットにした`addListNFT`関数。緩和策: 購入が影響を受けるまでの待機期間を実装し、被害者に`removeListNFT`関数を呼び出す時間を与えます。さらに、組み込みの2段階認証や、Googleオーセンティケーターなどの認証アプリを備えたウォレットソフトウェアを利用するなど、実装者が2段階認証を要求することもできます。

専門のセキュリティ分析ツールの使用に加えて、各実装でもセキュリティ監査を実施することをお勧めします。

## 著作権

著作権およびその関連権利は[CC0](../LICENSE.md)で放棄されています。