---
original: 3fbf5420555beb80badc7fcfabc611aced17067f480a82e5d499a8bf40bdfc46
---

---
eip: 5375
title: NFTの作者情報と同意
description: EIP-721のNFT作者と作者同意の拡張
author: Samuele Marro (@samuelemarro), Luca Donno (@lucadonnoh)
discussions-to: https://ethereum-magicians.org/t/eip-5375-nft-authorship/10182
status: Final
type: Standards Track
category: ERC
created: 2022-07-30
requires: 55, 155, 712, 721, 1155
---

## 概要

このEIPは、NFTの作者に関する情報を保存するためのJSONフォーマットを標準化しています。具体的には、作者名、アドレス、および_作者同意_の証明を提供する新しいフィールドを追加しています。作者同意の証明は、作者が自身の名前を作者として使用することに同意したことを示すものです。作者同意の証明は、作者であることの証明ではないことに注意してください。あるアドレスが同意できるのは、そのアドレスがNFTの作者であるとは限りません。

## 動機

現在、NFTの作者を特定する標準はありません。既存の手法には問題があります:

- `tx.origin`または`msg.sender`を使ってミントする
  - ミンターと作者が同一であると仮定する
  - 複数の作者をサポートしない
- 特定のIDの最初のTransferイベントを使う
  - コントラクト/ミンターが作者の同意なしに誰かを作者として主張できる
  - 複数の作者をサポートしない
- カスタムメソッドやカスタムJSONフィールドを使う
  - NFTプラットフォームによる個別のサポートが必要
  - コントラクト/ミンターが作者の同意なしに誰かを作者として主張できる

最も一般的な手法は最初のものです。しかし、ミンターと作者が同一でない状況がいくつかあります:

- コントラクトによってミントされたNFT
- Lazy Minting
- テクノロジーに精通していない作者や複雑なミントプロセスの場合の仲介者によるミント

このドキュメントでは、ミンターが作者情報を提供できるようにしつつ、作者の同意なしの作者主張を防ぐ標準を定義しています。

## 仕様

この文書の「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されるものとします。

この標準で使用されるすべてのアドレスは、[EIP-55](./eip-55.md)で説明されているケーシングルールに従わなければなりません。

### 定義

- **作者**: NFTの創造者
- **ミンター**: 実際のミントトランザクションを行う主体。ミンターと作者は同一である必要はありません
- **検証者**: NFTの作者を検証したい主体(ユーザーやNFTマーケットプレイスなど)
- **作者同意証明(ACP)**: 署名メッセージで、署名者がNFTの作者であることに同意することを証明するもの

### 作者情報のサポート

この標準は、`authorInfo`という新しいJSONフィールドを導入します。作者主張のための必須のインターフェースと、作者同意証明のためのオプションのインターフェースを提供します。

`authorInfo`はNFTメタデータのトップレベルフィールドです。具体的には:

- [EIP-721](./eip-721.md)のメタデータ拡張をサポートするコントラクトの場合、`tokenURI(uint256 _tokenId)`が返すJSONドキュメントには、トップレベルフィールドとして`authorInfo`を含める必要があります
- [EIP-1155](./eip-1155.md)のメタデータ拡張をサポートするコントラクトの場合、`uri(uint256 _id)`が返すJSONドキュメントには、トップレベルフィールドとして`authorInfo`を含める必要があります

`authorInfo`のJSONスキーマ(`ERC5375AuthorInfoSchema`)は以下のように定義されます:

```json
{
    "type": "object",
    "properties": {
        "consentInfo": {
            "type": "object",
            "description": "同意の検証に役立つヘルパーフィールド",
            "properties": {
                "chainId": {
                    "type": "integer",
                    "description": "EIP-155 chain id"
                },
                "id": {
                    "type": "string",
                    "description": "NFT id"
                },
                "contractAddress": {
                    "type": "string",
                    "description": "0x接頭辞付きのスマートコントラクトアドレス"
                }
            }
        },
        "authors": {
            "type": "array",
            "items": "ERC5375AuthorSchema"
        }
    },
    "required": [ "authors" ]
}
```

`authors`は空の配列であってもかまいません。

`ERC5375AuthorSchema`は以下のように定義されます:

```json
{
    "type": "object",
    "properties": {
        "address": {
            "type": "string",
            "description": "0x接頭辞付きの作者アドレス"
        },
        "consent": {
            "type": "ERC5375AuthorConsentSchema",
            "description": "作者同意情報"
        }
    },
    "required": [ "address" ]
}
```

さらに、`consent`フィールドが存在する場合、`authorInfo`の`consentInfo`フィールドも存在しなければなりません。

`ERC5375AuthorConsentSchema`は以下のように定義されます:

```json
{
    "type": "object",
    "properties": {
        "consentData": {
            "type": "object",
            "properties": {
                "version": {
                    "type": "string",
                    "description": "NFT作者同意スキーマのバージョン"
                },
                "issuer": {
                    "type": "string",
                    "description": "0x接頭辞付きの作者アドレス"
                },
                "metadataFields": {
                    "type": "object"
                }
            },
            "required": ["version", "issuer", "metadataFields"]
        },
        "publicKey": {
            "type": "string",
            "description": "作者のEVMパブリックキー"
        },
        "signature": {
            "type": "string",
            "description": "同意メッセージのEIP-712署名"
        }
    },
    "required": ["consentData", "publicKey", "signature"]
}
```

ここで、`metadataFields`は、作者が証明するJSONのトップレベルフィールド(「authorInfo」を除く)を含むオブジェクトです。`metadataFields`のキーは、フィールドの集合の(空集合を含む)部分集合である可能性があります。

`consentData`には、他のEIPで定義された追加のフィールドが含まれる可能性があります。`consentData`には、作者同意証明の有効性を検証するために必要な情報(他のフィールドに存在しない情報)が含まれている必要があります。

### 作者同意

同意は、[EIP-712](./eip-712.md)互換のメッセージに署名することで得られます。具体的な構造は以下のとおりです:

```solidity
struct Author {
    address subject;
    uint256 tokenId;
    string metadata;
}
```

ここで、`subject`はNFTコントラクトのアドレス、`tokenId`はNFTのIDを表し、`metadata`は`metadataFields`にリストされたフィールドのJSON エンコーディングです。`metadata`:

- `metadataFields`にリストされたフィールドと同じ順序で、同じフィールドを含む必要があります
- 非ASCII文字はすべてエスケープする必要があります。エスケープされた文字に16進数文字が含まれる場合、それらは大文字でなければなりません
- フィールド名や値の一部ではない空白を含んではいけません

例えば、トップレベルのJSONフィールドが以下の場合:

```json
{
    "name": "The Holy Hand Grenade of Antioch",
    "description": "Throw in the general direction of your favorite rabbit, et voilà",
    "damage": 500,
    "authors": [...],
    ...
}
```

`metadataFields`の内容が`["name", "description"]`の場合、`metadata`の内容は以下のようになります:

```json
{
    "name": "The Holy Hand Grenade of Antioch",
    "description": "Throw in the general direction of your favorite rabbit, et voil\u00E0"
}
```

`consentData`と同様に、このストラクチャにも他のEIPで定義された追加のフィールドが含まれる可能性があります。

ドメインセパレーターの構造は以下のとおりです:

```solidity
struct EIP712Domain {
    string name;
    string version;
    uint256 chainId;
}
```

ここで、`name`と`version`は`consentData`で説明したのと同じフィールドです。

このストラクチャにも、他のEIPで定義された追加のフィールドが含まれる可能性があります。

### 作者同意の検証

検証は、EIP-712に基づいて作者ごとに行われます。具体的には、JSONドキュメントD1が以下のすべての条件を満たす場合、同意証明は有効です:

- D1にはトップレベルの`authorInfo`フィールドが存在し、`ERC5375AuthorInfoSchema`に一致する
- `consent`が存在し、`ERC5375AuthorConsentSchema`に一致する
- `tokenURI`(EIP-721の場合)または`uri`(EIP-1155の場合)の呼び出しが返すJSONドキュメントD2の場合、`metadataFields`にリストされたすべてのトップレベルフィールドが存在し、同じ値を持つ
- JSONドキュメントで指定されたフィールドを使って計算された`signature`のEIP-712署名が有効である

検証者は、アドレスXに有効な同意証明があるからといって、Xが実際の作者であると仮定してはいけません。一方で、NFTに有効な同意証明がない場合、Xが実際の作者ではないと仮定してもかまいません。

## 根拠

### なぜ作者同意証明のみを提供するのか?

完全な作者証明(つまり、Aliceが唯一の作者であるという証明)をサポートするには、ある人物がNFTYの作者であるかどうかを証明するプロトコルが必要です。

議論のために、NFTYの作者を特定できるメソッドがあると仮定しましょう。しかし、攻撃者がYをわずかに変更して新しいNFTY'を作り、Y'の作者として正当に主張できてしまいます。これは、画像の一部のピクセルを変更したり、テキストの単語をシノニムに置き換えたりするなど、現実世界の例があります。
このような行為を防ぐには、2つのNFTが意味的に等価であるかどうかを正式に定義する必要があります。そのような概念を定義することが可能であっても、それはこのEIPの範囲を超えています。

ミンターのアドレスを作者のプロキシとして使う場合にも、同様の問題があることに注意してください。

### なぜオフチェーンなのか?

3つの理由があります:

- オフチェーンのサポートを追加しても、既存のスマートコントラクトを変更する必要がない
- オフチェーンのストレージはオンチェーンのストレージに比べて非常に安価なため、実装のハードルが低い
- 完全なオンチェーンの作者証明には一定の用途がある可能性がある(例えば、作者に特別な機能を提供するマーケットプレイス)が、作者同意にはそのような用途が限られている。作者同意は主に、ユーザーがNFTの主観的な価値を判断するために使用されるため

### なぜidやchainId、contractAddressを繰り返すのか?

多くの場合、これらのデータはコンテキスト情報から導出できます。ただし、JSONドキュメントにこれらを含めることで、JSONドキュメントのみを使って作者同意を検証できるようにしています。

### なぜ取り消しシステムを実装しないのか?

作者権は通常最終的なものです。NFTを作成したか否かのいずれかです。さらに、取り消しシステムを導入すると、スマートコントラクトの実装要件が増え、検証の複雑性も高まります。スマートコントラクトは、他のEIPで定義されているような取り消しシステムを実装してもかまいません。

#### なぜ署名メッセージの非ASCII文字をエスケープするのか?

EIP-712はオンチェーンの検証を念頭に設計されています。オンチェーンの検証は本EIPの優先事項ではありませんが、スマートコントラクトでの非ASCII文字の処理の複雑さが高いため、非ASCII文字はエスケープされます。


### 作者のための使いやすさの改善

作者はEIP-712メッセージに署名するだけで良いため、このプロトコルにより、ミンターが技術的な側面を処理しつつ、作者のウォレットの秘密を保持することができます。具体的には、作者は以下のことだけを行えば良くなります:

- EVMウォレットを取得する
- EIP-712メッセージの読み取りと署名の方法を学ぶ(Dappを使えば簡略化できることが多い)

一方で以下のことを行う必要がなくなります:

- チェーンのネイティブトークン(取引や橋渡しを通じて)を取得する
- トランザクションに署名する
- トランザクション手数料の仕組みを理解する
- トランザクションがブロックに含まれたかどうかを確認する

これにより、作者の技術的な障壁が減り、テクノロジーに精通した仲介者にキーを渡す必要がなくなるため、NFTの使いやすさが向上します。

### アドレスベースの同意の限界

この標準は、特定のアドレスが同意を提供したことを検証するプロトコルを定義しています。ただし、そのアドレスが期待される作者(「name」フィールドに提供されたもの)に対応していることを保証するものではありません。アドレスと実体の間のリンクを証明することは、このドキュメントの範囲を超えています。

## 下位互換性

下位互換性の問題は見つかりませんでした。

## セキュリティ上の考慮事項

### 攻撃

このEIPを悪用する可能性のある攻撃には、作者に望まない作者同意メッセージに署名させることが含まれます。そのため、作者は署名フィールドがすべて必要なものと一致することを必ず確認する必要があります。

より微妙な手法としては、`metadataFields`に重要なフィールドを追加しないことが考えられます。そうすることで、ミンターが重要な情報を変更しても、作者の署名が有効になる可能性があります。

### 非推奨の機能

`ERC5375AuthorInfoSchema`には当初、作者の人間可読の名前を指定するためのフィールドも含まれていました。しかし、作者なりすましのリスクが高いため、これは削除されました。

例えば:

- Aliceがボブの名前とアリスのアドレスを使ってNFTをミントする
- チャーリーはアドレスを確認せず、提供された名前を信頼する
- チャーリーはボブが作成したと思ってAliceのNFTを購入する

このため、スマートコントラクト開発者は、JSONドキュメントに検証できない情報を追加してはいけません。作者に関する複雑な情報(作者の名前など)を提供する最も安全な方法は、その情報がNFT自体ではなく_作者のアドレス_に関連付けられていることを証明することです。

### リプレイ攻撃への耐性

チェーンID、コントラクトアドレス、トークンIDによって、NFTを一意に識別できるため、ノンス・システムなどの追加のリプレイ攻撃対策は必要ありません。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)によって放棄されています。