---
original: c6b3a0abff2be0fd7a76d6c1b62a3fc2791bb6de4ca3f7500a85329f1030ede3
---

---
eip: 5630
title: 暗号化/復号化のための新しいアプローチ
description: Ethereumウォレットを使用した暗号化と復号化の仕様を定義します。
author: Firn Protocol (@firnprotocol), Fried L. Trout, Weiji Guo (@weijiguo)
discussions-to: https://ethereum-magicians.org/t/eip-5630-encryption-and-decryption/10761
status: Draft
type: Standards Track
category: ERC
created: 2022-09-07
---


## 概要

このEIPは、Ethereumキーを使用した新しい暗号化と復号化の方法を提案しています。このEIPは_secp256k1曲線_のみを使用し、2つの新しいRPCメソッド `eth_getEncryptionPublicKey` と `eth_performECDH` を提案しています。これら2つのメソッドを組み合わせることで、ユーザーは暗号化を受け取り、復号化を行うことができます。ウォレットには_コアのECDH操作_のみを実行させ、ECIESの操作は実装者に任せます(ただし、標準化されたECIESバージョンを提案しています)。以前のEIPでは、同じ秘密鍵を`secp256k1`曲線と`ec25519`曲線の両方で署名と暗号化に使用し、特定のECIESバージョンをハードコーディングしていました。

## 動機

いくつかの動機的な例を説明します。1つの主な動機は、Ethereumでの直接アドレス暗号化です。このEIPを使用すると、受信者との事前の直接チャネルがなくても、オンチェーンで暗号化されたメッセージを直接送信することができます。(このEIPでは、暗号文の生成_のみ_を標準化し、オンチェーンメッセージの送信方法は標準化していないことに注意してください。実際には、スマートコントラクトのインフラストラクチャが設定されることが理想的ですが、そうでない場合は、暗号化者が標準の`data`フィールドを利用できます。)

2つ目の例を説明します。ある一般的な設計パターンでは、dAppがユーザーに代わって新しい秘密を生成します。ユーザーにこの秘密を独立して保存、保護、バックアップさせるのではなく、dAppがこの秘密をユーザーが制御する公開鍵で暗号化し、その暗号文をセキュアなストレージ(例えばオンチェーン)に投稿することができれば、興味深いでしょう。このデザインパターンにより、_新しい_秘密のセキュリティをユーザーの既存のHDウォレットシードフレーズのセキュリティに基づけることができます。これにより、ユーザーが直接新しいキーを保存・管理する必要がなくなり、ユーザーエクスペリエンスの負担が大幅に軽減されます。この設計パターンは、Tornado Cashなどの一部のdAppで現在使用されています。

## 仕様

ここでは、我々のアプローチについて説明します。以前のEIPとの比較は**根拠**セクションで行います。以下では、Daniel R. L. BrownのSEC 1: Elliptic Curve Cryptographyを参照しています。

署名と暗号化の両方に`secp256k1`曲線を使用します。
暗号化にはECIESを使用します。ウォレットには_敏感なECDH操作のみ_を実行させ、ECIESの残りの部分は実装者に任せます。

すべてのバイナリデータは`0x`プレフィックス付きの16進文字列にシリアル化/デシリアル化されるものとします。また、秘密鍵と公開鍵は`0x`プレフィックス付き16進文字列で表し、公開鍵は圧縮形式で表します。Ethereumアカウントは通常の方法(`0x`プレフィックス付き、20バイトの16進文字列)で表します。楕円曲線点のシリアル化とデシリアル化には以下の標準を使用する必要があります:

- 点をシリアル化する: [SEC 1, §2.3.3]を使用し、点圧縮を行う。
- 点をデシリアル化する: [SEC 1, §2.3.3]を使用し、_点圧縮を要求する_。つまり:
  - 入力バイト列の長さは⌈log₂q / 8⌉ + 1 = `33`でなければならない。
  - 最初のバイトは`0x02`または`0x03`でなければならない。
  - 残りの32バイトで表される整数(ここでは[SEC 1, §2.3.8]に従う)は{0, ..., _p_ - 1}の範囲になり、さらにWeierstrass式X^3 + 7(mod _p_)の二次剰余でなければならない。

ECIESを実際に実装する場合、以下のバリアントを提案します。特に理由がない限り、実装者は以下の標準化されたオプションを使用するべきです:

- KDF: `ANSI-X9.63-KDF`、ハッシュ関数は`SHA-512`を使用
- HMAC: `HMAC–SHA-256–256`、32オクテット(256ビット)のキーを使用
- 対称暗号: `AES–256 in CBC mode`

ECIESの暗号文のバイナリ連結シリアル化モードを使用し、楕円曲線点は_圧縮_形式で表すものとします。

したがって、リクエスト:

```javascript
request({
  method: 'eth_getEncryptionPublicKey',
  params: [account]
})
```

ここで`account`は標準の20バイト、`0x`プレフィックス付き16進エンコードのEthereumアカウントです。クライアントは以下のように動作します:

- `account`に対応する秘密署名鍵`sk`を見つける。見つからない場合はエラーを返す。
- `sk`に対応する`secp256k1`公開鍵を計算する。
- この公開鍵を圧縮形式の`0x`プレフィックス付き16進文字列で返す([SEC 1, §2.3.3]に従う)。

リクエスト:

```javascript
request({
  method: 'eth_performECDH',
  params: [account, ephemeralKey]
})
```

ここで`account`は上記と同様で、`ephemeralKey`は上記の方法でエンコードされた楕円曲線点です:

- `account`に対応する秘密鍵`sk`を見つける。見つからない場合はエラーを返す。
- [SEC 1, §2.3.3]を使用して`ephemeralKey`を楕円曲線点にデシリアル化する(圧縮が必要)。デシリアル化に失敗した場合はエラーを返す。
- [SEC 1, §3.3.1]に従って楕円曲線Diffie–Hellmanの秘密を計算する。
- 結果のフィールド要素を[SEC 1, §2.3.5]に従って`0x`プレフィックス付き32バイト16進文字列で返す。

テストケースを以下に示します。

### スマートコントラクトへの暗号化

アカウント抽象化[EIP-4337](eip-4337.md)とスマートコントラクトウォレットの登場を踏まえ、コントラクトへの暗号化方法も指定します。
具体的には、コントラクトが暗号化方法をどのように広告するかを指定します。これは[EIP-1271](eip-1271.md)の暗号化版と見なすことができます。

仕様は以下の通りです。

```solidity
pragma solidity ^0.8.0;

contract ERC5630 {
  /**
   * @dev 提供されたプレーンテキストを、提供されたランダム性を使用して暗号化する必要がある。
   * @param plaintext      暗号化するプレーンテキスト
   * @param randomness     暗号化中に使用するエントロピー
   */
  function encryptTo(bytes memory plaintext, bytes32 randomness)
    public
    view
    returns (bytes memory ciphertext);
}
```

各コントラクトは`encryptTo`を自由に実装できますが、特に理由がない限り、上記のECIESバリアントを使用するべきです。

## 根拠

`secp256k1`曲線での署名と`ec25519`曲線での暗号化を同時に呼び出し、_しかも同じ秘密鍵を使用する_スキームには_セキュリティ証明がありません_。既知の攻撃はありませんが、このようなスキームを使用するのは望ましくありません。
代わりに、_同じ曲線_でサインと暗号化を行うことを提案します。この設定は以前の研究で検討されています。例えば、Degabriele, Lehmann, Paterson, Smart and Strefler, _On the Joint Security of Encryption and Signature in EMV_, 2011などです。この研究では、この結合スキームがジェネリックグループモデルで安全であることが示されています。
この結合スキーム(すなわち、同じ曲線でECDSAとECIESを使用すること)は、EMVペイメントの実稼働環境で使用されています。

さらに、アプローチのいくつかの側面について説明します。

**オンチェーンの公開鍵発見**。提案には重要な機能があり、アカウントが少なくとも1つのトランザクションに署名している場合、そのアカウントに対する暗号化を構築できます。
実際、アカウントに代わって署名されたものから、そのアカウントの`secp256k1`公開鍵を直接復元できます。

**ECDH vs. ECIES**。ウォレットには_敏感なECDH操作のみ_を実行させ、ECIESの残りの部分は実装者に任せます。これには2つの明確な利点があります:

- **柔軟性**。ウォレットの動作を更新することなく、実装者が任意のECIESバリアントを選択できます。
- **帯域幅**。提案では、クライアントとウォレット間で交換されるメッセージが小さい(32バイト程度)ため、プレーンテキストと暗号文が大きい場合や、クライアントとウォレットがインターネット接続で分離されている場合に重要になる可能性があります。

**ツイスト攻撃**。Christian Lundkvistによるある GitHub投稿では、`secp256k1`曲線に対する「ツイスト攻撃」について警告されています。これらの攻撃は、このEIPには適用されません。その理由は以下の通りです:

- **クラシックなECDHにのみ適用され、ECIESには適用されない**。この攻撃はクラシックなECDH(つまり、両当事者が永続的な認証付き公開鍵を使用する場合)にのみ適用され、ECIESには適用されません。攻撃者が被害者に敏感なスカラーで攻撃者が提供したポイントを指数化させ、その結果を攻撃者に送り返させるというパターンが必要ですが、これはクラシックなDiffie–Hellmanでのみ発生し、ECIESでは発生しません。ECIESでは、唯一の敏感なDiffie–Hellman操作は復号化時に行われますが、この場合、被害者(復号化者)は結果のDHポイントを攻撃者に送り返しません(代わりに、ローカルでAES復号化を試みます)。_暗号化_時の指数化は、秘密を持たない暗号化者によって行われるので、攻撃者が何かを学ぶことはできません。
- **圧縮ポイントにのみ適用される**。このEIPでは圧縮ポイントを使用しています。圧縮ポイントを使用する場合、各33バイトの文字列は必ず正しい曲線上のポイントに解決されるか、合理的な解釈がありません。「曲線上にないポイント」(特に、検出されずに通過できるようなもの)はありません。
- **ポイントが曲線上にあることを確認しないと適用される**。しかし、これは私たちには適用されません。圧縮ポイントを使用するためです(上記参照)。また、すべての検証を実行することを要求しています。

## 下位互換性

`eth_performECDH`メソッドは新しいため、下位互換性の問題はありません。

以前の提案では`eth_getEncryptionPublicKey`メソッド(この EIP とは無関係な`eth_decrypt`メソッドも提案)を提案していました。我々の提案では、`eth_getEncryptionPublicKey`メソッドの以前の動作を上書きします。
これは問題にならないと考えられます。暗号化キーは暗号化時にのみ新しく取得される必要があるためです。一方で、_新しい_暗号文は
我々の新しいアプローチを使用して生成されます。
(特に、以前のEIPで生成された暗号文は、我々の新しいアプローチを使用しても`eth_decrypt`で復号化できます。)

いずれにしろ、以前のEIPは標準化されておらず、現在_どの_本番環境コードでも非推奨の形で実装されていることはありません。

### テストケース

秘密_署名鍵_

```
    0x439047a312c8502d7dd276540e89fe6639d39da1d8466f79be390579d7eaa3b2
```

Ethereumアドレス`0x72682F2A3c160947696ac3c9CC48d290aa89549c`に対応する`secp256k1`公開鍵は

```
    0x03ff5763a2d3113229f2eda8305fae5cc1729e89037532a42df357437532770010
```

したがって、リクエスト:

```javascript
request({
  method: 'eth_getEncryptionPublicKey',
  params: ["0x72682F2A3c160947696ac3c9CC48d290aa89549c"]
})
```

は以下を返すはずです:

```javascript
"0x03ff5763a2d3113229f2eda8305fae5cc1729e89037532a42df357437532770010"
```

暗号化者が上記の公開鍵を使用して、例えば`I use Firn Protocol to gain privacy on Ethereum.`というメッセージを暗号化した場合、以下のような暗号文が得られるでしょう:

```javascript
"0x036f06f9355b0e3f7d2971da61834513d5870413d28a16d7d68ce05dc78744daf850e6c2af8fb38e3e31d679deac82bd12148332fa0e34aecb31981bd4fe8f7ac1b74866ce65cbe848ee7a9d39093e0de0bd8523a615af8d6a83bbd8541bf174f47b1ea2bd57396b4a950a0a2eb77af09e36bd5832b8841848a8b302bd816c41ce"
```

この暗号文を受け取ると、復号化者は関連する一時的な公開鍵を抽出します:

```javascript
"0x036f06f9355b0e3f7d2971da61834513d5870413d28a16d7d68ce05dc78744daf8"
```

そして、以下のリクエストを送信します:

```javascript
request({
  method: 'eth_performECDH',
  params: [
    "0x72682F2A3c160947696ac3c9CC48d290aa89549c",
    "0x036f06f9355b0e3f7d2971da61834513d5870413d28a16d7d68ce05dc78744daf8"
  ]
})
```

これにより、Diffie–Hellmanの秘密が返されます:

```javascript
"0x4ad782e7409702101abe6d0279f242a2c545c46dd50a6704a4b9e3ae2730522e"
```

上記のECIESバリアントを使用して処理を続けることで、復号化者は`I use Firn Protocol to gain privacy on Ethereum.`という文字列を得ることができます。

## セキュリティ上の考慮事項

提案では、十分に標準化されたアルゴリズムを使用し、すべての最良の実践に従っています。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。