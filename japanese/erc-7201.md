---
original: 03485015b57d824e4018a4c47c91ccd3b90c03087f6d9d004a7a4c0e1abfa8c1
---

---
eip: 7201
title: 名前空間ストレージレイアウト
description: 名前空間ストレージパターンでのストラクチャのストレージ位置に関する規約。
author: Francisco Giordano (@frangio), Hadrien Croubois (@Amxx), Ernesto García (@ernestognw), Eric Lau (@ericglau)
discussions-to: https://ethereum-magicians.org/t/eip-7201-namespaced-storage-layout/14796
status: 最終
type: 標準トラック
category: ERC
created: 2023-06-20
---

## 概要

Solidity または Vyper のソースコードでストレージ名前空間とその位置を文書化するための NatSpec アノテーション `@custom:storage-location` を定義します。さらに、任意の識別子から位置を導出するための式を定義します。この式は、Solidity および Vyper のストレージレイアウトで使用されるレイアウトとの衝突を防ぐように選択されています。

## 動機

Solidity や Vyper などのスマートコントラクト言語は、ツリー状のストレージレイアウトに依存しています。このツリーはスロット0から始まり、連続する変数の連続するチャンクで構成されています。ハッシュは、マッピングや動的配列の値を含むチャンクが衝突しないようにするために使用されます。これは多くのコントラクトにとって十分です。ただし、スマートコントラクト開発で使用されるさまざまなデザインパターンにとっては課題となります。1つの例は、`DELEGATECALL`を使ってコードを複数のコントラクトから実行するモジュラーデザインで、これらすべてが同じストレージ領域を共有し、その使用方法を慎重に調整する必要があります。別の例は、アップグレード可能なコントラクトで、既存の変数の割り当てられたストレージ位置に影響を与える可能性のある新しい状態変数を追加するのが難しい場合です。

このデフォルトのストレージレイアウトを使用する代わりに、これらのパターンは状態変数をストレージ空間全体に配置することで恩恵を受けることができます。通常、ハッシュによって得られる擬似ランダムな位置に配置されます。各値は完全に異なる位置に配置される可能性がありますが、一般的により密接に関連する値は Solidity の構造体にまとめられ、ストレージ内で共同配置されます。これらの擬似ランダムな位置は、デフォルトのものと同じ規則に従う新しいストレージツリーのルートになることができます。このランダムなルートがデフォルトのツリーの一部ではないように構築されれば、お互いに衝突しない独立したスペースが定義されるはずです。

これらのストレージ使用パターンは、Solidity や Vyper のコンパイラには見えません。なぜなら、Solidity の状態変数として表現されていないためです。静的アナライザーやブロックチェーンエクスプローラーなどのスマートコントラクトツールは、しばしばコントラクトデータのストレージ位置を知る必要があります。ストレージレイアウトの位置を標準化することで、これらのツールがこれらのデザインパターンが使用されているコントラクトを正しく解釈できるようになります。

## 仕様

### 前提条件

_名前空間_は、動的配列やマッピングを含む順序付けられた変数のセットで構成され、デフォルトのストレージレイアウトと同じ規則に従ってその値が配置されますが、スロット0ではなく別の位置にルーティングされます。名前空間を使ってストレージを整理するコントラクトは、_名前空間ストレージ_を使用していると言われます。

_名前空間 ID_ は、コントラクト内の名前空間を識別する文字列です。空白文字は含まれていません。

### `@custom:storage-location`

コントラクト内の名前空間は、構造体型として実装されるべきです。これらの構造体には、`@custom:storage-location <FORMULA_ID>:<NAMESPACE_ID>`という NatSpec タグを付ける必要があります。ここで、`<FORMULA_ID>`は、名前空間 ID に基づいてストレージ位置を計算するために使用される式を識別します。_(注意: Solidity コンパイラは v0.8.20 以降、この注釈を AST に含めるようになったので、このパターンを使用する際は、この最小バージョンのコンパイラを推奨します。)_ コントラクト外にあるこのようなアノテーションが付いた構造体は、ソースコード内の任意のコントラクトの名前空間とは見なされません。

### 式

`erc7201`で識別される式は、`erc7201(id: string) = keccak256(keccak256(id) - 1) & ~0xff`と定義されます。Solidity では、これは `keccak256(abi.encode(uint256(keccak256(bytes(id))) - 1)) & ~bytes32(uint256(0xff))`という式に相当します。この式を使用する場合、アノテーションは `@custom:storage-location erc7201:<NAMESPACE_ID>`となります。例えば、`@custom:storage-location erc7201:foobar`は、ID が `"foobar"`の名前空間が `erc7201("foobar")`に位置していることを示します。

将来の EIP では、一意の式識別子を持つ新しい式を定義する可能性があります。この EIP で設定された規則に従い、`erc1234`のようなフォーマットの識別子を使用することをお勧めします。

## 根拠

Solidity と Vyper が使用するツリー状のストレージレイアウトは、次の文法に従います(ルート=0):

$L_{root} := \mathit{root} \mid L_{root} + n \mid \texttt{keccak256}(L_{root}) \mid \texttt{keccak256}(H(k) \oplus L_{root}) \mid \texttt{keccak256}(L_{root} \oplus H(k))$

ルートの要件は、Solidity と Vyper の標準ストレージツリー(ルート=0)の一部になるような位置や、他の名前空間(別のルート)から派生したストレージツリーの一部にもならないことです。これは、複数の名前空間を意図的または偶発的に標準ストレージレイアウトと一緒に使用できるようにするためです。式の `keccak256(id) - 1`という用語は、Solidity では使用されていない位置として選択されていますが、最終的な位置として使用されるわけではありません。なぜなら、名前空間は1スロットより大きくなる可能性があり、`keccak256(id) + n`に及ぶ可能性があるためです。これは Solidity によって使用される可能性があります。2つ目のハッシュを追加することで、keccak256の衝突耐性と配列が非常に大きくないという前提の下で、名前空間が標準ストレージから完全に分離されることが保証されます。

さらに、名前空間の位置は256の倍数に揃えられています。これは、Verkle状態ツリーの移行後のガススケジュールの変更を見越した最適化の可能性があります。その場合、256個のストレージスロットのグループがまとめて温まる可能性があります。

### 命名

このパターンは時々「ダイアモンドストレージ」と呼ばれています。これにより、「ダイアモンドプロキシパターン」と混同されてしまいます。しかし、それらは互いに独立して使用できます。このEIPでは、プロキシパターンと明確に区別するために、別の名前を選択しました。

## 下位互換性

下位互換性の問題は見つかりませんでした。

## 参考実装

```solidity
pragma solidity ^0.8.20;

contract Example {
    /// @custom:storage-location erc7201:example.main
    struct MainStorage {
        uint256 x;
        uint256 y;
    }

    // keccak256(abi.encode(uint256(keccak256("example.main")) - 1)) & ~bytes32(uint256(0xff));
    bytes32 private constant MAIN_STORAGE_LOCATION =
        0x183a6125c38840424c4a85fa12bab2ab606c4b6d0e7cc73c0c06ba5300eab500;

    function _getMainStorage() private pure returns (MainStorage storage $) {
        assembly {
            $.slot := MAIN_STORAGE_LOCATION
        }
    }

    function _getXTimesY() internal view returns (uint256) {
        MainStorage storage $ = _getMainStorage();
        return $.x * $.y;
    }
}
```

## セキュリティ上の考慮事項

名前空間は、他の名前空間やSolidity/Vyperの標準ストレージレイアウトとの衝突を避ける必要があります。このEIPで定義された式は、keccak256の衝突耐性を前提として、任意の名前空間IDに対してこの性質を保証します(根拠を参照)。

`@custom:storage-location`は、現在のコンパイラが規則を強制したり意味を持たせたりしないNatSpecアノテーションです。名前空間の実装と、アノテーションで主張されているとおりの名前空間の使用は、コントラクト開発者の責任です。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。