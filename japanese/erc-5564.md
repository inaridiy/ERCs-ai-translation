---
original: a2573a9107b1a77be0d75f85c11b98bbf9846766f9cee72243d44fd56d14e54c
---

---
eip: 5564
title: ステルスアドレス
description: プライベートで非対話型のトランザクション
author: Toni Wahrstätter (@nerolation)、Matt Solomon (@mds1)、Ben DiFrancesco (@apbendi)、Vitalik Buterin (@vbuterin)
discussions-to: https://ethereum-magicians.org/t/eip-5566-stealth-addresses-for-smart-contract-wallets/10614
status: 最終
type: Standards Track
category: ERC
created: 2022-08-13
---

## 概要

この仕様は、送信者がトランザクションや送金の際に、受信者専用の非対話型のプライベートアカウントを生成できるステルスアドレスとの対話方法を標準化するものです。さらに、この仕様では、`0x55649E01B5Df198D18D95b5cc5051630cfD45564`にデプロイされたシングルトンコントラクトから必要な情報を発信することで、開発者がこのERCに基づいたステルスアドレスプロトコルを作成できるようにしています。このベースの実装に加えて、この仕様では、SECP256k1曲線を使った最初の実装についても説明しています。

## 動機

非対話型のステルスアドレス生成の標準化は、送信者と受信者の間の共有秘密を使ってステルスアドレスを生成することで、受信者のプライバシーを保護し、Ethereum ネットワークやEVM互換チェーンのプライバシー機能を大幅に向上させる可能性があります。受信者だけがステルスアドレスの秘密鍵を持っているため、観察者はステルスアドレスと受信者の身元を関連付けることができません。単一のコントラクトを介して複数の暗号化スキームに対応することで、受信者は自分宛ての取引を見逃すことなく一元的に監視できるようになります。

## 仕様

この文書における「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119に記載されているように解釈されるものとします。

定義:

- 「ステルスメタアドレス」とは、受信者のステルスアドレスを計算するために使用できる1つまたは2つの公開鍵のセットです。
- 「スペンディングキー」とは、ステルスアドレスに送金された資金を使用するために使用できる秘密鍵です。「スペンディング公開鍵」はその対応する公開鍵です。
- 「ビューイングキー」とは、ステルスアドレスに送金された資金が自分のものかどうかを判断するために使用できる秘密鍵です。「ビューイング公開鍵」はその対応する公開鍵です。

異なるステルスアドレススキームでは、ステルスメタアドレスの長さが異なります。長さが`n`バイトの公開鍵を使うスキームでは、ステルスメタアドレスを次のように定義する必要があります:

- 長さが`n`のステルスメタアドレスでは、スペンディング公開鍵とビューイング公開鍵が同じです。
- 長さが`2n`のステルスメタアドレスでは、最初の`n`バイトがスペンディング公開鍵、最後の`n`バイトがビューイング公開鍵です。

受信者のステルスメタアドレスを受け取った送信者は、次のシグネチャのメソッドを呼び出してステルスアドレスを生成する必要があります:

```solidity
/// @notice ステルスメタアドレスからステルスアドレスを生成する
/// @param stealthMetaAddress 受信者のステルスメタアドレス
/// @return stealthAddress 受信者のステルスアドレス
/// @return ephemeralPubKey ステルスアドレスを生成するために使用された一時的な公開鍵
/// @return viewTag 共有秘密から派生したビュータグ
function generateStealthAddress(bytes memory stealthMetaAddress)
  external
  view
  returns (address stealthAddress, bytes memory ephemeralPubKey, bytes1 viewTag);
```

受信者は、次のシグネチャのメソッドを呼び出してステルスアドレスが自分のものかどうかを確認できます:

```solidity
/// @notice ステルスアドレスに送金された資金が、対応するスペンディングキーを持つ受信者のものであるかどうかを返す
/// @param stealthAddress 受信者のステルスアドレス
/// @param ephemeralPubKey ステルスアドレスを生成するために使用された一時的な公開鍵
/// @param viewingKey 受信者のビューイング秘密鍵
/// @param spendingPubKey 受信者のスペンディング公開鍵
/// @return ステルスアドレスに送金された資金が受信者のものである場合はtrue
function checkStealthAddress(
  address stealthAddress,
  bytes memory ephemeralPubKey,
  bytes memory viewingKey,
  bytes memory spendingPubKey
) external view returns (bool);
```

受信者は、次のシグネチャのメソッドを呼び出してステルスアドレスの秘密鍵を計算できます:

```solidity
/// @notice ステルスアドレスのステルス秘密鍵を計算する
/// @param stealthAddress 期待されるステルスアドレス
/// @param ephemeralPubKey ステルスアドレスを生成するために使用された一時的な公開鍵
/// @param viewingKey 受信者のビューイング秘密鍵
/// @param spendingKey 受信者のスペンディング秘密鍵
/// @return stealthKey ステルスアドレスに対応するステルス秘密鍵
/// @dev ステルスアドレスの入力は厳密には必要ありませんが、ステルス秘密鍵が正しく生成されたことを検証するために含まれています。
function computeStealthKey(
  address stealthAddress,
  bytes memory ephemeralPubKey,
  bytes memory viewingKey,
  bytes memory spendingKey
) external view returns (bytes memory);
```

これらのメソッドの実装はスキーム固有です。新しいステルスアドレススキームを仕様化する際は、これらのメソッドの実装を明記する必要があります。また、これらの関数インターフェースはSolidityで指定されていますが、実際にSolidityで実装される必要はありません。ただし、この仕様に準拠するライブラリやSDKは、互換性のある関数インターフェースでこれらのメソッドを実装する必要があります。

256ビットの整数(`schemeId`)を使ってステルスアドレススキームを識別します。新しいステルスアドレススキームを標準化するERCでは、`schemeId`から仕様への対応付けを宣言する必要があります。`schemeId`は単純化のために連続する整数を選ぶことが推奨されますが、任意の意味のある`schemeId`を選択することもできます。この仕様では、`1`というスキームIDを導入し、以下の拡張を行います:

- `1`はこのスキームの整数識別子です。
- `viewTags`は発表イベントに含める必要があり、受信者のパース時間を短縮するために使用されます。
- SECP256k1は、ステルスメタアドレス(つまり、スペンディング公開鍵とビューイング公開鍵)を`bytes`配列にエンコーディングし、ネイティブの鍵型にデコーディングするためのアルゴリズムです。
- SECP256k1とビュータグは、`generateStealthAddress`、`checkStealthAddress`、`computeStealthKey`メソッドで使用されます。

この仕様では、さらに、ステルスアドレスに何かが送信されたときにイベントを発行するシングルトンの`ERC5564Announcer`コントラクトを定義しています。これは、チェーンごとに1つのインスタンスが存在する必要があるシングルトンコントラクトです。コントラクトは次のように指定されています:

```solidity
/// @notice ステルスアドレスに何かが送信されたときに発表するためのインターフェース
contract IERC5564Announcer {
  /// @dev ステルスアドレスに何かが送信されたときに発行されるイベント
  /// @dev `announce`メソッドのドキュメントを参照してください
  event Announcement (
    uint256 indexed schemeId, 
    address indexed stealthAddress, 
    address indexed caller, 
    bytes ephemeralPubKey, 
    bytes metadata
  );

  /// @dev インテグレーターが`Announcement`イベントを発行するために呼び出す
  /// @param schemeId 適用されたステルスアドレススキームを指定する整数
  /// @param stealthAddress 受信者のステルスアドレス
  /// @param ephemeralPubKey 送信者が使用した一時的な公開鍵
  /// @param metadata 任意のフィールド。最初のバイトにはビュータグが含まれる必要があります。
  /// ビュータグ以外にも、送信者が任意の方法で使用できますが、以下のガイドラインが推奨されます:
  /// メタデータの最初のバイトはビュータグでなければなりません。
  /// - ブロックチェーンのネイティブトークン(ETHなど)を送信/やり取りする場合、メタデータは次のように構造化されるべきです:
  ///     - 1バイト目はビュータグ(上記のとおり)
  ///     - 2-5バイト目は`0xeeeeeeee`
  ///     - 6-25バイト目は`0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`アドレス
  ///     - 26-57バイト目は送信されるETHの量
  /// - ERC-20/ERC-721/etc.トークンと対話する場合、メタデータは次のように構造化されるべきです:
  ///   - 1バイト目はビュータグ(上記のとおり)
  ///   - 2-5バイト目は関数識別子。ソリディティやVyperが使用するような関数シグネチャの最初の(左、ビッグエンディアンの高次)4バイトのKeccak-256ハッシュを使う必要があります。
  ///   - 6-25バイト目はトークンコントラクトアドレス
  ///   - 26-57バイト目は送信/やり取りされるトークンの量(fungibleトークンの場合)、またはトークンID(non-fungibleトークンの場合)
  function announce (
    uint256 schemeId, 
    address stealthAddress, 
    bytes memory ephemeralPubKey, 
    bytes memory metadata
  )
    external
  {
    emit Announcement(schemeId, stealthAddress, msg.sender, ephemeralPubKey, metadata);
  }
}
```

### ステルスメタアドレスのフォーマット

ステルスメタアドレスの新しいアドレス形式は、チェーン固有のアドレス形式に`st:`(ステルス)プレフィックスを追加したものです。
したがって、Ethereumのステルスメタアドレスは次の形式になります:

```
st:eth:0x<spendingPubKey><viewingPubKey>
```

ステルスメタアドレスはユーザーが管理し、[ERC-6538](./eip-6538.md)に記載されている`Registry`コントラクトに登録することができます。これにより、ユーザーは他の個人に関連付けられたステルスメタアドレスを一元的に識別できるようになり、同時に受信者がステルスアドレスを介して関与する意思を表明できるようになります。

*注目すべきは、アドレス形式はステルスアドレスと標準アドレスを区別するためにのみ使用され、ステルスメタアドレスに対する計算を行う前にプレフィックスが削除されることです。*

---

### SECP256k1とビュータグの初期実装

この仕様は、`IERC5564Announcer`コントラクトを通じて特定の暗号化システムに縛られないようにしています。さらに、SECP256k1楕円曲線とビュータグを使ったステルスアドレススキームの最初の実装を紹介しています。SECP256k1楕円曲線は、方程式$y^2 = x^3 + 7 \pmod{p}$で定義され、$p = 2^{256} - 2^{32} - 977$です。

以下のリファレンスは3つのセクションに分かれています:

1. ステルスアドレスの生成
2. 発表のパース
3. ステルス秘密鍵の導出

定義:

- $G$は曲線の生成点を表します。

#### 生成 - ステルスメタアドレスからステルスアドレスを生成する:

- 受信者は秘密鍵$p_{spend}$、$p_{view}$にアクセスし、それらから公開鍵$P_{spend}$と$P_{view}$を導出します。
- 受
信者はステルスメタアドレスを公開しており、それは公開鍵$P_{spend}$と$P_{view}$で構成されています。
- 送信者はステルスメタアドレスを`generateStealthAddress`関数に渡します。
- `generateStealthAddress`関数は以下の計算を行います:
  - 32バイトのランダムな一時的な秘密鍵$p_{ephemeral}$を生成します。
  - $p_{ephemeral}$から一時的な公開鍵$P_{ephemeral}$を導出します。
  - ステルスメタアドレスからスペンディング公開鍵$P_{spend}$とビューイング公開鍵$P_{view}$を解析します。
  - 共有秘密$s$を$s = p_{ephemeral} \cdot P_{view}$と計算します。
  - 秘密をハッシュして$s_{h} = \textrm{h}(s)$を得ます。
  - ビュータグ$v$を$s_{h}[0]$の最上位バイトとして抽出します。
  - ハッシュされた共有秘密をジェネレーター点$G$に乗じて$S_h = s_h \cdot G$を計算します。
  - 受信者のステルス公開鍵を$P_{stealth} = P_{spend} + S_h$と計算します。
  - 受信者のステルスアドレス$a_{stealth}$を$\textrm{pubkeyToAddress}(P_{stealth})$と計算します。
  - 関数はステルスアドレス$a_{stealth}$、一時的な公開鍵$P_{ephemeral}$、ビュータグ$v$を返します。

#### パース - 自分のステルスアドレスを特定する:

- ユーザーはビューイング秘密鍵$p_{view}$とスペンディング公開鍵$P_{spend}$にアクセスしています。
- ユーザーは一連の`Announcement`イベントにアクセスし、それぞれに`checkStealthAddress`関数を適用します。
- `checkStealthAddress`関数は以下の計算を行います:
  - 共有秘密$s$を、ビューイング秘密鍵と発表の一時的な公開鍵を乗じて$s = p_{view}$ * $P_{ephemeral}$と計算します。
  - 秘密をハッシュして$s_{h} = h(s)$を得ます。
  - ビュータグ$v$を$s_{h}[0]$の最上位バイトとして抽出し、与えられたビュータグと比較します。ビュータグが一致しない場合、このアナウンスはユーザー宛てではないため、残りの手順をスキップできます。ビュータグが一致する場合は続行します。
  - ハッシュされた共有秘密をジェネレーター点$G$に乗じて$S_h = s_h \cdot G$を計算します。
  - ステルス公開鍵を$P_{stealth} = P_{spend} + S_h$と計算します。
  - 導出されたステルスアドレス$a_{stealth}$を$\textrm{pubkeyToAddress}(P_{stealth})$と計算します。
  - 発表のステルスアドレスが導出されたステルスアドレスと一致する場合はtrueを返し、そうでない場合はfalseを返します。

#### 秘密鍵の導出 - ハッシュされた共有秘密とスペンディング秘密鍵からステルスアドレスの秘密鍵を生成する

- ユーザーはビューイング秘密鍵$p_{view}$とスペンディング秘密鍵$p_{spend}$にアクセスしています。
- ユーザーは`checkStealthAddress`関数がtrueを返す一連の`Announcement`イベントにアクセスしています。
- `computeStealthKey`関数は以下の計算を行います:
  - 共有秘密$s$を、ビューイング秘密鍵と発表の一時的な公開鍵を乗じて$s = p_{view}$ * $P_{ephemeral}$と計算します。
  - 秘密をハッシュして$s_{h} = h(s)$を得ます。
  - ステルス秘密鍵を$p_{stealth} = p_{spend} + s_h$と計算します。

### パースの考慮事項

通常、ステルスアドレストランザクションの受信者は、特定のトランザクションの受信者であるかどうかを確認するために、以下の操作を行う必要があります:

- 2x ecMUL
- 2x HASH
- 1x ecADD

ビュータグアプローチを導入することで、パース時間を約6倍短縮できます。ユーザーは1x ecMULと1x HASHのみを実行すれば良く(1x ecMUL、1x ecADD、1x HASHをスキップできる)、共有秘密$h(s)$をハッシュした後に、非一致のアナウンスをほぼ確実にスキップできます。1バイトの`viewTag`の長さは、一致しないアナウンスを確実にフィルタリングするのに必要な最小限のスペースに基づいています。1バイトの`viewTag`を使うと、共有秘密$h(s)$の1バイトが明らかになるため、セキュリティマージンは128ビットから124ビットに減少します。ただし、これはプライバシーにのみ影響し、ステルスアドレスの安全な生成には影響しません。

---

## 根拠

この仕様は、受信者の身元を開示することなく所有権を移転する必要性から生まれました。トークンの所有権は個人情報を露呈する可能性があります。個人が特定の組織や国に寄付したい場合でも、自分と受信者の関係を同時に開示したくない可能性があります。ステルスアドレス生成の標準化は、広範な採用を実現するためのプライバシー保護ソリューションに不可欠です。

ステルスアドレスの仕様は、事前に受信者と対話することなく資産を移転できるプロトコルを標準化しています。これにより、受信者はブロックチェーンを照会してアカウントの残高を確認する必要なく、トランスファーの受領を確認できます。重要なのは、ステルスアドレスにより、トランスファーの受信者がプライバシーを維持したまま受領を確認できることです。

著者は、オンチェーンとオフチェーンの効率性のトレードオフを認識しています。Monero型のビュータグメカニズムを組み込むことで受信者のパース効率が向上しますが、発表イベントの複雑性が増します。

受信者のアドレスと`viewTag`を発表イベントに含める必要があり、これにより、ユーザーはアカウントの残高を照会することなく所有権を迅速に確認できます。

## 下位互換性

この仕様は完全に下位互換性があります。

### デプロイメントの方法

`ERC5564Announcer`コントラクトは、`0x4e59b44847b379578588920ca78fbf26c0b4956c`の決定論的デプロイヤーを使ってsaltが`0xd0103a290d760f027c9ca72675f5121d725397fb2f618f05b6c44958b25b4447`の`CREATE2`を介して、`0x55649E01B5Df198D18D95b5cc5051630cfD45564`にデプロイされます。

## リファレンス実装

`ERC5564Announcer`コントラクトの実装は[こちら](../assets/eip-5564/contracts/ERC5564Announcer.sol)、インターフェース`IERC5564Announcer.sol`は[こちら](../assets/eip-5564/contracts/interfaces/IERC5564Announcer.sol)にあります。

## セキュリティ上の考慮事項

### DoS対策

ネットワークのトランザクション料では軽減できないDDoS攻撃ベクトルが存在します。ステルストランスファーの送信者は受信者に外部性を引き起こします。アナウンスイベントのパースはガス代が補償されないコンピューティングリソースを消費するため、アナウンスイベントのスパミングは**ユーザーエクスペリエンスの悪化**につながる可能性があります。
このような攻撃を行う動機は低いと考えられますが、**金銭的な利益が得られないため**。
ただし、スパムに対処するため、パースプロバイダーは独自のDoS対策を採用する可能性があります。既知のスパマーを無視したり、アナウンスの順序付けで優先度を下げたりするなどの対策が考えられます。インデックス付きの`caller`キーワードを使えば、パースプロバイダーが効果的にスパマーをフィルタリングできます。

さらに、パースプロバイダーには、ステーキングメカニズムの導入や送信者に「通行料」の支払いを要求するなど、スパムに対処する選択肢があります。ステーキングメカニズムでは、[ERC-4337](./eip-4337)のように、スラッシャブルではない一定量のETHをステークすることで、*Sybil攻撃*によるスパムを軽減し、パースプロバイダーがスパムをより効果的にフィルタリングできるようになります。
「通行料」を導入することで、ステルスアドレストランザクションにコストがかかるため、スパミングが経済的に魅力的でなくなります。

### 受信者のトランザクション費用

ステルスアドレスウォレットの資金調達は、プライバシーを侵害する既知の問題です。ステルスアドレスの所有者と物理的な関係がないウォレットから資金を調達する必要があります。

したがって、送信者はステルスアドレストランザクションに少額のETHを添付して、受信者の後続のトランザクションをスポンサーすることができます。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。