---
original: aeffc2c5d4e735b5fbc6be9fac57a73554a354034970a42bc080d0c25e4c0e02
---

---
eip: 2544
title: ENS ワイルドカード解決
description: ENS のサブドメインの "ワイルドカード" 解決をサポートします。
author: Nick Johnson (@arachnid), 0age (@0age)
discussions-to: https://ethereum-magicians.org/t/eip-2544-ens-wildcard-resolution
status: 停滞
type: Standards Track
category: ERC
created: 2020-02-28
requires: 137
---

## 概要

Ethereum Name Service 仕様 (EIP-137) は、2 段階の名前解決プロセスを確立しています。まず、ENS クライアントは namehash アルゴリズムを使用して名前を処理し、関連する "ノード" を特定し、それをENSレジストリコントラクトに渡して解決者を特定します。次に、レジストリにリゾルバーが設定されている場合、クライアントはその同じノードをリゾルバーコントラクトに渡し、関連するアドレスやその他のレコードを取得します。

現在の仕様では、ノードにリゾルバーが設定されていない場合、この処理は終了します。このEIPは、ドメインにリゾルバーが設定されていない場合の名前解決プロセスを変更します。この場合、名前から最左のラベルを削除し、新しい断片のノードを派生させ、それをENSレジストリに渡します。そのノードにリゾルバーが見つかった場合、クライアントは元の完全な名前をそのリゾルバーコントラクトに渡して、関連するレコードを取得します。この手順は、ノードにリゾルバーが見つかるまで繰り返されます。

さらに、この仕様では、より柔軟な名前解決を可能にする新しい `resolve()` メソッドを使用してリゾルバーが名前を解決する方法を定義しています。

## 動機

ウォレットプロバイダー、取引所、dアプリなどの多くのアプリケーションは、共有親ドメインのカスタムサブドメインを通じてユーザーにENS名を発行したいと考えています。しかし、大規模なユーザーベースに対してそうするのは現在コストが高すぎます。なぜなら、各サブドメインに対して ENS レジストリにレコードを設定する必要があるからです。

さらに、ユーザーはサブドメインのノードにリゾルバーを割り当てるトランザクションが最初に送信され、オンチェーンでマイニングされるまで、これらのサブドメインを即座に利用することはできません。これは、ENS名の恩恵を最も受けられるはずの新規ユーザーの導入に不必要な摩擦を加えています。

ワイルドカードサポートを可能にすることで、未割り当てのサブドメインに対して決定論的にアドレスやその他のレコードを生成できる、より高度なリゾルバーの設計が可能になります。生成されたアドレスは、counterfactual コントラクトデプロイメントアドレス (つまり `CREATE2` アドレス)、指定された "フォールバック" アドレス、またはその他のスキームにマッピングできます。さらに、個々のリゾルバーは任意のサブドメインに割り当てることができ、親リゾルバーを使用するワイルドカード解決を上書きします。

EIP-2544 の重要な動機の 1 つは、下位互換性のあるワイルドカード解決を可能にすることです。これは、現在の ENS レジストリコントラクトや既存のリゾルバーを変更する必要がなく、既存の ENS レコードもサポートし続けます。レガシーの ENS クライアントはワイルドカードレコードを解決できないだけです。

## 仕様

この文書の "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"、"OPTIONAL" というキーワードは、RFC 2119 で説明されているように解釈されるものとします。

以下を定義します:
 - `namehash` は EIP 137 で定義されたアルゴリズムです。
 - `dnsencode` は RFC1035 のセクション 3.1 で指定されている DNS 名のエンコーディングプロセスです。ただし、エンコードされた名前の総長に制限はありません。空文字列は '.' という名前と同じように、単一の 0 オクテットでエンコードされます。
 - `parent` は名前から最初のラベルを削除する関数です (例: `parent('foo.eth') = 'eth'`)。`parent('tld')` は空文字列 '' と定義されます。
 - `ens` は現在のネットワークの ENS レジストリコントラクトです。

EIP-2544 準拠の ENS リゾルバーは、以下の関数インターフェイスを実装してもよいです:

```
interface ExtendedResolver {
    function resolve(bytes calldata name, bytes calldata data) external view returns(bytes);
}
```

このインターフェイスの ID `0xTBD` で `supportsInterface()` が呼び出された場合、リゾルバーはtrueを返さなければなりません。

ENS クライアントは、解決する DNS エンコードされた名前と、リゾルバー関数のエンコードされた呼び出しデータ (EIP-137 などで指定されているとおり) を使って `resolve` を呼び出します。関数は、その関数に対する有効な戻り値を返すか、サポートされていない場合はrevertしなければなりません。

EIP-2544 準拠の ENS クライアントは、特定の名前のリゾルバーを決定する際に、以下の手順を実行しなければなりません:

1. `currentname = name` を設定する
2. `resolver = ens.resolver(namehash(currentname))` を設定する
3. `resolver` がゼロアドレスでない場合、ここで停止し `resolver` を返す
4. `name` が空の名前 ('' または '.') の場合、ここで停止し nullを返す
5. そうでない場合、`currentname = parent(currentname)` を設定し、2 に戻る

上記の手順がnullを返した場合、名前解決は失敗したものとみなされます。それ以外の場合、EIP-2544 準拠の ENS クライアントは、レコードを解決する際に以下の手順を実行しなければなりません:

1. 解決に必要な関数呼び出しデータの ABI エンコーディングを `calldata` に設定する - 例えば、`addr` レコードを解決する場合は `addr(namehash(name))` の ABI エンコーディング
2. `supports2544 = resolver.supportsInterface(0xTBD)` を設定する
3. `supports2544` が true の場合、`result = resolver.resolve(dnsencode(name), calldata)` を設定する
4. そうでない場合、`calldata` を使って `resolver` を呼び出した結果を `result` に設定する
5. 対応する解決関数 (例: `addr()` の場合) の戻りデータ ABI を使ってデコードした `result` を返す

すべての場合において、解決関数 (`addr()` など) と `resolve` 関数には、最初の解決段階で見つかった `currentname` ではなく、元の `name` が渡されることに注意してください。

### 擬似コード
```
function getResolver(name) {
    for(let currentname = name; currentname !== ''; currentname = parent(currentname)) {
        const node = namehash(currentname);
        const resolver = ens.resolver(node);
        if(resolver != '0x0000000000000000000000000000000000000000') {
            return resolver;
        }
    }
    return null;
}

function resolve(name, func, ...args) {
    const resolver = getResolver(name);
    if(resolver === null) {
        return null;
    }
    const supports2544 = resolver.supportsInterface('0xTBD');
    let result;
    if(supports2544) {
        const calldata = resolver[func].encodeFunctionCall(namehash(name), ...args);
        result = resolver.resolve(dnsencode(name), calldata);
        return resolver[func].decodeReturnData(result);
    } else {
        return resolver[func](...args);
    }
}
```

## 根拠

提案された実装は、既存のシステムへの影響を最小限に抑えながら、ワイルドカード解決をサポートしています。また、可能な限り既存のアルゴリズムと手順を再利用することで、さまざまな ENS クライアントの作者やメンテナーの負担を軽減しています。

ENS のワイルドカード解決の望ましさに関する既存のコンセンサスも認識しており、これにより、スケーラビリティの主要な障害を解決することで、元の仕様のより広範な採用を可能にしています。

リゾルバーに対して `resolve` 関数のオプション実装を導入し、ハッシュされていない名前と解決関数のコールデータを受け取ることで実装の複雑さが増加しますが、リゾルバーがプレーンテキストのラベルを取得し、それに応じて行動できるようになります。これにより、`id.nifty.eth` を特定の NFTコレクションの ID `id` の所有者に解決するなど、ワイルドカード関連の多くのユースケースが可能になります。ただし、namehashしか扱えない場合、これは不可能です。より単純な要件のリゾルバーは、`resolve` 関数のサポートを省略し、解決関数を直接実装し続けることができます。

DNS ワイヤー形式は、名前のハッシュ化を迅速かつガス効率的に行うことができ、個々のラベルの取得や削除などの一般的な操作にも適しているため、使用されています。対照的に、ドット区切りの名前では、区切り文字を見つけるために名前の各文字を反復する必要があります。

## 下位互換性

EIP-137 に準拠した既存の ENS クライアントは、ワイルドカードレコードを解決できず、それらとの対話を拒否します。一方、EIP-2544 に準拠したクライアントは、既存の ENS レコードを引き続き正しく解決するか、拒否します。新しい `resolve` 関数を実装したいリゾルバーは、レガシークライアントとの最大限の互換性を確保するために、個別の解決関数に何を返すべきかを検討する必要があります。

## セキュリティ上の考慮事項

準拠 ENS クライアントはリゾルバーのない記録を解決することを拒否し続けますが、クライアントが不適切に設定されている場合や、リゾルバーが見つからない場合にnullアドレスとの対話を拒否しない可能性があります。

さらに、完全に任意のワイルドカードサブドメイン解決をサポートするリゾルバーにより、タイプミスによる意図しない受信者への資金送付の可能性が高くなります。このようなリゾルバーを実装するアプリケーションは、コンテキストに応じてクライアントに追加の名前検証を提供したり、資金の回復性をサポートする機能を実装したりすることを検討する必要があります。

特定のサブドメインにリゾルバーを設定しないことを要求するアプリケーションもあるかもしれません。これが問題になるには、親ドメインが指定のサブドメインノードを正常に解決する必要があります。著者の知る限り、現時点でこの機能をサポートしたり、サブドメインがレコードに解決されるべきではないと期待したりするアプリケーションはありません。

## 著作権

著作権およびそれに関連する権利は [CC0](../LICENSE.md) で放棄されています。