---
original: 3cfc53fd96cf3901a393f61c484a4af69e90a38a78ffe7c3310d3a04ca40cb03
---

---
eip: 7579
title: 最小限のモジュラースマートアカウント
description: アカウントとモジュールの最小限の制限でのインターオペラビリティのためのモジュラースマートアカウントのインターフェースと動作
author: zeroknots (@zeroknots), Konrad Kopp (@kopy-kat), Taek Lee (@leekt), Fil Makarov (@filmakarov), Elim Poon (@yaonam), Lyu Min (@rockmin216)
discussions-to: https://ethereum-magicians.org/t/erc-7579-minimal-modular-smart-accounts/17336
status: Draft
type: Standards Track
category: ERC
created: 2023-12-14
requires: 165, 1271, 2771, 4337
---

## 概要

このプロポーザルは、実装間のインターオペラビリティを確保するために、モジュラースマートアカウントとモジュールに必要最小限のインターフェースと動作を概説しています。アカウントについては、標準では実行、設定、フォールバックのインターフェースを指定し、[ERC-165](./eip-165.md)と[ERC-1271](./eip-1271.md)に準拠しています。モジュールについては、標準では、コアインターフェース、モジュールタイプ、タイプ固有のインターフェースを指定しています。

## 動機

コントラクトアカウントの採用が進んでおり、多くのアカウントがモジュラーアーキテクチャを使って構築されています。これらのモジュラーコントラクトアカウント(以下、スマートアカウント)は、外部コントラクト(モジュール)に機能を移動することで、イノベーションの速度と可能性を高め、将来に備え、開発者やユーザーによるカスタマイズを可能にしています。しかし、現在これらのスマートアカウントは大きく異なる方法で構築されており、モジュールの断片化とベンダーロックインが生じています。スマートアカウントを標準化することが生態系にとって非常に有益な理由は以下の通りです:

- モジュールを異なるスマートアカウント間で使用可能にする
- スマートアカウントをさまざまなウォレットアプリケーションやSDKで使用可能にする
- スマートアカウントユーザーの大きなベンダーロックインを防ぐ

ただし、この標準化は、スマートアカウントベンダーが継続的にイノベーションできるように、アカウントの実装ロジックに最小限の影響を与えることが非常に重要です。その結果、この標準の目的は、インターオペラビリティを確保しつつ、可能な限り最小限のインターフェースとアカウントとモジュールの動作を定義することです。

## 仕様

この文書の中の「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」というキーワードは、RFC 2119およびRFC 8174に記載されているように解釈されるものとします。

### 定義

- **スマートアカウント** - モジュラーアーキテクチャを持つスマートコントラクトアカウント。
- **モジュール** - 自己完結型のスマートアカウント機能を持つスマートコントラクト。
  - バリデーター: トランザクションの有効性を判断し、アカウントで実行するかどうかを決定するために使用されるモジュール。
  - エグゼキューター: スマートアカウントに代わってトランザクションを実行できるモジュール。
  - フォールバックハンドラー: スマートアカウントのフォールバック機能を拡張できるモジュール。
- **エントリーポイント** - [ERC-4337](./eip-4337.md)の仕様に準拠したトラステッドシングルトンコントラクト。

### アカウント

#### 検証

この標準では、バリデーター選択の実装方法は指定していません。ただし、スマートアカウントがバリデーター選択メカニズムをデータフィールド(例えば、ERC-4337を使用する場合の `userOp.signature`)に符号化する場合、スマートアカウントはバリデーターを呼び出す前に影響を受ける値を確認する必要があります。

スマートアカウントの検証関数は、バリデーターの返り値を返すべきです。

#### 実行動作

この標準に準拠するには、スマートアカウントは以下の実行インターフェースを実装する必要があります:

```solidity
interface IExecution {
    /**
     * @dev アカウントに代わってトランザクションを実行する
     * @param mode トランザクションの実行モードをエンコードしたもの。詳細はModeLib.solを参照
     * @param executionCalldata 実行コールデータをエンコードしたもの
     *
     * 適切な承認制御を実装する必要がある: 例えばERC-4337を使用する場合はonlyEntryPointOrSelf
     * サポートされていないモードが要求された場合は、revertする必要がある
     */
    function execute(bytes32 mode, bytes calldata executionCalldata) external;

    /**
     * @dev アカウントに代わってトランザクションを実行する
     *         この関数はエグゼキューターモジュールから呼び出されることを想定
     * @param mode トランザクションの実行モードをエンコードしたもの。詳細はModeLib.solを参照
     * @param executionCalldata 実行コールデータをエンコードしたもの
     *
     * 適切な承認制御を実装する必要がある: つまりonlyExecutorModule
     * サポートされていないモードが要求された場合は、revertする必要がある
     */
    function executeFromExecutor(bytes32 mode, bytes calldata executionCalldata)
        external
        returns (bytes[] memory returnData);
}
```

アカウントは、ERC-4337に従って以下の関数も実装してもよい:

```solidity
/**
 * @dev ERC-4337 executeUserOp ERC-4337 v0.7に従う
 *         この関数はERC-4337 EntryPoint.solから呼び出されることを想定
 * @param userOp PackedUserOperation構造体(ERC-4337 v0.7+を参照)
 * @param userOpHash PackedUserOperation構造体のハッシュ
 *
 * 適切な承認制御を実装する必要がある: つまりonlyEntryPoint
 */
function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external;
```

実行モードは以下のように構成される `bytes32` 値です:

- callType (1バイト): `0x00`は単一の `call`、`0x01`はバッチ `call`、`0xff`は `delegatecall`
- execType (1バイト): `0x00`はエラー時にrevertする実行、`0x01`はエラー時にrevertせず、エラー処理を実装する実行
- 未使用 (4バイト): この範囲は将来の標準化のために予約されている
- modeSelector (4バイト): カスタムの実行モードを作成するための追加のモードセレクター
- modePayload (22バイト): 実行に渡す追加のデータ

実行モードの視覚的な表現は以下の通りです:

| CallType | ExecType | 未使用  | ModeSelector | ModePayload |
| -------- | -------- | ------- | ------------ | ----------- |
| 1バイト  | 1バイト  | 4バイト | 4バイト      | 22バイト    |

アカウントは、すべての実行モードを実装する必要はありません。アカウントは `supportsAccountMode`(下記参照)で、サポートされているモードを宣言する必要があり、サポートされていないモードが要求された場合はrevertする必要があります。

アカウントは、以下の方法で実行データをエンコードする必要があります:

- 単一のコールの場合、`target`、`value`、`callData`の順にパックする(Solidityでは `abi.encodePacked`)。
- `delegatecall`の場合、`target`と`callData`の順にパックする(Solidityでは `abi.encodePacked`)。
- バッチコールの場合、`targets`、`values`、`callDatas`をこの順序の`Execution`構造体の配列にする。その後、このデータを(Solidityでは `abi.encode`)でエンコードする。

#### アカウントの設定

この標準に準拠するには、スマートアカウントは以下のアカウント設定インターフェースを実装する必要があります:

```solidity
interface IAccountConfig {
    /**
     * @dev スマートアカウントのアカウントIDを返す
     * @return accountImplementationId スマートアカウントのアカウントID
     *
     * 空でない文字列を返す必要がある
     * アカウントIDは以下のような構造が推奨される:
     *        "vendorname.accountname.semver"
     * IDはすべてのスマートアカウントで一意である必要がある
     */
    function accountId() external view returns (string memory accountImplementationId);

    /**
     * @dev 特定の実行モードをアカウントがサポートしているかどうかを確認する関数
     * @param encodedMode エンコードされたモード
     *
     * アカウントがそのモードをサポートする場合はtrueを、そうでない場合はfalseを返す必要がある
     */
    function supportsExecutionMode(bytes32 encodedMode) external view returns (bool);

    /**
     * @dev 特定のモジュールタイプIDをアカウントがサポートしているかどうかを確認する関数
     * @param moduleTypeId ERC-7579仕様に従ったモジュールタイプID
     *
     * アカウントがそのモジュールタイプをサポートする場合はtrueを、そうでない場合はfalseを返す必要がある
     */
    function supportsModule(uint256 moduleTypeId) external view returns (bool);
}
```

#### モジュールの設定

この標準に準拠するには、スマートアカウントは以下のモジュール設定インターフェースを実装する必要があります。

スマートアカウントは、インストールされたモジュールの種類を区別できるようにする必要があります。例えば、インストールされたエグゼキューターのみ `executeFromExecutor` 関数を呼び出せるようにアクセス制御を実装できます。

```solidity
interface IModuleConfig {
    event ModuleInstalled(uint256 moduleTypeId, address module);
    event ModuleUninstalled(uint256 moduleTypeId, address module);

    /**
     * @dev 特定のタイプのモジュールをスマートアカウントにインストールする
     * @param moduleTypeId ERC-7579仕様に従ったモジュールタイプID
     * @param module モジュールのアドレス
     * @param initData モジュールの `onInstall` 初期化時に必要な任意のデータ
     *
     * 承認制御を実装する必要がある
     * `onInstall` をモジュールに呼び出し、`initData`パラメータがある場合は渡す必要がある
     * ModuleInstalledイベントを発行する必要がある
     * モジュールがすでにインストールされている場合や、モジュールの初期化に失敗した場合はrevertする必要がある
     */
    function installModule(uint256 moduleTypeId, address module, bytes calldata initData) external;

    /**
     * @dev 特定のタイプのモジュールをスマートアカウントからアンインストールする
     * @param moduleTypeId ERC-7579仕様に従ったモジュールタイプID
     * @param module モジュールのアドレス
     * @param deInitData モジュールの `onUninstall` 終了時に必要な任意のデータ
     *
     * 承認制御を実装する必要がある
     * `onUninstall` をモジュールに呼び出し、`deInitData`パラメータがある場合は渡す必要がある
     * ModuleUninstalledイベントを発行する必要がある
     * モジュールがインストールされていない場合や、モジュールの終了処理に失敗した場合はrevertする必要がある
     */
    function uninstallModule(uint256 moduleTypeId, address module, bytes calldata deInitData) external;

    /**
     * @dev モジュールがスマートアカウントにインストールされているかどうかを返す
     * @param moduleTypeId ERC-7579仕様に従ったモジュールタイプID
     * @param module モジュールのアドレス
     * @param additionalContext モジュールがインストールされているかどうかを判断するために必要な任意のデータ
     *
     * モジュールがインストールされている場合はtrueを、そうでない場合はfalseを返す必要がある
     */
    function isModuleInstalled(uint256 moduleTypeId, address module, bytes calldata additionalContext) external view returns (bool);
}
```

#### フック

フックは、この標準の任意の拡張機能です。スマートアカウントは、単一または一括実行の前後にカスタムロジックとチェックを実行するためにフックを使用してもよい。この任意の拡張機能に準拠する
するには、スマートアカウントは:

- 実行中に1つ以上のフックの `preCheck` 関数を呼び出す必要がある
- 実行中に1つ以上のフックの `postCheck` 関数を呼び出す必要がある

#### ERC-1271 フォワーディング

スマートアカウントは、ERC-1271インターフェースを実装する必要があります。`isValidSignature` 関数の呼び出しは、バリデーターにフォワーディングできます。ERC-1271フォワーディングを実装する場合、バリデーターは `isValidSignatureWithSender(address sender, bytes32 hash, bytes signature)` を呼び出す必要があり、ここでsenderは、スマートアカウントへの呼び出しの `msg.sender` です。スマートアカウントが `bytes signature` パラメーターにバリデーター選択エンコーディングを実装している場合、スマートアカウントはそのパラメーターを、バリデーターにフォワーディングする前に確認する必要があります。

スマートアカウントのERC-1271 `isValidSignature` 関数は、フォワーディングされた要求のバリデーターの返り値を返すべきです。

#### フォールバック

スマートアカウントは、フォールバックハンドラーにコールをフォワーディングするフォールバック関数を実装してもよい。

スマートアカウントにフォールバックハンドラーがインストールされている場合:

- 承認制御を実装する必要がある
- `call` を使ってフォールバックハンドラーを呼び出す必要がある
- [ERC-2771](./eip-2771.md)を使って、元の `msg.sender` をフォールバックハンドラーに渡されるコールデータに追加する必要がある
- コールデータの関数セレクターに基づいてフォールバックハンドラーにルーティングする必要がある

#### ERC-165

スマートアカウントは、ERC-165を実装する必要があります。ただし、機能を実装せずにrevertする関数については、対応するインターフェースIDに `false` を返す必要があります。

### モジュール

この標準では、以下の異なるタイプのモジュールを区別しており、それぞれに一意かつ増分の識別子を使う必要があります。アカウント、モジュール、その他のエンティティはこれらのIDを使ってモジュールタイプを識別する必要があります:

- バリデーション (タイプID: 1)
- 実行 (タイプID: 2)
- フォールバック (タイプID: 3)
- フック (タイプID: 4)

注意: 単一のモジュールが複数のタイプを持つことができます。

モジュールは以下のインターフェースを実装する必要があります:

```solidity
interface IModule {
     /**
     * @dev このメソッドは、モジュールがスマートアカウントにインストールされる際に呼び出される
     * @param data モジュールの `onInstall` 初期化時に必要な任意のデータ
     *
     * エラー時はrevertする必要がある(例: モジュールがすでに有効化されている場合)
     */
    function onInstall(bytes calldata data) external;

    /**
     * @dev このメソッドは、モジュールがスマートアカウントからアンインストールされる際に呼び出される
     * @param data モジュールの `onUninstall` 終了時に必要な任意のデータ
     *
     * エラー時はrevertする必要がある
     */
    function onUninstall(bytes calldata data) external;

    /**
     * @dev モジュールが特定のタイプであるかどうかを返す
     * @param moduleTypeId ERC-7579仕様に従ったモジュールタイプID
     *
     * 指定したタイプの場合はtrueを、そうでない場合はfalseを返す必要がある
     */
    function isModuleType(uint256 moduleTypeId) external view returns(bool);
}
```

#### バリデーター

バリデーターは、`IModule`と`IValidator`インターフェースを実装し、モジュールタイプIDは`1`である必要があります。

```solidity
interface IValidator is IModule {
    /**
     * @dev ユーザーオペレーションを検証する
     * @param userOp ERC-4337 PackedUserOperation
     * @param userOpHash ERC-4337 PackedUserOperationのハッシュ
     *
     * ユーザーオペレーションのシグネチャが有効であることを検証する必要がある
     * シグネチャが一致しない場合はERC-4337のSIG_VALIDATION_FAILEDを返す(revertしない)べき
     */
    function validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external returns (uint256);

    /**
     * @dev ERC-1271を使ってシグネチャを検証する
     * @param sender ERC-1271リクエストをスマートアカウントに送信したアドレス
     * @param hash ERC-1271リクエストのハッシュ
     * @param signature ERC-1271リクエストのシグネチャ
     *
     * シグネチャが有効な場合はERC-1271の `MAGIC_VALUE` を返す必要がある
     * 状態を変更してはいけない
     */
    function isValidSignatureWithSender(address sender, bytes32 hash, bytes calldata signature) external view returns (bytes4);
}
```

#### エグゼキューター

エグゼキューターは、`IModule`インターフェースを実装し、モジュールタイプIDは`2`である必要があります。

#### フォールバックハンドラー

フォールバックハンドラーは、`IModule`インターフェースを実装し、モジュールタイプIDは`3`である必要があります。

承認制御を実装するフォールバックハンドラーは、`msg.sender`ではなく、ERC-2771の `_msgSender()` を使用して承認制御を行う必要があります。

#### フック

フックは、`IModule`と`IHook`インターフェースを実装し、モジュールタイプIDは`4`である必要があります。

```solidity
interface IHook is IModule {
    /**
     * @dev 実行前にスマートアカウントから呼び出される
     * @param msgSender スマートアカウントを呼び出したアドレス
     * @param value スマートアカウントに送信された値
     * @param msgData スマートアカウントに送信されたデータ
     *
     * `hookData`の返り値として任意のデータを返すことができる
     */
    function preCheck(address msgSender, uint256 value, bytes calldata msgData) external returns (bytes memory hookData);

    /**
     * @dev 実行後にスマートアカウントから呼び出される
     * @param hookData `preCheck`関数の返り値
     *
     * `hookData`を検証して、`preCheck`関数のトランザクションコンテキストを検証することができる
     */
    function postCheck(bytes calldata hookData) external;
}
```

## 根拠

### 最小限のアプローチ

スマートアカウントは新しい概念であり、最適な構築方法についてまだ学習中です。したがって、スマートアカウントの構築方法について過度に意見を述べるのではなく、スマートアカウントとモジュールの間のインターオペラビリティを可能にする最小限のインターフェースを定義すべきです。

私たちのアプローチは2つの側面があります:

1. 実稼働で使用されているスマートアカウントから得られた教訓と、それらの間の相互運用性レイヤーの構築から学ぶ
2. 代替アーキテクチャにも開かれた、可能な限り最小限のインターフェースを確保する

### 拡張

最小限であることを望む一方で、イノベーションと意見の異なる機能も許容したいと考えています。これらの機能の一部は、すべてのスマートアカウントが実装するわけではないが、同様の理由から標準化する必要があるかもしれません。この可能性を確保するために、将来の標準化の取り組みは、この標準の拡張として行うことを提案します。つまり、コアインターフェースは変更されませんが、新しいインターフェースを拡張として追加できます。これらは、例えば `[FEATURE] Extension for ERC-7579` というタイトルの別のERCとして提案されるべきです。

### 仕様

#### 実行モード

アカウントは、さまざまな方法でコールデータを実行できる必要があります。各実行タイプの組み合わせに対して個別の関数を定義するのではなく、単一の `bytes32` 値にエンコードすることにしました。これにより、より柔軟で拡張性のあるアプローチが可能になり、コードの記述、読解、メンテナンス、監査が大幅に容易になります。上述のように、実行モードは、コールタイプと実行タイプをエンコードする2つのバイトで構成されています。コールタイプは、単一、バッチ、`delegatecall`(マルチコールコントラクトに `delegatecall` をバッチする場合)の3つの異なる呼び出し方法をカバーします。実行タイプは、エラー時にrevertする実行と、エラー時にrevertせずエラー処理を実装する実行の2つの異なる実行タイプをカバーします。これにより、相関関係のない実行をまとめて実行できるようになり、1つの実行が失敗しても他の実行を実行できます。これらの2バイトに続いて、将来の標準化のために予約された4バイトの未使用領域があります。その後に4バイトのカスタムモードセレクターが続きます。これにより、アカウントは、標準では対象とされていないカスタムの実行モードを実装できます。このアイテムは4バイトの長さがあり、Solidityの関数セレクターと同様の衝突回避保証を持っています。最後の22バイトは、実行に渡すカスタムデータ用に予約されています。これにより、アカウントは、2バイトのフラグとアドレスなどの最大22バイトのデータを渡したり、実行の前後に実行されるフックのアドレスなどのポインターを渡したりできます。

#### モジュールタイプの区別

モジュールタイプを区別しないと、承認制御の実施時に安全性の問題が生じる可能性があります。例えば、スマートアカウントがバリデーターとエグゼキューターを同じタイプのモジュールとして扱う場合、バリデーターが代わりにスマートアカウントに代わって任意のトランザクションを実行できるようになる可能性があります。

#### アカウントID

アカウント設定インターフェースには `accountId` 関数が含まれており、アカウントを識別するのに使用できます。これは特に、フロントエンドライブラリーが、標準化されていないアカウントの動作を正しく実装するために、アカウントのタイプとバージョンを判断する必要がある場合に便利です。代替案としては、ERC-165のようなインターフェースを使ってアカウントの正確な違いとサポートされる機能を宣言する方法や、アカウントIDのkeccakハッシュを返す方法があります。しかし、前者の解決策はアカウントIDほど柔軟ではなく、よく定義された機能セットに合意する必要があり、後者の解決策はアカウントIDほど人間が読みやすくありません。

#### ERC-4337への依存

この標準は、検証フローにERC-4337に厳密に依存しています。ただし、将来的に、ERC-4337ではなく、ネイティブのアカウントアブストラクション実装を使ってモジュラーアカウントを構築したいスマートアカウントビルダーもいるでしょう。これが始まると、この標準の提案されるアップグレードパスは、ERC-4337の依存性を拡張(つまり別のERC)に移し、スマートアカウントが実装する必要がないようにすることです。異なるアカウントアブストラクション実装の検証フローを標準化する必要がある場合は、これらの要件も別の拡張に移動できます。

これを最初から行わない理由は、現在構築されているモジュラーアカウントがすべてERC-4337を使っているためです。したがって、まずはこれらのアカウントのインターフェースを標準化し、異なるアカウントアブストラクション実装に基づいてモジュラーアカウントがどのように見えるかについての学習が必要になったら、ERC-4337の依存性を拡張に移すのが賢明です。

## 下位互換性

### 既に展開されているスマートアカウント

すでに展開されているスマートアカウントは、ほとんどの場合、この標準を実装できるはずです。プロキシとしてデプロイされている場合は、この標準に準拠した新しいアカウント実装にアップグレードできます。アップグレード不可能なコントラクトとして
デプロイされている場合でも、例えばフォールバックハンドラーとしてコンプライアントなアダプターを追加するなどして、準拠させることができる可能性があります。

## 参考実装

スマートアカウントのフルインターフェースは、 [`IMSA.sol`](../assets/eip-7579/IMSA.sol) にあります。

## セキュリティ上の考慮事項

さらなる議論が必要です。初期的な考慮事項は以下の通りです:

- スマートアカウントで `delegatecall` 実行を実装する場合は慎重に検討する必要があります。スマートアカウントが `delegatecall` を実装する場合、ターゲットコントラクトが安全であることを確認する必要があります。そうでない場合、セキュリティ上の脆弱性が生じる可能性があります。
- モジュールの `onInstall` および `onUninstall` 関数は、予期せぬコールバック(例: 再入力)を引き起こす可能性があります。アカウント実装では、適切な保護ルーチンを実装することを検討する必要があります。さらに、モジュールが `onUninstall` でrevertすることで、アカウントがモジュールをアンインストールしてアカウントから削除するのを阻止する可能性があります。
- 一度に1つのモジュールしか有効でないタイプのモジュール(例: フォールバックハンドラー)の場合、新しいモジュールをインストールしても前のモジュールが適切にアンインストールされない可能性があります。これにより、古いモジュールが再度追加された場合に、残留状態により予期せぬ動作が発生する可能性があります。
- フォールバックハンドラーの承認制御が不十分な場合、無許可の実行が行われる可能性があります。
- 悪意のあるフックが `preCheck` または `postCheck` でrevertすると、アカウントのサービス拒否につながる可能性があります。
- 現在、アカウント設定関数(例: `installModule`)は単一の操作用に設計されています。アカウントが `address(this)` からこれらの関数を呼び出すことを許可すると、設定操作をバッチ処理できるようになります。ただし、これらの関数がより機密性が高いため、アカウントがより強力な承認制御を実装している場合、これらの対策を自己呼び出しによってバイパスできる可能性があります。

## 著作権

著作権およびそれに関連する権利は[CC0](../LICENSE.md)で放棄されています。